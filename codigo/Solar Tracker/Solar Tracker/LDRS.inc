;------------------------------------------------------------------
;
;						HEADER DE LOS LDR'S
;
;------------------------------------------------------------------
.CSEG

LDRS_INIT:
		RCALL LDRS_POINTERS_RESET
LOOP:	CLR ADC_DATA_H
		SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H
		SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H
		SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H
		SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H
		INPUT AUX,COUNTER
		INC AUX
		OUTPUT COUNTER,AUX
		CPI AUX,CANT_SAMPLES			;CHEQUEAR QUE NO ESTE HACIENDO UNO DE MENOS
		BRLO LOOP
		RCALL LDRS_POINTERS_RESET
RET

LDRS_POINTERS_RESET:
	MOVI LDR_NO_LOW,LOW(LDR_NO_BUFFER)
	MOVI LDR_NO_HIGH,HIGH(LDR_NO_BUFFER)
	MOVI LDR_SO_LOW,LOW(LDR_SO_BUFFER)
	MOVI LDR_SO_HIGH,HIGH(LDR_SO_BUFFER)

	MOVI LDR_SE_LOW,LOW(LDR_SE_BUFFER)
	MOVI LDR_SE_HIGH,HIGH(LDR_SE_BUFFER)

	MOVI LDR_NE_LOW,LOW(LDR_NE_BUFFER)
	MOVI LDR_NE_HIGH,HIGH(LDR_NE_BUFFER)

;	INPUT AUX,COUNTER
	CLR AUX
	OUTPUT COUNTER,AUX
RET

READ_LDRS:

	INPUT AUX,COUNTER			;CHEQUEO QUE SEA MENOR A CANT_SAMPLES. SI ES MAYOR, RESETEO LOS PUNTEROS. [EL BUFFER ESTA LLENO, SACO LA PRIMER MUESTRA].
	CPI AUX,CANT_SAMPLES
	BREQ _LDRS_POINTERS_RESET
	LDRS_POINTERS_RESET_RETURN:
	INPUT AUX,COUNTER
	INC AUX
	OUTPUT COUNTER,AUX
;PREGUNTAR COMO SE HACE ESTO BIEN!! CUANDO HACES UNA FUNCION Y QUERES COMPARAR E IR A LA FUNCION.
	
	RCALL READ_LDR_NO										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
	SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H

	RCALL READ_LDR_SO										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
	SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H

	RCALL READ_LDR_SE										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
	SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H

	RCALL READ_LDR_NE										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
	SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
RET

_LDRS_POINTERS_RESET:
	RCALL LDRS_POINTERS_RESET
	RJMP LDRS_POINTERS_RESET_RETURN

LDRS_MEAN:
;OBS: PARA HACER EL PROMEDIO NO IMPORTA SI NO SE TOMARON CANT_SAMPLES, EL BUFFER ESTA INICIALIZADO CON CERO.

	LDI	AUX,CANT_SAMPLES					;VECTMEAN NECESITA LA CANTIDAD DE LAS MUESTRAS

	LDIW Z,LDR_NO_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
	OUTPUT LDR_NO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.

	LDIW Z,LDR_SO_BUFFER					;UBICO EL LDR_SO EN UN PUNTERO.
	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
	OUTPUT LDR_SO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.

	LDIW Z,LDR_SE_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
	OUTPUT LDR_SE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.

	LDIW Z,LDR_NE_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
	OUTPUT LDR_NE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
RET	

READ_LDR_NO:
	LDI ADC_DATA_L,LDR_NO
	RCALL ADC_SELECT_INPUT
	RCALL ADC_SIMPLE_CONVERSION
RET

READ_LDR_SO:
	LDI ADC_DATA_L,LDR_SE
	RCALL ADC_SELECT_INPUT
	RCALL ADC_SIMPLE_CONVERSION
RET

READ_LDR_SE:
	LDI ADC_DATA_L,LDR_SE
	RCALL ADC_SELECT_INPUT
	RCALL ADC_SIMPLE_CONVERSION
RET

READ_LDR_NE:
	LDI ADC_DATA_L,LDR_NE
	RCALL ADC_SELECT_INPUT
	RCALL ADC_SIMPLE_CONVERSION
RET