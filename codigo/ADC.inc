/*
 * PRUEBA_ADC.asm
 *
 *  Created: 25/05/2016 04:10:33 a.m.
 *   Author: MAU
 *
 *	ESTE PROGRAMA RECIBE POR ADC0 UN LDR Y MANDA POR LOS 4 LEDS
 *	DE LA PLACA DEL CdR EL DATO.
 *
 */ 

.DSEG
.DEF	ADC_DATA_L = R19
.DEF	ADC_DATA_H = R20

; codigo
;-------------------------------------------------------------------------
.CSEG

ADC_INIT:
		LDI R18,0xFC
		OUT DDRC,R18
		LDI R18,0x90
		OUT DDRD,R18

/*ISR_ADC_CONVERSION_COMPLETE:
		
		INPUT AUX,ADCSRA
		SBR AUX,ADIF
		OUTPUT ADCSRA,AUX

		LDI AUX,PD7
		OUTPUT PORTD,AUX
	RETI
*/
;-------------------------------------------------------------------------
;					CONVERSOR ANALOGICO-DIGITAL
;-------------------------------------------------------------------------

ADC_INIT:
;ADMUX = REFS1 REFS0 ADLAR – MUX3 MUX2 MUX1 MUX0
;INTERNAL VREF=VCC Y EL DATO AJUSTADO A DERECHA [ADCH:ADCL]. SE SELECCIONA POR DEFECTO EL CANAL ADC1 [LDR DE LA PLACA DE CdR MODIF]
	LDI ADC_DATA_L,((0<<REFS1)|(1<<REFS0)|(0<<ADLAR)|(0<<MUX3)|(0<<MUX2)|(0<<MUX1)|(1<<MUX0))
	OUTPUT ADMUX,ADC_DATA_L
;ADCSRA = ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0		
;SE HABILITA EL ADC, AUTO TRIGGER OFF, FLAG INTERRUPCION EN CERO, PRESCALER DIV POR 64 [trabaja en aprox 100Khz]
	LDI ADC_DATA_L,((1<<ADEN)|(0<<ADSC)|(0<<ADATE)|(0<<ADIF)|(0<<ADIE)|(1<<ADPS2)|(1<<ADPS1)|(0<<ADPS0))
	OUTPUT ADCSRA,ADC_DATA_L

;SETEAR ESTE REGISTRO PARA EL MODO DE AUTO TRIGGER
;	LDI AUX,(0<<ADTS2)|(0<<ADTS1)|(0<<ADTS0)
;	OUTPUT ADCSRB,AUX

;SE DESHABILITA LA PARTE DIGITAL INTERNA DEL PIN A UTILIZAR
;HABILITO SOLO LOS LDRS
	LDI ADC_DATA_L,((0<<ADC0D)|(0<<ADC1D)|(1<<ADC2D)|(1<<ADC3D)|(1<<ADC4D)(1<<ADC5D))
	OUTPUT DIDR0,ADC_DATA_L
RET
;-------------------------------------------------------------------------

START_SIMPLE_CONVERSION:
;RECIBE: -
;DEVUELVE: RESULTADO DE LA CONVERSION EN ADC_DATA_H:ADC_DATA_L

	INPUT ADC_DATA_L,ADCSRA
	ORI ADC_DATA_L,((1<<ADEN)|(1<<ADSC))
	OUTPUT ADCSRA,ADC_DATA_L
L1:	INPUT ADC_DATA_L,ADCSRA
	SBRC ADC_DATA_L,ADSC
	RJMP L1
	ANDI ADC_DATA_L,(~(1<<ADEN))
	OUTPUT ADCSRA,ADC_DATA_L

	INPUT ADC_DATA_L,ADCL
	INPUT ADC_DATA_H,ADCH
RET
;-------------------------------------------------------------------------

ADC_SELECT_INPUT:	;ADMUX = REFS1 REFS0 ADLAR – MUX3 MUX2 MUX1 MUX0
;RECIBE: EL VALOR DEL PIN A SELECCIONAR EN ADC_DATA_L
;DEVUELVE: NADA
	PUSH ADC_DATA_H ;ESTE ES AUXILIAR PARA ESTA FUNCION

	INPUT ADC_DATA_H,ADMUX
	ANDI ADC_DATA_H,(~(1<<MUX3)|(1<<MUX2)|(1<<MUX1)|(1<<MUX0))
	ORI ADC_DATA_H,ADC_DATA_L ;NO HAY QUE HACER SHIFT
	OUTPUT ADMUX,ADC_DATA_H

	POP ADC_DATA_H
RET

/************************** EJEMPLO! ***********************************
EJEMPLO_CONVERSOR:
		INPUT AUX,ADCSRA
		ORI AUX,((1<<ADEN)|(1<<ADSC))
		OUTPUT ADCSRA,AUX

ESPERO:	INPUT AUX,ADCSRA
		SBRC AUX,ADSC
		RJMP ESPERO
		ANDI AUX,(~(1<<ADEN))
		OUTPUT ADCSRA,AUX
;SE INICIA LA CONVERSION [ADEN=1]Y SE ESPERA A QUE TERMINE [ADSC=1] ?? O ADIF ???
		INPUT AUX,ADCH
		CPI AUX,0x00		
		BREQ LED1
		CPI AUX,0x01		
		BREQ LED2
		CPI AUX,0x02		
		BREQ LED3
		CPI AUX,0x03		
		BREQ LED4	

SIGO:	RCALL DELAY
		RJMP EJEMPLO_CONVERSOR

************************************************************************/