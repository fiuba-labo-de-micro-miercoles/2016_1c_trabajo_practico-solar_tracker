
AVRASM ver. 2.1.57  C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm Tue Jun 21 01:55:46 2016

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m88def.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(8): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m88def.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(9): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar_Tracker.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(10): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\avr_macros.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(157): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\ADC.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(158): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\PWM.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(159): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\SERIAL_PORT.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(160): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\DELAY.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(161): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\LIGHT.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(162): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\BATTERY.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(163): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\SOLAR_PANEL.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(164): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\LDRS.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(165): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MOTORS.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(166): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc'
                 
                 /*
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega88.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m88def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega88
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega88
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M88DEF_INC_
                 #define _M88DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega88
                 #pragma AVRPART ADMIN PART_NAME ATmega88
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x0a
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0A_0	= 0	; 
                 .equ	OCR0A_1	= 1	; 
                 .equ	OCR0A_2	= 2	; 
                 .equ	OCR0A_3	= 3	; 
                 .equ	OCR0A_4	= 4	; 
                 .equ	OCR0A_5	= 5	; 
                 .equ	OCR0A_6	= 6	; 
                 .equ	OCR0A_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - 
                 .equ	SE	= 0	; 
                 .equ	SM0	= 1	; 
                 .equ	SM1	= 2	; 
                 .equ	SM2	= 3	; 
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x04ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0003	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0004	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x0005	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x0006	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x0007	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0008	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0009	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x000a	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x000b	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x000c	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x000d	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x000e	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x000f	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0010	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0011	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0012	; USART Rx Complete
                 .equ	UDREaddr	= 0x0013	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0014	; USART Tx Complete
                 .equ	ADCCaddr	= 0x0015	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x0016	; EEPROM Ready
                 .equ	ACIaddr	= 0x0017	; Analog Comparator
                 .equ	TWIaddr	= 0x0018	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0019	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 26	; size in words
                 
                 #endif  /* _M88DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                  * Solar_Tracker.asm
                  *
                  *  Created: 08/06/2016 07:45:11 p.m.
                  *   Author: Agustn Picard, Joaquin Ulloa, Mauro Giordano
                  */ 
                 
                 .include "m88def.inc"   	;Incluye los nombres de los registros del micro
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega88.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m88def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega88
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega88
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M88DEF_INC_
                 #endif  /* _M88DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 .include "Solar_Tracker.inc"
                 
                 
                 	 Me parece mas comodo e intuitivo
                 	poner los registros y definiciones
                 		en un header general
                 
                 ******************************************/
                 .DSEG
                 .ORG SRAM_START
                 
                 ;--------------------HEADER DE LA LUZ-----------------------------------------------
                 .EQU	LIGHT_PIN					=	PD3
                 ;-----------------------------------------------------------------------------------
                 
                 
                 ;--------------------HEADER DEL ADC-------------------------------------------------
                 .DEF	ADC_DATA_L					=	R19
                 .DEF	ADC_DATA_H					=	R20
                 
                 .EQU	ADC_BATTERY					=	6		;LA BATERIA ESTA EN EL PIN 19 [ADC6]
                 .EQU	ADC_SOLAR_PANEL				=	7		;EL PANEL ESTA EN EL PIN 22 [ADC7]
                 ;-----------------------------------------------------------------------------------
                 
                 
                 ;--------------------HEADER DEL PUERTO SERIE----------------------------------------
                 .EQU	BAUD_RATE					=	103	; 12	76.8 kbps e=0.2%	@8MHz y U2X=1
                 											; 25	38.4 kbps e=0.2%	@8MHz y U2X=1
                 											; 51	19.2 kbps e=0.2% 	@8MHz y U2X=1
                 											; 103	9600 bps  e=0.2% 	@8MHz y U2X=1
                 
                 .EQU	BUF_SIZE					=	 64	;tamao en bytes del buffer de transmisin
                 
                 ;SERIE DE COMANDOS DE RECEPCION POR BT
                 .EQU	BT_COMMAND_PROJECT_NAME		=	'q'
                 .EQU	BT_COMMAND_V_BAT			=	'w'
                 .EQU	BT_COMMAND_V_PANEL			=	'e'
                 .EQU	BT_COMMAND_LIGHT_TURN_ON	=	'r'
                 .EQU	BT_COMMAND_LIGHT_TURN_OFF	=	't'
                 .EQU	BT_COMMAND_DISCONNECT		=	'y'
                 .EQU	BT_COMMAND_ELEVATION_NORTH	=	'u'
                 .EQU	BT_COMMAND_ELEVATION_SOUTH	=	'i'
                 .EQU	BT_COMMAND_AZIMUT_EAST		=	'o'
                 .EQU	BT_COMMAND_AZIMUT_WEST		=	'p'
                 .EQU	BT_COMMAND_RESET			=	'z'
                 
                 
000100           TX_BUF:	.BYTE	BUF_SIZE	; buffer de transmisin
                 
                 .DEF	PTR_TX_L					=	R8		;puntero al buffer de datos a transmitir
                 .DEF	PTR_TX_H					=	R9
                 .DEF	BYTES_A_TX					=	R10 	;nro. de bytes a transmitir desde el buffer
                 ;-----------------------------------------------------------------------------------
                 
                 ;--------------------------------HEADER DE LA BATERIA-------------------------------
                 .EQU	PIN_BATTERY_LED_OK			=	PD4
                 .EQU	PIN_BATTERY_LED_LOW			=	PD7
                 
                 .EQU	MIN_BATTERY_VALUE			=	170		;{0,255} RESULTADO DEL ADC QUE HACE IR A BAJO CONSUMO EL EQUIPO POR NO TENER SUFICIENTE TENSION
                 										;YA ESTA AJUSTADO! 10.6v
000140           V_BATTERY_DATA:		.BYTE 8			;[DECENA,UNIDAD,'.',DECIMAL,'V','\r','\n',0]
                 ;-----------------------------------------------------------------------------------
                 
                 ;-------------------------------HEADER DEL PANEL SOLAR------------------------------
                 .EQU	PIN_SOLAR_PANEL_LED_OK		=	PC1
                 .EQU	PIN_SOLAR_PANEL_LED_LOW		=	PC0
                 
                 .EQU	MIN_SOLAR_PANEL_VALUE		=	50		;{0,255} RESULTADO DEL ADC QUE DECIDE SI ES DE DIA O NOCHE.
                 										;FALTA AJUSTAR CON EL SOL! .... O CON LO QUE VAMOS A MOSTRAR!
000148           V_SOLAR_PANEL_DATA: .BYTE 8			;[DECENA,UNIDAD,'.',DECIMAL,'V','\r','\n',0]
                 ;-----------------------------------------------------------------------------------
                 
                 ;--------------------REGISTROS DE USO GENERAL SIN IMPORTAR QUE TENGA----------------
                 .DEF	AUX							=	R16
                 .DEF	AUX1						=	R17
                 .DEF	AUX2						=	R18
                 .DEF	AUX3						=	R22
                 .DEF	AUX4						=	R23
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DE LDRS---------------------------------------
                 .EQU CANT_SAMPLES = 8 ;TIENE QUE SER MULTIPLO DE 2
                 
000150           LDR_NO_BUFFER:						.BYTE CANT_SAMPLES
000158           LDR_NE_BUFFER:						.BYTE CANT_SAMPLES
000160           LDR_SE_BUFFER:						.BYTE CANT_SAMPLES
000168           LDR_SO_BUFFER:						.BYTE CANT_SAMPLES
000170           LDR_NO_MEAN:						.BYTE 1
000171           LDR_NE_MEAN:						.BYTE 1
000172           LDR_SE_MEAN:						.BYTE 1
000173           LDR_SO_MEAN:						.BYTE 1
000174           COUNTER:							.BYTE 2
000176           BT_FLAG:							.BYTE 1				;[FLAG=0xFF]: ESTA CONECTADO A BT. [FLAG=0x00]: NO ESTA CONECTADO A BT.
                 
                 
                 ;LAS CONSTANTES SON PARA EL MUX EN EL ADC
                 .EQU LDR_NO							=	3	;ADC2
                 .EQU LDR_NE							=	2	;ADC3
                 .EQU LDR_SE							=	4	;ADC4
                 .EQU LDR_SO							=	5	;ADC5		NO USAR EL ADC5 PARA COMPARAR! FUERA DE ESCALA LA RESISTENCIA DEL LDR
                 
                 .DEF LDR_NO_LOW						=	R2
                 .DEF LDR_NO_HIGH					=	R3
                 .DEF LDR_NE_LOW						=	R4
                 .DEF LDR_NE_HIGH					=	R5
                 .DEF LDR_SE_LOW						=	R6
                 .DEF LDR_SE_HIGH					=	R7
                 .DEF LDR_SO_LOW						=	R11
                 .DEF LDR_SO_HIGH					=	R12
                 
                 
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DEL PWM---------------------------------------
                 .DEF PWM_DATA					 	=	R21
                 
                 .EQU PWM_AZIMUT_DEFAULT				=	190		;{0,255} PARA SETEAR EL PWM
                 .EQU PWM_ELEVATION_DEFAULT			=	190		;{0,255} PARA SETEAR EL PWM
                 										;200 ES 10V APROX.
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DE MOTORES------------------------------------
                 
                 .EQU MOT_1							=	PD5
                 .EQU MOT_2							=	PD6
                 
                 ;-----------------------------------------------------------------------------------
                 .include "avr_macros.inc"	;Incluye los macros
                 
                 ; coleccin de macros para microcontroladores AVR
                 ;------------------------------------------------------------------
                 ; Sintaxis:
                 ; 	.macro NOMBRE_MACRO
                 ; 		; cuerpo de la macro
                 ;		; los parmetros de la macro se referencian como
                 ;		; @0 (1er parmetro), @1 (2do parmetro), etc.
                 ; 	.endm
                 ;------------------------------------------------------------------
                 
                 ;------------------------------------------------------------------
                 ; input: resuelve si usa "in"/"lds" segn la direccin del registro
                 ;        de E/S que se lee.
                 ;------------------------------------------------------------------
                 .macro	input ; @0= destino {r0, ... , r31}
                               ; @1= fuente I/0 ($0000-$FFFF)
                 .if	@1<0x40
                 	in	@0,@1	; si dir del reg de E/S <0x40 uso "in"
                 .else
                 	lds	@0,@1	; sino uso "lds"
                 .endif
                 .endm
                 
                 ;------------------------------------------------------------------
                 ; output: resuelve si usa "out"/"sts" segn la direccin del registro
                 ;         de E/S que se escribe.
                 ;------------------------------------------------------------------
                 .macro	output		; @0= destino I/O ($0000-$FFFF)
                 			; @1= fuente, cte o r0..r31
                 .if	@0<0x40
                 		out	@0,@1	; si dir del reg de E/S <0x40 uso "out"
                 .else
                 		sts	@0,@1	; sino uso "sts"
                 .endif
                 .endm
                 
                 .macro	ldiw		; carga puntero
                 		ldi	@0L, LOW(@1)
                 		ldi	@0H, HIGH(@1)
                 .endm
                 
                 .macro	movi	; carga registro con constante
                 		ldi	AUX,@1
                 		mov	@0,AUX
                 .endm
                 
                 .macro	outi
                 		ldi		AUX,@1
                 		output	@0,AUX  ;FIGURABA R16!!!!! OJO!
                 .endm
                 
                 
                 .macro	pushw	;@0		; Pone el puntero @0 de 16 bits en la pila
                 		push	@0L
                 		push	@0H
                 .endm
                 
                 
                 .macro	popw	;@0		; Saca el puntero @0 de 16 bits de la pila
                 		pop		@0H
                 		pop		@0L
                 .endm
                 
                 
                 .macro	pushi	;@0			; Pone en pila un registro de I/O
                 			in		AUX,@0	; usa la variable auxiliar t0
                 			push	AUX
                 .endm
                 
                 
                 .macro	popi	;@0			; Saca de pila un registro de I/O
                 			pop		AUX		; usa la variable auxiliar t0
                 			out		@0,AUX
                 .endm
                 
                 .macro	sti		;@0,@1	; Guarda una constante de modo indirecto
                 		ldi		AUX4,@1	; Usa: variable auxiliar "t0" y un puntero
                 		st		@0,AUX4	; [3 ciclos, 2 words] @0={X, Y, Z}
                 .endm
                 
                 .macro	stsi	;@0,@1	; Guarda una constante en SRAM
                 		ldi		AUX,@1	; Usa: variable auxiliar "t0".
                 		sts		@0,AUX	; [3 ciclos, 2 words] @0={any SRAM ADDRESS}
                 .endm
                 
                 ;---------------------MACROS PROPIAS-----------------------------------------------
                 .macro SLDR
                 ;STORE_LDR
                 ;PROTOTYPE: SLDR LDR_XX_LOW,LDR_XX_HIGH,ADC_DATA_H
                 ;RECIBE: ADC_DATA_H EL VALOR DEL LDR
                 ;DEVUELVE: -
                 	MOV	ZL,@0
                 	MOV	ZH,@1	
                 	ST	Z+,@2
                 	MOV	@0,ZL
                 	MOV	@1,ZH
                 .endm
                 
                 .macro LLDR
                 ;LOAD_LDR_TO_POINTER
                 ;PROTOTYPE: LLDR Z,LDR_XX_LOW,LDR_XX_HIGH
                 	LDI @0L,@1
                 	LDI @0H,@2
                 .endm
                 
                 .macro VECTMEAN	;@0,@1,@2	;Calcula la media de un vector @0 de longitud @1 y guarda la media en @2
                 		PUSH		@1
                 		LD 		AUX3,@0+
                 		CLR		@2
                 		DEC		@1
                 		CLR		AUX2
                 loop_mean:
                 		CLV
                 		LD		AUX4,@0+
                 		ADD		AUX3,AUX4
                 		ADC		@2,AUX2
                 		DEC		@1
                 		BRNE		loop_mean
                 		LDI		AUX2,3
                 division:
                 		LSR		@2
                 		ROR		AUX3
                 		DEC		AUX2
                 		BRNE		division
                 		MOV		@2,AUX3
                 		POP		@1
                 .endm
                 
                 
                 .macro SPWM 
                 ;PROTOTYPE SET_PWM: SPWM OCRnx,PWM_DATA
                 ;RECIBE: OCRnx,PWM_DATA
                 ;DEVUELVE: .
                 	OUTPUT @0,@1
                 .endm
                 
                 .macro RPWM 
                 ;PROTOTYPE RESET_PWM: RPWM OCRnx
                 ;RECIBE: OCRnx
                 ;DEVUELVE: -
                 	CLR AUX
                 	OUTPUT @0,AUX
                 .endm
                 
                 .macro ADDI
                 ;PROTOTYPE ADDI: REG,CTE
                 ;RECIBE: REG,CTE
                 ;DEVUELVE: Suma de cte al registro
                 	LDI AUX4,@1
                 	ADD @0,AUX4
                 .endm
                 
                 .macro ADDP
                 ;PROTOTYPE ADDP: POINTER,REG
                 ;RECIBE: POINTER,REG
                 ;DEVUELVE: Pointer en posicin inicial + AUX
                 	ADD @0L,@1
                 	BRVC NO_POINTER_OV
                 	INC @0H
                 	SUB @1,@0L
                 	MOV @1,@0L
                 NO_POINTER_OV: NOP
                 .endm
                 .listmac					;Permite que se expandan las macros en el listado
                 
                 .CSEG
                 .ORG 0x0000
000000 c019      RJMP SETUP	
                 
                 .ORG	INT0addr
000001 c058      RJMP	ISR_INT0
                 
                 .ORG	URXCaddr		; USART, Rx Complete
000012 c0d2      RJMP	ISR_RX_USART_COMPLETA
                 	
                 .ORG	UDREaddr		; USART Data Register Empty
000013 c131      RJMP	ISR_REG_USART_VACIO
                 
                 .ORG	OVF1addr
00000d c04d      RJMP	ISR_TIMER_1_OV
                 
                 ;-------------------------------SETUP--------------------------------------------
                 .ORG	INT_VECTORS_SIZE
                 SETUP:
00001a ef0f      	LDI AUX,LOW(RAMEND)
00001b bf0d      	OUT SPL,AUX
00001c e004      	LDI	AUX,HIGH(RAMEND)
00001d bf0e      	OUT SPH,AUX
                 
00001e d11f      	RCALL BT_DISCONNECT		;[FLAG=0xFF]: ESTA CONECTADO A BT. [FLAG=0x00]: NO ESTA CONECTADO A BT.
00001f d1cb      	RCALL BATTERY_INIT
000020 d23e      	RCALL SOLAR_PANEL_INIT
000021 d04d      	RCALL ADC_INIT			;TIENE QUE ESTAR EN "ADC.inc"
                 
000022 d30c      	RCALL LDRS_INIT
000023 d09d      	RCALL SERIAL_PORT_INIT	;TIENE QUE ESTAR EN "SERIAL_PORT.inc"
000024 d3cb      	RCALL MOTORS_INIT
000025 d1a3      	RCALL LIGHT_INIT	;TIENE QUE ESTAR EN "LIGHT.inc"
                 
000026 9478      	SEI
                 
                +
000027 e3e2     +ldi ZL , LOW ( ( MSJ_PROJECT_NAME * 2 ) )
000028 e0f9     +ldi ZH , HIGH ( ( MSJ_PROJECT_NAME * 2 ) )
                 	LDIW	Z,(MSJ_PROJECT_NAME*2)
000029 d13c      	RCALL	TRANSMITIR_MENSAJE
00002a d188      	RCALL	DELAY_50ms
                 
00002b c000      RJMP MAIN
                 
                 ;-------------------------------PROGRAMA_PRINCIPAL-------------------------------
                 MAIN:	
                 	;MIDO LA BATERIA
00002c d1d6      		RCALL	READ_V_BATTERY					
00002d d1ec      		RCALL	VBATTERY_TO_ASCII
00002e d1d8      		RCALL	CHECK_IF_BATTERY_MINIMUM		;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
00002f f0f0      		BRCS	SLEEP_MODE
000030 d1e3      		RCALL	INDICATE_BATTERY_OK
                 
                +
000031 e5e6     +ldi ZL , LOW ( ( MSJ_V_BAT * 2 ) )
000032 e0f9     +ldi ZH , HIGH ( ( MSJ_V_BAT * 2 ) )
                 		LDIW	Z,(MSJ_V_BAT*2)
                +
000033 e4c0     +ldi YL , LOW ( V_BATTERY_DATA )
000034 e0d1     +ldi YH , HIGH ( V_BATTERY_DATA )
                 		LDIW	Y,V_BATTERY_DATA
000035 d14d      		RCALL	TRANSMITIR_TENSION	
000036 d17c      		RCALL	DELAY_50ms
                 
                 	;DIA O NOCHE?
000037 d23f      		RCALL	READ_V_SOLAR_PANEL				;PARA VER SI ES DE DIA O NOCHE, MIDO LA TENSION DEL PANEL SOLAR.
000038 d2b3      		RCALL	VPANEL_TO_ASCII
000039 d241      		RCALL	CHECK_IF_SOLAR_PANEL_MINIMUM	;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
00003a f108      		BRCS	AT_NIGHT
00003b d24c      		RCALL	INDICATE_SOLAR_PANEL_OK
                 
                +
00003c e7e4     +ldi ZL , LOW ( ( MSJ_V_PANEL * 2 ) )
00003d e0f9     +ldi ZH , HIGH ( ( MSJ_V_PANEL * 2 ) )
                 		LDIW	Z,(MSJ_V_PANEL*2)
                +
00003e e4c8     +ldi YL , LOW ( V_SOLAR_PANEL_DATA )
00003f e0d1     +ldi YH , HIGH ( V_SOLAR_PANEL_DATA )
                 		LDIW	Y,V_SOLAR_PANEL_DATA
000040 d142      		RCALL	TRANSMITIR_TENSION	
000041 d171      		RCALL	DELAY_50ms
                 ;SI ESTOY ACA YA TENGO BATERIA SUFICIENTE, ES DE DIA.
000042 d31f      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
000043 d168      		RCALL	DELAY_100us
000044 d31d      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
000045 d166      		RCALL	DELAY_100us
000046 d165      		RCALL	DELAY_100us
000047 d31a      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
000048 d163      		RCALL	DELAY_100us
000049 d318      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
00004a d161      		RCALL	DELAY_100us
00004b d316      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
00004c d339      		RCALL	LDRS_MEAN
                 
00004d d240      		RCALL	ORIENTATE_SOLAR_PANEL			;HAY QUE RESOLVER ESTO TODAVIA.
                 
                 SLEEP_MODE:
00004e d010      		RCALL SLEEP_TIMER_INIT
                +
                +
                +.if SMCR < 0x40
00004f b703     +in AUX , SMCR
                +.else 
                +lds AUX , SMCR
                 		INPUT AUX,SMCR
000050 7f00      		ANDI AUX,((~((1<<SM2)|(1<<SM1)|(1<<SM0)|(1<<SE))))
000051 6001      		ORI AUX,((0<<SM2)|(0<<SM1)|(0<<SM0)|(1<<SE))	;SETEO EL MODO IDLE.
                +
                +
                +.if SMCR < 0x40
000052 bf03     +out SMCR , AUX
                +.else 
                +sts SMCR , AUX
                 		OUTPUT SMCR,AUX
000053 9588      		SLEEP
000054 0000      		NOP
                +
                +
                +.if SMCR < 0x40
000055 b703     +in AUX , SMCR
                +.else 
                +lds AUX , SMCR
                 		INPUT AUX,SMCR
000056 7f0e      		ANDI AUX,(~(1<<SE))								;CUANDO SALGO DE SLEEP, PONGO SE=0.
000057 6000      		ORI AUX,(0<<SE)
                +
                +
                +.if SMCR < 0x40
000058 bf03     +out SMCR , AUX
                +.else 
                +sts SMCR , AUX
                 		OUTPUT SMCR,AUX
000059 cfd2      RJMP MAIN
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------MAIN_FUNCTIONS---------------------------------------
                 ISR_INT0:
00005a 9518      RETI
                 
                 ISR_TIMER_1_OV:
00005b 9518      RETI
                 
                 AT_NIGHT:
00005c d171      	RCALL LIGHT_TURN_ON
00005d d225      	RCALL INDICATE_SOLAR_PANEL_LOW
                 ;---------------------------------------------------------->> VOLVER AL ORIGEN!!!
                 	;RCALL RETURN_TO_ORIGIN
00005e cfef      	RJMP SLEEP_MODE
                 
                 /*------------NO LA UTILIZAMOS, YA QUE EN 'IDLE' SE DESPIERTA POR TRANSMISION BT.
                 INT_EXT_INIT:
                 		;SETEO EL PIN INT0 (PD2) COMO ENTRADA.
                 		INPUT	AUX,DDRD
                 		ANDI	AUX,(~(1<<PD2))
                 		OUTPUT	DDRD,AUX
                 
                 		;SETEO PARA QUE SALTE LA INT0 SI HAY CUALQUIER CAMBIO.
                 		ANDI	AUX,(~((1<<ISC00)|(1<<ISC01)))
                 		ORI		AUX,((1<<ISC00)|(0<<ISC01))		
                 		OUTPUT	EICRA,AUX
                 	
                 		;HABILITO LA INTERRUPCION INT0.
                 		INPUT	AUX,EIMSK
                 		ANDI	AUX,~((1<<INT0)|(1<<INT1))		
                 		ORI		AUX,((1<<INT0)|(0<<INT1))
                 		OUTPUT	EIMSK,AUX
                 RET
                 */
                 
                 SLEEP_TIMER_INIT:
00005f ee0e      			LDI	AUX,0xEE		;Pongo como valor inicial del timer 34286 para que cuando haga overflow haya contado (8E6)/256
                +
                +
                +.if TCNT1L < 0x40
                +out TCNT1L , AUX
000060 9300 0084+.else 
                +sts TCNT1L , AUX
                 			OUTPUT TCNT1L,AUX
000062 e805      			LDI AUX,0x85
                +
                +
                +.if TCNT1H < 0x40
                +out TCNT1H , AUX
000063 9300 0085+.else 
                +sts TCNT1H , AUX
                 			OUTPUT TCNT1H,AUX
000065 e004      			LDI AUX,(1<<CS12)|(0<<CS11)|(0<<CS10)		;Seteo el prescaler a 256
                +
                +
                +.if TCCR1B < 0x40
                +out TCCR1B , AUX
000066 9300 0081+.else 
                +sts TCCR1B , AUX
                 			OUTPUT TCCR1B,AUX
000068 e000      			LDI AUX,0
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , AUX
000069 9300 0080+.else 
                +sts TCCR1A , AUX
                 			OUTPUT TCCR1A,AUX
00006b e001      			LDI AUX,(1<<TOIE1)
                +
                +
                +.if TIMSK1 < 0x40
                +out TIMSK1 , AUX
00006c 9300 006f+.else 
                +sts TIMSK1 , AUX
                 			OUTPUT TIMSK1,AUX
00006e 9508      RET
                 
                 .include "ADC.inc"
                 
                  * PRUEBA_ADC.asm
                  *
                  *  Created: 25/05/2016 04:10:33 a.m.
                  *   Author: MAU
                  *
                  *	ESTE PROGRAMA RECIBE POR ADC0 UN LDR Y MANDA POR LOS 4 LEDS
                  *	DE LA PLACA DEL CdR EL DATO.
                  *
                  */ 
                 
                 ; codigo
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 /*ISR_ADC_CONVERSION_COMPLETE:
                 		
                 		INPUT AUX,ADCSRA
                 		SBR AUX,ADIF
                 		OUTPUT ADCSRA,AUX
                 
                 		LDI AUX,PD7
                 		OUTPUT PORTD,AUX
                 	RETI
                 */
                 ;-------------------------------------------------------------------------
                 ;					CONVERSOR ANALOGICO-DIGITAL
                 ;-------------------------------------------------------------------------
                 
                 ADC_INIT:
                 ;ADMUX = REFS1 REFS0 ADLAR  MUX3 MUX2 MUX1 MUX0
                 ;INTERNAL VREF=VCC Y EL DATO AJUSTADO A IZQUIERDA! [ADCH:ADCL]. SE SELECCIONA POR DEFECTO EL CANAL ADC1 [LDR DE LA PLACA DE CdR MODIF]
00006f e634      	LDI ADC_DATA_L,((0<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0<<MUX3)|(1<<MUX2)|(0<<MUX1)|(0<<MUX0))
                +
                +
                +.if ADMUX < 0x40
                +out ADMUX , ADC_DATA_L
000070 9330 007c+.else 
                +sts ADMUX , ADC_DATA_L
                 	OUTPUT ADMUX,ADC_DATA_L
                 ;ADCSRA = ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0		
                 ;SE HABILITA EL ADC, AUTO TRIGGER OFF, FLAG INTERRUPCION EN CERO, PRESCALER DIV POR 64 [trabaja en aprox 100Khz]
000072 e836      	LDI ADC_DATA_L,((1<<ADEN)|(0<<ADSC)|(0<<ADATE)|(0<<ADIF)|(0<<ADIE)|(1<<ADPS2)|(1<<ADPS1)|(0<<ADPS0))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , ADC_DATA_L
000073 9330 007a+.else 
                +sts ADCSRA , ADC_DATA_L
                 	OUTPUT ADCSRA,ADC_DATA_L
                 
                 ;SETEAR ESTE REGISTRO PARA EL MODO DE AUTO TRIGGER
                 ;	LDI AUX,(0<<ADTS2)|(0<<ADTS1)|(0<<ADTS0)
                 ;	OUTPUT ADCSRB,AUX
                 
                 ;SE DESHABILITA LA PARTE DIGITAL INTERNA DEL PIN A UTILIZAR
                 ;HABILITO SOLO LOS LDRS
000075 e33c      	LDI ADC_DATA_L,((1<<ADC2D)|(1<<ADC3D)|(1<<ADC4D)|(1<<ADC5D))
                +
                +
                +.if DIDR0 < 0x40
                +out DIDR0 , ADC_DATA_L
000076 9330 007e+.else 
                +sts DIDR0 , ADC_DATA_L
                 	OUTPUT DIDR0,ADC_DATA_L
000078 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ADC_SELECT_INPUT:
                 ;ADMUX = REFS1 REFS0 ADLAR  MUX3 MUX2 MUX1 MUX0
                 ;RECIBE: EL VALOR DEL PIN A SELECCIONAR EN ADC_DATA_L
                 ;DEVUELVE: NADA
                +
                +
                +.if ADMUX < 0x40
                +in AUX , ADMUX
000079 9100 007c+.else 
                +lds AUX , ADMUX
                 	INPUT AUX,ADMUX
00007b 7f00      	ANDI AUX,(~((1<<MUX3)|(1<<MUX2)|(1<<MUX1)|(1<<MUX0)))
00007c 2b03      	OR AUX,ADC_DATA_L;NO HAY QUE HACER SHIFT
                +
                +
                +.if ADMUX < 0x40
                +out ADMUX , AUX
00007d 9300 007c+.else 
                +sts ADMUX , AUX
                 	OUTPUT ADMUX,AUX
                 
00007f 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ADC_SIMPLE_CONVERSION:
                 ;RECIBE: -
                 ;DEVUELVE: RESULTADO DE LA CONVERSION EN ADC_DATA_H:ADC_DATA_L
                 
                +
                +
                +.if ADCSRA < 0x40
                +in AUX , ADCSRA
000080 9100 007a+.else 
                +lds AUX , ADCSRA
                 	INPUT AUX,ADCSRA
000082 6c00      	ORI AUX,((1<<ADEN)|(1<<ADSC))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , AUX
000083 9300 007a+.else 
                +sts ADCSRA , AUX
                 	OUTPUT ADCSRA,AUX
                +
                +
                +.if ADCSRA < 0x40
                +in AUX , ADCSRA
000085 9100 007a+.else 
                +lds AUX , ADCSRA
                 L2:	INPUT AUX,ADCSRA
000087 fd06      	SBRC AUX,ADSC
000088 cffc      	RJMP L2
000089 770f      	ANDI AUX,(~(1<<ADEN))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , AUX
00008a 9300 007a+.else 
                +sts ADCSRA , AUX
                 	OUTPUT ADCSRA,AUX
                 
                +
                +
                +.if ADCL < 0x40
                +in ADC_DATA_L , ADCL
00008c 9130 0078+.else 
                +lds ADC_DATA_L , ADCL
                 	INPUT ADC_DATA_L,ADCL
                +
                +
                +.if ADCH < 0x40
                +in ADC_DATA_H , ADCH
00008e 9140 0079+.else 
                +lds ADC_DATA_H , ADCH
                 	INPUT ADC_DATA_H,ADCH
                 
000090 9508      RET
                 
                 /************************** EJEMPLO! ***********************************
                 EJEMPLO_CONVERSOR:
                 		INPUT AUX,ADCSRA
                 		ORI AUX,((1<<ADEN)|(1<<ADSC))
                 		OUTPUT ADCSRA,AUX
                 
                 ESPERO:	INPUT AUX,ADCSRA
                 		SBRC AUX,ADSC
                 		RJMP ESPERO
                 		ANDI AUX,(~(1<<ADEN))
                 		OUTPUT ADCSRA,AUX
                 ;SE INICIA LA CONVERSION [ADEN=1]Y SE ESPERA A QUE TERMINE [ADSC=1] ?? O ADIF ???
                 		INPUT AUX,ADCH
                 		CPI AUX,0x00		
                 		BREQ LED1
                 		CPI AUX,0x01		
                 		BREQ LED2
                 		CPI AUX,0x02		
                 		BREQ LED3
                 		CPI AUX,0x03		
                 		BREQ LED4	
                 
                 SIGO:	RCALL DELAY
                 		RJMP EJEMPLO_CONVERSOR
                 
                 .include "PWM.inc"
                 
                 ;* 	CODIGO PWM 
                 ;*
                 ;*  Created: 29/05/2016
                 ;*  Autor: Mauro Giordano, Agustin Picard, Joaqun Ulloa
                 ;*	
                 ;*	f_outPWM = f_clkIO / (prescaler * 256)
                 ;*	Configuracion Fast Pwm
                 ;*	
                 ;*****************************************************
                 .CSEG
                 PWM_INIT:
                 ;	RCALL PWM_INIT_0
000091 d001      	RCALL PWM_INIT_1
                 ;	RCALL PWM_INIT_2
                 ;COMENTO LA FUNCION ANTERIOR PORQUE VAMOS A USAR MOTORES DE CONTINUA PUESTOS EN OC1A Y OC1B QUE SON LOS DEL PUERTO B SOLAMENTE.
000092 9508      RET
                 
                 /*PWM_INIT_0:
                 ;Se inicializan como salida los pines de PWM
                 	INPUT PWM_DATA,DDRD
                 	ANDI PWM_DATA,(~((1<<DDD5)|(1<<DDD6)))	;Mascara para tocar solo D5 Y D6
                 	ORI PWM_DATA,((1<<DDD5)|(1<<DDD6))
                 	OUTPUT DDRD,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM02=0 (por defecto), WGM01=1 y WGM00=1
                 	;Non-inverting mode: COM0A1=1 y COM0A0=0
                 	INPUT PWM_DATA,TCCR0A	;Timer/counter control register A
                 	ANDI PWM_DATA,(~((1<<WGM01)|(1<<WGM00)|(1<<COM0A1)|(1<<COM0A0)|(1<<COM0B1)|(1<<COM0B0)))
                 	ORI PWM_DATA,((1<<WGM01)|(1<<WGM00)|(1<<COM0A1)|(0<<COM0A0)|(1<<COM0B1)|(0<<COM0B0))	;fast PWM, non-inverting
                 	OUTPUT TCCR0A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                 	INPUT PWM_DATA,TCCR0B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
                 	ANDI PWM_DATA,(~((1<<CS00)|(1<<CS01)|(1<<CS02)))
                 	ORI PWM_DATA,((0<<CS00)|(1<<CS01)|(0<<CS02))	;Ver tabla prescalers al final del archivo
                 	OUTPUT TCCR0B,PWM_DATA
                 ;Se inicializa el pwm en cero
                 	CLR	AUX
                 	OUTPUT	OCR0A,AUX
                 	OUTPUT	OCR0B,AUX
                 RET
                 */
                 ;*****************************************************
                 
                 PWM_INIT_1:
                 ;Se inicializan como salida los pines de PWM
                +
                +
                +.if DDRB < 0x40
000093 b154     +in PWM_DATA , DDRB
                +.else 
                +lds PWM_DATA , DDRB
                 	INPUT PWM_DATA,DDRB
000094 7f59      	ANDI PWM_DATA,(~((1<<DDB1)|(1<<DDB2)))	;Mascara para tocar solo B1 Y B2
000095 6056      	ORI PWM_DATA,((1<<DDB1)|(1<<DDB2))
                +
                +
                +.if DDRB < 0x40
000096 b954     +out DDRB , PWM_DATA
                +.else 
                +sts DDRB , PWM_DATA
                 	OUTPUT DDRB,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM02=0 (por defecto), WGM01=1 y WGM00=1
                 	;Non-inverting mode: COM0A1=1 y COM0A0=0
                 	;Descripcion de registros en seccion 15.9 (pag 106-112)
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000097 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000099 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
00009a 6f51      	ORI PWM_DATA,((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
00009b 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                +
                +
                +.if TCCR1B < 0x40
                +in PWM_DATA , TCCR1B
00009d 9150 0081+.else 
                +lds PWM_DATA , TCCR1B
                 	INPUT PWM_DATA,TCCR1B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
00009f 7e50      	ANDI PWM_DATA,(~((1<<WGM13)|(1<<WGM12)|(1<<CS10)|(1<<CS11)|(1<<CS12)))
0000a0 605a      	ORI PWM_DATA,((0<<WGM13)|(1<<WGM12)|(0<<CS10)|(1<<CS11)|(0<<CS12))	;Prescaler = 8
                +
                +
                +.if TCCR1B < 0x40
                +out TCCR1B , PWM_DATA
0000a1 9350 0081+.else 
                +sts TCCR1B , PWM_DATA
                 	OUTPUT TCCR1B,PWM_DATA
                 
0000a3 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
0000a4 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
0000a6 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                +
                +
                +.if OCR1AH < 0x40
                +out OCR1AH , AUX
0000a8 9300 0089+.else 
                +sts OCR1AH , AUX
                 	OUTPUT	OCR1AH,AUX
                +
                +
                +.if OCR1BH < 0x40
                +out OCR1BH , AUX
0000aa 9300 008b+.else 
                +sts OCR1BH , AUX
                 	OUTPUT	OCR1BH,AUX
0000ac 9508      RET
                 
                 ;*****************************************************
                 PWM_INIT_2:
                 ;Se inicializan como salida los pines de PWM
                 ;Se usa uno solo de los pines (para la luz), el otro es el MOSI, lo dejamos solo para programar
                +
                +
                +.if DDRD < 0x40
0000ad b15a     +in PWM_DATA , DDRD
                +.else 
                +lds PWM_DATA , DDRD
                 	INPUT PWM_DATA,DDRD
0000ae 7f57      	ANDI PWM_DATA,(~(1<<DDD3))	;Mascara para tocar solo D3
0000af 6058      	ORI PWM_DATA,((1<<DDD3))
                +
                +
                +.if DDRD < 0x40
0000b0 b95a     +out DDRD , PWM_DATA
                +.else 
                +sts DDRD , PWM_DATA
                 	OUTPUT DDRD,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM22=0 (por defecto), WGM21=1 y WGM20=1
                 	;Non-inverting mode: COM2A1=1 y COM2A0=0
                +
                +
                +.if TCCR2A < 0x40
                +in PWM_DATA , TCCR2A
0000b1 9150 00b0+.else 
                +lds PWM_DATA , TCCR2A
                 	INPUT PWM_DATA,TCCR2A	;Timer/counter control register A
0000b3 7c5c      	ANDI PWM_DATA,(~((1<<COM2B1)|(1<<COM2B0)|(1<<WGM20)|(1<<WGM21)))
0000b4 6253      	ORI PWM_DATA,((1<<COM2B1)|(0<<COM2B0)|(1<<WGM20)|(1<<WGM21))	;fast PWM, non-inverting
                +
                +
                +.if TCCR2A < 0x40
                +out TCCR2A , PWM_DATA
0000b5 9350 00b0+.else 
                +sts TCCR2A , PWM_DATA
                 	OUTPUT TCCR2A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                +
                +
                +.if TCCR2B < 0x40
                +in PWM_DATA , TCCR2B
0000b7 9150 00b1+.else 
                +lds PWM_DATA , TCCR2B
                 	INPUT PWM_DATA,TCCR2B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
0000b9 7f58      	ANDI PWM_DATA,(~((1<<CS20)|(1<<CS21)|(1<<CS22)))
0000ba 6052      	ORI PWM_DATA,((0<<CS20)|(1<<CS21)|(0<<CS22))	;Ver tabla prescalers al final del archivo
                +
                +
                +.if TCCR2B < 0x40
                +out TCCR2B , PWM_DATA
0000bb 9350 00b1+.else 
                +sts TCCR2B , PWM_DATA
                 	OUTPUT TCCR2B,PWM_DATA
                 
0000bd 2700      	CLR	AUX
                +
                +
                +.if OCR2B < 0x40
                +out OCR2B , AUX
0000be 9300 00b4+.else 
                +sts OCR2B , AUX
                 	OUTPUT	OCR2B,AUX
                 
0000c0 9508      RET
                 
                 
                 
                 ;*****************************************************
                 
                 /*
                 ;PWM DE 16 BITS, RECIBE EL VALOR POR PWM_DATA_L Y PWM_DATA_L_H
                 PWM_MOTOR_ELEVACION_SET:	;EL DE ELEVACION ES PD5 [MOT_1]
                 	OUTPUT OCR1BL,PWM_DATA
                 	OUTPUT OCR1BH,PWM_DATA_H	
                 RET
                 
                 PWM_MOTOR_ELEVACION_RESET:	;EL DE ELEVACION ES PD6 [MOT_2]
                 	CLR PWM_DATA
                 	OUTPUT OCR1BL,PWM_DATA	
                 	OUTPUT OCR1BH,PWM_DATA_H	
                 RET
                 */
                 
                 ;*****************************************************
                 /*
                 CS22	CS21	CS20	Description
                 0 		0 		0 		No clock source (timer/counter stopped)
                 0 		0 		1 		clkT2S/(no prescaling)
                 0 		1 		0 		clkT2S/8 (from prescaler)
                 0 		1 		1 		clkT2S/32 (from prescaler)
                 1 		0 		0 		clkT2S/64 (from prescaler)
                 1 		0 		1 		clkT2S/128 (from prescaler)
                 1 		1 		0 		clkT2S/256 (from prescaler)
                 1 		1 		1 		clkT2S/1024 (from prescaler)
                 */
                 .include "SERIAL_PORT.inc"
                 
                  * PRUEBA_PUERTO_SERIE.asm
                  *
                  *  Created: 18/05/2016 07:33:17 p.m.
                  *   Author: MAU
                  */ 
                 
                 
                 ;-------------------------------------------------------------------------
                 ; codigo
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 SERIAL_PORT_INIT:
0000c1 930f      		PUSH	AUX
0000c2 931f      		PUSH	AUX1
                +
0000c3 93af     +push XL
0000c4 93bf     +push XH
                 		PUSHW	X
                 	
0000c5 e000      		LDI		AUX,HIGH(BAUD_RATE)
                +
                +
                +.if UBRR0H < 0x40
                +out UBRR0H , AUX
0000c6 9300 00c5+.else 
                +sts UBRR0H , AUX
                 		OUTPUT		UBRR0H,AUX	; Velocidad de transmisin
0000c8 e607      		LDI		AUX,LOW(BAUD_RATE)
                +
                +
                +.if UBRR0L < 0x40
                +out UBRR0L , AUX
0000c9 9300 00c4+.else 
                +sts UBRR0L , AUX
                 		OUTPUT		UBRR0L,AUX	
                 		
0000cb e002      		LDI		AUX,1<<U2X0		; Modo asinc., doble velocidad
                +
                +
                +.if UCSR0A < 0x40
                +out UCSR0A , AUX
0000cc 9300 00c0+.else 
                +sts UCSR0A , AUX
                 		OUTPUT		UCSR0A,AUX	
                 
                 		; Trama: 8 bits de datos, sin paridad y 1 bit de stop, 
0000ce e006      		LDI		AUX,(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(1<<UCSZ01)|(1<<UCSZ00)
                +
                +
                +.if UCSR0C < 0x40
                +out UCSR0C , AUX
0000cf 9300 00c2+.else 
                +sts UCSR0C , AUX
                 		OUTPUT		UCSR0C,AUX
                 
                 
                 		; Configura los terminales de TX y RX; y habilita
                 		; 	nicamente la int. de recepcin
0000d1 e908      		LDI		AUX,(1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0)|(0<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
0000d2 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT		UCSR0B,AUX
                 
                +
0000d4 e000     +ldi AUX , LOW ( TX_BUF )
0000d5 2e80     +mov PTR_TX_L , AUX
                 		MOVI	PTR_TX_L,LOW(TX_BUF)	; inicializa puntero al 
                +
0000d6 e001     +ldi AUX , HIGH ( TX_BUF )
0000d7 2e90     +mov PTR_TX_H , AUX
                 		MOVI	PTR_TX_H,HIGH(TX_BUF)	; buffer de transmisin.
                 	
                +
0000d8 e0a0     +ldi XL , LOW ( TX_BUF )
0000d9 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF				; limpia BUF_SIZE posiciones 
0000da e410      		LDI		AUX1, BUF_SIZE			; del buffer de transmisin
0000db 2700      		CLR		AUX
                 loop_limpia:
0000dc 930d      		ST		X+,AUX
0000dd 951a      		DEC		AUX1
0000de f7e9      		BRNE	loop_limpia
                 					
0000df 24aa      		CLR		BYTES_A_TX		; nada pendiente de transmisin
                 
                +
0000e0 91bf     +pop XH
0000e1 91af     +pop XL
                 		POPW	X
0000e2 911f      		POP		AUX1
0000e3 910f      		POP		AUX
0000e4 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ; RECEPCION: Interrumpe cada vez que se recibe un byte x RS232.
                 ;
                 ; Recibe:	UDR (byte de dato)
                 ; Devuelve: nada
                 ;-------------------------------------------------------------------------
                 ISR_RX_USART_COMPLETA:
                 
0000e5 ef0f      		SER AUX
                +
                +
                +.if BT_FLAG < 0x40
                +out BT_FLAG , AUX
0000e6 9300 0176+.else 
                +sts BT_FLAG , AUX
                 		OUTPUT BT_FLAG,AUX	;[FLAG=0xFF]: ESTA CONECTADO A BT. 
                 							;[FLAG=0x00]: NO ESTA CONECTADO A BT.
                +
                +
                +.if UDR0 < 0x40
                +in AUX , UDR0
0000e8 9100 00c6+.else 
                +lds AUX , UDR0
                 		INPUT AUX,UDR0
                 
0000ea 3701      		CPI AUX,BT_COMMAND_PROJECT_NAME
0000eb f0a9      		BREQ CALL_PROJECT_NAME
                 
0000ec 3707      		CPI AUX,BT_COMMAND_V_BAT
0000ed f0b9      		BREQ CALL_V_BAT
                 
0000ee 3605      		CPI AUX,BT_COMMAND_V_PANEL
0000ef f0d9      		BREQ CALL_V_PANEL
                 
0000f0 3702      		CPI AUX,BT_COMMAND_LIGHT_TURN_ON
0000f1 f0f9      		BREQ _LIGHT_TURN_ON
                 
0000f2 3704      		CPI AUX,BT_COMMAND_LIGHT_TURN_OFF
0000f3 f111      		BREQ _LIGHT_TURN_OFF
                 
0000f4 3709      		CPI AUX,BT_COMMAND_DISCONNECT
0000f5 f129      		BREQ _BT_DISCONNECT
                 
0000f6 360f      		CPI AUX,BT_COMMAND_AZIMUT_EAST
0000f7 f129      		BREQ _MOVE_AZIMUT_EAST
                 
0000f8 3700      		CPI AUX,BT_COMMAND_AZIMUT_WEST
0000f9 f159      		BREQ _MOVE_AZIMUT_WEST
                 
0000fa 3705      		CPI AUX,BT_COMMAND_ELEVATION_NORTH
0000fb f189      		BREQ _MOVE_ELEVATION_NORTH
                 
0000fc 3609      		CPI AUX,BT_COMMAND_ELEVATION_SOUTH
0000fd f1b9      		BREQ _MOVE_ELEVATION_SOUTH
                 
0000fe 370a      		CPI AUX,BT_COMMAND_RESET
0000ff f1e9      		BREQ _RESET
                 
000100 9518      SIGO:  	RETI 
                 
                 CALL_PROJECT_NAME:
                +
000101 e3e2     +ldi ZL , LOW ( ( MSJ_PROJECT_NAME * 2 ) )
000102 e0f9     +ldi ZH , HIGH ( ( MSJ_PROJECT_NAME * 2 ) )
                 		LDIW	Z,(MSJ_PROJECT_NAME*2)
000103 d062      		RCALL TRANSMITIR_MENSAJE
000104 cffb      	RJMP SIGO
                 CALL_V_BAT:
                +
000105 e5e6     +ldi ZL , LOW ( ( MSJ_V_BAT * 2 ) )
000106 e0f9     +ldi ZH , HIGH ( ( MSJ_V_BAT * 2 ) )
                 		LDIW	Z,(MSJ_V_BAT*2)
                +
000107 e4c0     +ldi YL , LOW ( V_BATTERY_DATA )
000108 e0d1     +ldi YH , HIGH ( V_BATTERY_DATA )
                 		LDIW	Y,V_BATTERY_DATA
000109 d079      		RCALL TRANSMITIR_TENSION
00010a cff5      	RJMP SIGO
                 CALL_V_PANEL:
                +
00010b e7e4     +ldi ZL , LOW ( ( MSJ_V_PANEL * 2 ) )
00010c e0f9     +ldi ZH , HIGH ( ( MSJ_V_PANEL * 2 ) )
                 		LDIW	Z,(MSJ_V_PANEL*2)
                +
00010d e4c8     +ldi YL , LOW ( V_SOLAR_PANEL_DATA )
00010e e0d1     +ldi YH , HIGH ( V_SOLAR_PANEL_DATA )
                 		LDIW	Y,V_SOLAR_PANEL_DATA
00010f d073      		RCALL TRANSMITIR_TENSION
000110 cfef      	RJMP SIGO
                 _LIGHT_TURN_ON:
                +
000111 e8ee     +ldi ZL , LOW ( ( MSJ_LIGHT_ON * 2 ) )
000112 e0f9     +ldi ZH , HIGH ( ( MSJ_LIGHT_ON * 2 ) )
                 		LDIW	Z,(MSJ_LIGHT_ON*2)
000113 d052      		RCALL TRANSMITIR_MENSAJE
000114 d0b9      		RCALL LIGHT_TURN_ON
000115 cfea      	RJMP SIGO
                 _LIGHT_TURN_OFF:
                +
000116 eae4     +ldi ZL , LOW ( ( MSJ_LIGHT_OFF * 2 ) )
000117 e0f9     +ldi ZH , HIGH ( ( MSJ_LIGHT_OFF * 2 ) )
                 		LDIW	Z,(MSJ_LIGHT_OFF*2)
000118 d04d      		RCALL TRANSMITIR_MENSAJE
000119 d0c9      		RCALL LIGHT_TURN_OFF
00011a cfe5      	RJMP SIGO
                 _BT_DISCONNECT:
00011b d022      		RCALL BT_DISCONNECT
00011c cfe3      	RJMP SIGO
                 _MOVE_AZIMUT_EAST:
                +
00011d ebe8     +ldi ZL , LOW ( ( MSJ_AZIMUT_EAST * 2 ) )
00011e e0f9     +ldi ZH , HIGH ( ( MSJ_AZIMUT_EAST * 2 ) )
                 		LDIW	Z,(MSJ_AZIMUT_EAST*2)
00011f d046      		RCALL TRANSMITIR_MENSAJE
000120 ec68      		LDI	AUX3,200
000121 d2df      		RCALL MOTOR_AZIMUT_EAST
000122 d09b      		RCALL DELAY_500ms
000123 d30b      		RCALL MOTOR_AZIMUT_OFF
000124 cfdb      	RJMP SIGO
                 _MOVE_AZIMUT_WEST:
                +
000125 ede6     +ldi ZL , LOW ( ( MSJ_AZIMUT_WEST * 2 ) )
000126 e0f9     +ldi ZH , HIGH ( ( MSJ_AZIMUT_WEST * 2 ) )
                 		LDIW	Z,(MSJ_AZIMUT_WEST*2)
000127 d03e      		RCALL TRANSMITIR_MENSAJE
000128 ec68      		LDI	AUX3,200
000129 d2e6      		RCALL MOTOR_AZIMUT_WEST
00012a d093      		RCALL DELAY_500ms
00012b d303      		RCALL MOTOR_AZIMUT_OFF
00012c cfd3      	RJMP SIGO
                 _MOVE_ELEVATION_NORTH:
                +
00012d efe4     +ldi ZL , LOW ( ( MSJ_ELEVATION_NORTH * 2 ) )
00012e e0f9     +ldi ZH , HIGH ( ( MSJ_ELEVATION_NORTH * 2 ) )
                 		LDIW	Z,(MSJ_ELEVATION_NORTH*2)
00012f d036      		RCALL TRANSMITIR_MENSAJE
000130 ec68      		LDI	AUX3,200
000131 d326      		RCALL MOTOR_ELEVATION_NORTH
000132 d08b      		RCALL DELAY_500ms
000133 d343      		RCALL MOTOR_ELEVATION_OFF
000134 cfcb      	RJMP SIGO
                 _MOVE_ELEVATION_SOUTH:
                +
000135 e1e2     +ldi ZL , LOW ( ( MSJ_ELEVATION_SOUTH * 2 ) )
000136 e0fa     +ldi ZH , HIGH ( ( MSJ_ELEVATION_SOUTH * 2 ) )
                 		LDIW	Z,(MSJ_ELEVATION_SOUTH*2)
000137 d02e      		RCALL TRANSMITIR_MENSAJE
000138 ec68      		LDI	AUX3,200
000139 d30f      		RCALL MOTOR_ELEVATION_SOUTH
00013a d083      		RCALL DELAY_500ms
00013b d33b      		RCALL MOTOR_ELEVATION_OFF
00013c cfc3      	RJMP SIGO
                 _RESET:
00013d cedc      	RJMP SETUP
                 
                 BT_DISCONNECT:
                +
00013e e2ee     +ldi ZL , LOW ( ( MSJ_DISCONNECTED_BT * 2 ) )
00013f e0fa     +ldi ZH , HIGH ( ( MSJ_DISCONNECTED_BT * 2 ) )
                 		LDIW	Z,(MSJ_DISCONNECTED_BT*2)
000140 d025      		RCALL TRANSMITIR_MENSAJE
000141 2700      		CLR AUX
                +
                +
                +.if BT_FLAG < 0x40
                +out BT_FLAG , AUX
000142 9300 0176+.else 
                +sts BT_FLAG , AUX
                 		OUTPUT BT_FLAG,AUX 
000144 9508      RET
                 ;------------------------------------------------------------------------
                 
                 ;------------------------------------------------------------------------
                 ; TRANSMISION: interrumpe cada vez que puede transmitir un byte.
                 ; Se transmiten "BYTES_A_TX" comenzando desde la posicin TX_BUF del
                 ; buffer. Si "BYTES_A_TX" llega a cero, se deshabilita la interrupcin.
                 ;
                 ; Recibe: 	BYTES_A_TX.
                 ; Devuelve: PTR_TX_H:PTR_TX_L, y BYTES_A_TX.
                 ;------------------------------------------------------------------------
                 ISR_REG_USART_VACIO:		; UDR est vaco
000145 930f      		PUSH	AUX
000146 931f      		PUSH	AUX1
                +
000147 b70f     +in AUX , SREG
000148 930f     +push AUX
                 		PUSHI	SREG
                +
000149 93af     +push XL
00014a 93bf     +push XH
                 		PUSHW	X
                 
                 
00014b 20aa      		TST		BYTES_A_TX	; hay datos pendientes de transmisin?
00014c f069      		BREQ	FIN_TRANSMISION
                 
00014d 01d4      		MOVW	XL,PTR_TX_L	; Recupera puntero al prximo byte a tx.
00014e 910d      		LD		AUX,X+		; lee byte del buffer y apunta al
                +
                +
                +.if UDR0 < 0x40
                +out UDR0 , AUX
00014f 9300 00c6+.else 
                +sts UDR0 , AUX
                 		OUTPUT		UDR0,AUX		; sgte. dato a transmitir (en la prxima int.)
                 
000151 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
000152 f020      		BRLO	SALVA_PTR_TX
000153 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
000154 f010      		BRLO	SALVA_PTR_TX
                +
000155 e0a0     +ldi XL , LOW ( TX_BUF )
000156 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx=ptr_tx+1, (mdulo BUF_SIZE)
                 
                 SALVA_PTR_TX:
000157 014d      		MOVW	PTR_TX_L,XL	; preserva puntero a sgte. dato
                 
000158 94aa      		DEC		BYTES_A_TX	; Descuenta el nro. de bytes a tx. en 1
000159 f429      		BRNE	SIGUE_TX	; si quedan datos que transmitir
                 							;	vuelve en la prxima int.
                 ;REVISAR ESTE GRUPO DE INSTRUCCIONES
                 FIN_TRANSMISION:			; si no hay nada que enviar,
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
00015a 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
00015c 7d0f      		CBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
00015d 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 		;se deshabilita la interrupcin.
                 
                 sigue_tx:
                +
00015f 91bf     +pop XH
000160 91af     +pop XL
                 		POPW	X
                +
000161 910f     +pop AUX
000162 bf0f     +out SREG , AUX
                 		POPI	SREG
000163 911f      		POP		AUX1
000164 910f      		POP		AUX
000165 9518      		RETI
                 
                 ;-------------------------------------------------------------------------
                 ; TRANSMITIR_MENSAJE: transmite el mensaje almacenado en memoria flash a partir
                 ; de la direccin APUNTADA POR Z! que termina con 0x00 (el 0 no se transmite).
                 ; Recibe: nada
                 ; Devuelve: PTR_TX_L|H, BYTES_A_TX.  
                 ; Habilita la int. de transmisin serie con ISR en ISR_REG_USART_VACIO().
                 ;-------------------------------------------------------------------------
                 TRANSMITIR_MENSAJE:
                +
000166 93ef     +push ZL
000167 93ff     +push ZH
                 		PUSHW	Z
                +
000168 93af     +push XL
000169 93bf     +push XH
                 		PUSHW	X
00016a 930f      		PUSH	AUX
                 
00016b 01d4      		MOVW	XL,PTR_TX_L
                 
                 LOOP_TRANSMITIR_MENSAJE:
00016c 9105      		LPM		AUX,Z+
00016d 2300      		TST		AUX
00016e f049      		BREQ	FIN_TRANSMITIR_MENSAJE
                 
00016f 930d      		ST		X+,AUX
000170 94a3      		INC		BYTES_A_TX
                 
000171 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
000172 f3c8      		BRLO	LOOP_TRANSMITIR_MENSAJE
000173 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
000174 f3b8      		BRLO	LOOP_TRANSMITIR_MENSAJE
                +
000175 e0a0     +ldi XL , LOW ( TX_BUF )
000176 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
000177 cff4      		RJMP	LOOP_TRANSMITIR_MENSAJE
                 	
                 FIN_TRANSMITIR_MENSAJE:
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
000178 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
                 
00017a 6200      		SBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
00017b 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 
00017d 910f      		POP		AUX
                +
00017e 91bf     +pop XH
00017f 91af     +pop XL
                 		POPW	X
                +
000180 91ff     +pop ZH
000181 91ef     +pop ZL
                 		POPW	Z
000182 9508      		RET
                 
                 ;-------------------------------------------------------------------------
                 ; fin del cdigo
                 ;-------------------------------------------------------------------------
                 
                 
                 TRANSMITIR_TENSION:
                +
000183 93ef     +push ZL
000184 93ff     +push ZH
                 		PUSHW	Z
                +
000185 93af     +push XL
000186 93bf     +push XH
                 		PUSHW	X
000187 930f      		PUSH	AUX
                 
000188 01d4      		MOVW	XL,PTR_TX_L
                 
                 LOOP_TRANSMITIR_TENSION:
000189 9105      		LPM		AUX,Z+
00018a 2300      		TST		AUX
00018b f049      		BREQ	LOOP_TRANSMITIR_DATO	;TERMINO DE MANDAR EL MENSAJE, AHORA MANDO EL DATO
                 
00018c 930d      		ST		X+,AUX
00018d 94a3      		INC		BYTES_A_TX
                 
00018e 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
00018f f3c8      		BRLO	LOOP_TRANSMITIR_TENSION
000190 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
000191 f3b8      		BRLO	LOOP_TRANSMITIR_TENSION
                +
000192 e0a0     +ldi XL , LOW ( TX_BUF )
000193 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
000194 cff4      		RJMP	LOOP_TRANSMITIR_TENSION
                 	
                 LOOP_TRANSMITIR_DATO:
000195 9109      		LD		AUX,Y+
000196 2300      		TST		AUX
000197 f049      		BREQ	FIN_TRANSMITIR_DATO
                 
000198 930d      		ST		X+,AUX
000199 94a3      		INC		BYTES_A_TX
                 
00019a 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
00019b f3c8      		BRLO	LOOP_TRANSMITIR_DATO
00019c 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
00019d f3b8      		BRLO	LOOP_TRANSMITIR_DATO
                +
00019e e0a0     +ldi XL , LOW ( TX_BUF )
00019f e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
0001a0 cff4      		RJMP	LOOP_TRANSMITIR_DATO
                 	
                 FIN_TRANSMITIR_DATO:
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
0001a1 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
                 
0001a3 6200      		SBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
0001a4 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 
0001a6 910f      		POP		AUX
                +
0001a7 91bf     +pop XH
0001a8 91af     +pop XL
                 		POPW	X
                +
0001a9 91ff     +pop ZH
0001aa 91ef     +pop ZL
                 		POPW	Z
                 .include "DELAY.inc"
0001ab 9508      
                 ;		Para crear los delays, no te hagas el crack y
                 ;		us el bocho de alguien que ya lo pens:
                 ;		http://www.bretmulvey.com/avrdelay.html
                 ;
                 ;		TENER EN CUENTA QUE EL MICRO TRABAJA A 8MHZ
                 ;
                 ;***********************************************************
                 .CSEG
                 
                 DELAY_100us:
0001ac e002          ldi  AUX, 2
0001ad e019          ldi  AUX1, 9
0001ae 951a      L4: dec  AUX1
0001af f7f1          brne L4
0001b0 950a          dec  AUX
0001b1 f7e1          brne L4
0001b2 9508      RET
                 
                 DELAY_50ms:
                 
0001b3 e003          ldi  AUX, 3
0001b4 e018          ldi  AUX1, 8
0001b5 e728          ldi  AUX2, 120
0001b6 952a      L1: dec  AUX2
0001b7 f7f1          brne L1
0001b8 951a          dec  AUX1
0001b9 f7e1          brne L1
0001ba 950a          dec  AUX
0001bb f7d1          brne L1
0001bc 9508      RET
                 
                 DELAY_LO_QUE_SE_ME_ANTOJE:
                 
                 ;ABRI EL PROGRAMA Y LISTO.
                 ;HACER PUSH Y POP DE LOS REGS QUE SE USEN
                 
0001bd 9508      RET
                 
                 DELAY_500ms:
0001be e105          ldi  AUX, 21
0001bf e41b          ldi  AUX1, 75
0001c0 eb2f          ldi  AUX2, 191
0001c1 952a      L3: dec  AUX2
0001c2 f7f1          brne L3
0001c3 951a          dec  AUX1
0001c4 f7e1          brne L3
0001c5 950a          dec  AUX
0001c6 f7d1          brne L3
0001c7 0000          nop
                 .include "LIGHT.inc"
0001c8 9508      
                 *	LIGHT.inc [COMO SI FUERA UN OBJETO]
                 *
                 *  Created: 01/06/2016 13:10:11 p.m.
                 *   Author: MAU
                 */ 
                 .CSEG
                 ;FUTURA MEJORA: HACER QUE LA LUZ SE MUEVA POR PWM EN FUNCION DE LA CARGA DE LA BATERIA
                 LIGHT_INIT:
                 ;CONFIGURO COMO SALIDA LIGHT_PIN
                +
                +
                +.if DDRD < 0x40
0001c9 b10a     +in AUX , DDRD
                +.else 
                +lds AUX , DDRD
                 	INPUT	AUX,DDRD
0001ca 7f07      	ANDI	AUX,(~(1<<LIGHT_PIN))
0001cb 6008      	ORI		AUX,(1<<LIGHT_PIN)
                 
0001cc d016      	RCALL	LIGHT_TURN_OFF
0001cd 9508      RET
                 
                 LIGHT_TURN_ON:
                +
                +
                +.if BT_FLAG < 0x40
                +in AUX , BT_FLAG
0001ce 9100 0176+.else 
                +lds AUX , BT_FLAG
                 	INPUT AUX,BT_FLAG
0001d0 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: ESTA CONECTADO A BT. NO MODIFICAR EL ESTADO
0001d1 f081      	BREQ ORDEN_BT_NO_HACER_NADA			;[FLAG=0x00]: NO ESTA CONECTADO A BT.
                 
0001d2 e604      	LDI AUX,100
0001d3 d02f      	RCALL READ_V_BATTERY
0001d4 3e46      	CPI	ADC_DATA_H,230
0001d5 f420      	BRSH EXC_CHARGE
0001d6 3a4a      	CPI	ADC_DATA_H,170
0001d7 f420      	BRSH GOOD_CHARGE
0001d8 3946      	CPI	ADC_DATA_H,150
0001d9 f420      	BRSH BAD_CHARGE
                 EXC_CHARGE:
                +
                +
                +
                +
0001da e372     +LDI AUX4 , 50
0001db 0f07     +ADD AUX , AUX4
                 	ADDI AUX,50
                 GOOD_CHARGE:
                +
                +
                +
                +
0001dc e372     +LDI AUX4 , 50
0001dd 0f07     +ADD AUX , AUX4
                 	ADDI AUX,50
                 BAD_CHARGE:
                +
                +
                +
                +
0001de e377     +LDI AUX4 , 55
0001df 0f07     +ADD AUX , AUX4
                 	ADDI AUX,55
                +
                +
                +.if OCR2B < 0x40
                +out OCR2B , AUX
0001e0 9300 00b4+.else 
                +sts OCR2B , AUX
                 	OUTPUT OCR2B,AUX
                 
                 ORDEN_BT_NO_HACER_NADA:
0001e2 9508      RET
                 
                 LIGHT_TURN_OFF:
                +
                +
                +.if BT_FLAG < 0x40
                +in AUX , BT_FLAG
0001e3 9100 0176+.else 
                +lds AUX , BT_FLAG
                 	INPUT AUX,BT_FLAG
0001e5 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: ESTA CONECTADO A BT. 
0001e6 f3d9      	BREQ ORDEN_BT_NO_HACER_NADA			;[FLAG=0x00]: NO ESTA CONECTADO A BT.
                 
0001e7 2700      	CLR AUX
                +
                +
                +.if OCR2B < 0x40
                +out OCR2B , AUX
0001e8 9300 00b4+.else 
                +sts OCR2B , AUX
                 	OUTPUT OCR2B,AUX
                 .include "BATTERY.inc"
0001ea 9508      
                 ;
                 ;							BATTERY.inc
                 ;
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 BATTERY_INIT:
                +
                +
                +.if DDRD < 0x40
0001eb b10a     +in AUX , DDRD
                +.else 
                +lds AUX , DDRD
                 	INPUT AUX,DDRD
0001ec 760f      	ANDI AUX,(~((1<<DDD4)|(1<<DDD7)))	;Mascara para tocar solo D3
0001ed 6900      	ORI AUX,((1<<DDD4)|(1<<DDD7))
                +
                +
                +.if DDRD < 0x40
0001ee b90a     +out DDRD , AUX
                +.else 
                +sts DDRD , AUX
                 	OUTPUT DDRD,AUX
0001ef d01f      	RCALL INDICATE_BATTERY_LOW
                 
                 	;INICIALIZO LA INFORMACION DE LA TENSION PARA TRANSMITIR POR BLUETOOTH
                +
0001f0 e4a0     +ldi XL , LOW ( V_BATTERY_DATA )
0001f1 e0b1     +ldi XH , HIGH ( V_BATTERY_DATA )
                 	LDIW X,V_BATTERY_DATA
                +
0001f2 e370     +ldi AUX4 , '0'
0001f3 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0001f4 e370     +ldi AUX4 , '0'
0001f5 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0001f6 e27e     +ldi AUX4 , '.'
0001f7 937d     +st X + , AUX4
                 	STI	X+,'.'
                +
0001f8 e370     +ldi AUX4 , '0'
0001f9 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0001fa e576     +ldi AUX4 , 'V'
0001fb 937d     +st X + , AUX4
                 	STI	X+,'V'
                +
0001fc e07d     +ldi AUX4 , '\r'
0001fd 937d     +st X + , AUX4
                 	STI X+,'\r'
                +
0001fe e07a     +ldi AUX4 , '\n'
0001ff 937d     +st X + , AUX4
                 	STI X+,'\n'
                +
000200 e070     +ldi AUX4 , 0
000201 937c     +st X , AUX4
                 	STI	X,0
                 
000202 9508      RET
                 
                 READ_V_BATTERY:
000203 e036      		LDI ADC_DATA_L,ADC_BATTERY			;ELIJO EL PIN DE LA BATERA
000204 de74      		RCALL ADC_SELECT_INPUT				;LLAMO LA FUNCION PARA SELECCIONAR LA BATERIA
000205 de7a      		RCALL ADC_SIMPLE_CONVERSION			;LLAMO LA FUNCION PARA MEDIR
000206 9508      RET
                 
                 CHECK_IF_BATTERY_MINIMUM:
000207 9488      	CLC
000208 3a4a      	CPI		ADC_DATA_H,MIN_BATTERY_VALUE	;COMPARAR PARA VER SI HAY SUFICIENTE BATERIA PARA OPERAR
000209 f010      	BRCS	_INDICATE_BATTERY_LOW						;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
00020a d009      	RCALL INDICATE_BATTERY_OK
                 	
                 RETURN_INDICATE_BATTERY_LOW:
00020b 9508      RET
                 
                 _INDICATE_BATTERY_LOW:
00020c d002      	RCALL INDICATE_BATTERY_LOW
00020d 9408      	SEC										;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
00020e cffc      RJMP RETURN_INDICATE_BATTERY_LOW
                 
                 INDICATE_BATTERY_LOW:
                +
                +
                +.if PORTD < 0x40
00020f b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT	AUX,PORTD
000210 760f      	ANDI	AUX,(~((1<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW)))
000211 6100      	ORI		AUX,((1<<PIN_BATTERY_LED_OK)|(0<<PIN_BATTERY_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTD < 0x40
000212 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT	PORTD,AUX
000213 9508      RET
                 
                 INDICATE_BATTERY_OK:
                +
                +
                +.if PORTD < 0x40
000214 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT	AUX,PORTD
000215 760f      	ANDI	AUX,(~((1<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW)))
000216 6800      	ORI		AUX,((0<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTD < 0x40
000217 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT	PORTD,AUX
000218 9488      	CLC										;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
000219 9508      RET
                 
                 
                 VBATTERY_TO_ASCII:
                 
                +
00021a e4a0     +ldi XL , LOW ( V_BATTERY_DATA )
00021b e0b1     +ldi XH , HIGH ( V_BATTERY_DATA )
                 					LDIW X,V_BATTERY_DATA
                +
00021c e7e4     +ldi ZL , LOW ( ( VBATTERY_DIG_TABLE * 2 ) )
00021d e0fa     +ldi ZH , HIGH ( ( VBATTERY_DIG_TABLE * 2 ) )
                 VBATTERY_DIG:		LDIW Z,(VBATTERY_DIG_TABLE*2)
00021e 2711      					CLR AUX1
00021f 2722      					CLR AUX2
                 LOOP_DIG_BATTERY:			
000220 d032      					RCALL SET_VBATTERY_DIG
000221 f056      					BRTS V_BATTERY_DEC
000222 9513      					INC AUX1
000223 301a      					CPI AUX1,10
000224 f010      					BRLO LOWER_THAN_10_DIG_BATTERY
000225 2711      					CLR AUX1
000226 9523      					INC AUX2
000227 f7c6      LOWER_THAN_10_DIG_BATTERY: BRTC LOOP_DIG_BATTERY
                +
000228 e371     +ldi AUX4 , 48 + 1
000229 937d     +st X + , AUX4
                 					STI X+,48+1
                +
00022a e375     +ldi AUX4 , 48 + 5
00022b 937d     +st X + , AUX4
                 					STI X+,48+5
                 
                +
00022c e7e4     +ldi ZL , LOW ( ( VBATTERY_DIG_TABLE * 2 ) )
00022d e0fa     +ldi ZH , HIGH ( ( VBATTERY_DIG_TABLE * 2 ) )
                 V_BATTERY_DEC:		LDIW Z,(VBATTERY_DIG_TABLE*2)
00022e 5310      					SUBI AUX1,48
00022f 5320      					SUBI AUX2,48
000230 e06a      					LDI AUX3,10
000231 9f26      					MUL AUX2,AUX3
000232 2d20      					MOV AUX2,R0
000233 0f12      					ADD AUX1,AUX2
                +
                +
                +
                +
000234 0fe1     +ADD ZL , AUX1
000235 f41b     +BRVC NO_POINTER_OV
000236 95f3     +INC ZH
000237 1b1e     +SUB AUX1 , ZL
000238 2f1e     +MOV AUX1 , ZL
000239 0000     +NO_POINTER_OV : NOP
                 					ADDP Z,AUX1
00023a 9114      					LPM AUX1,Z
00023b 1b14      					SUB AUX1,ADC_DATA_H	;ACA AUX1 TIENE QUE ESTAR ENTRE 0 Y 15
                 	
                 
                +
00023c e27e     +ldi AUX4 , '.'
00023d 937d     +st X + , AUX4
                 					STI	X+,'.'
00023e ea20      					ldi	aux2,160		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
00023f 9f12      					MUL	AUX1,AUX2
000240 2d11      					MOV	AUX1,R1
000241 1b61      					SUB AUX3,AUX1					
                +
                +
                +
                +
000242 e370     +LDI AUX4 , 48
000243 0f67     +ADD AUX3 , AUX4
                 					ADDI AUX3,48		;SE TRANSFORMA EN ASCII
000244 336a      					CPI AUX3,':'
000245 f059      					BREQ ajuste_9_bat
                 
000246 936d      vuelvo_9_bat:		ST X+,AUX3	;El ASCII del nmero en AUX.
                +
000247 e576     +ldi AUX4 , 'V'
000248 937d     +st X + , AUX4
                 					STI	X+,'V'
                +
000249 e07d     +ldi AUX4 , '\r'
00024a 937d     +st X + , AUX4
                 					STI X+,'\r'
                +
00024b e07a     +ldi AUX4 , '\n'
00024c 937d     +st X + , AUX4
                 					STI X+,'\n'
                +
00024d e070     +ldi AUX4 , 0
00024e 937c     +st X , AUX4
                 					STI	X,0
00024f 94e8      					CLT
000250 9508      RET	
                 
                 ajuste_9_bat:
000251 e369      		ldi aux3,'9'
000252 cff3      		rjmp vuelvo_9_bat
                 		
                 SET_VBATTERY_DIG:
000253 9105      					LPM AUX,Z+
000254 9503      					INC AUX
000255 1740      					CP ADC_DATA_H,AUX
000256 f438      					BRSH END_SET_VBATTERY_DIG
                +
                +
                +
                +
000257 e370     +LDI AUX4 , 48
000258 0f17     +ADD AUX1 , AUX4
                 					ADDI AUX1,48
                +
                +
                +
                +
000259 e370     +LDI AUX4 , 48
00025a 0f27     +ADD AUX2 , AUX4
                 					ADDI AUX2,48
00025b 932d      					ST X+,AUX2
00025c 931d      					ST X+,AUX1
00025d 9468      					SET
00025e 9508      END_SET_VBATTERY_DIG:	RET
                 
                 
                 
                 /*
                 MAURO:
                 V_BATTERY_TO_ASCII:
                 
                 .DEF UNIDAD		= R17		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 .DEF DECENA		= R18		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 .DEF DECIMAL	= R22		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 
                 	PUSH UNIDAD
                 	PUSH DECENA
                 	PUSH DECIMAL
                 	PUSH ADC_DATA_H
                 
                 	CLR	UNIDAD
                 	CLR DECENA
                 	CLR DECIMAL
                 
                 		TST	ADC_DATA_H
                 		BREQ NULO
                 START:	CLC
                 		SUBI ADC_DATA_H,16
                 		BRCS OOB
                 		CPI ADC_DATA_H,16
                 		BRLO PASSED
                 		BREQ dec_0
                 		inc	unidad
                 		cpi unidad,10
                 		breq acomodo
                 		RJMP START
                 
                 OOB:	NEG ADC_DATA_H
                 
                 PASSED:	ldi	aux1,160		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
                 		MUL	ADC_DATA_H,AUX1
                 		MOV	ADC_DATA_H,R1
                 dec_0:	MOV	decimal,ADC_DATA_H
                 	
                 NULO:
                 		LDIW	Z,V_BATTERY_DATA
                 SUBIR_DECENA:
                 	ADDI	DECENA,48
                 	ST	Z+,DECENA
                 
                 SUBIR_UNIDAD:
                 	ADDI	UNIDAD,48
                 	ST	Z+,UNIDAD
                 
                 SUBIR_PUNTO:
                 	STI		Z+,'.'
                 
                 SUBIR_DECIMAL:
                 	ADDI	DECIMAL,48
                 	ST	Z+,DECIMAL
                 
                 SUBIR_FINAL:
                 	STI		Z+,'V'
                 	STI		Z+,'\r'
                 	STI		Z+,'\n'
                 	STI		Z,0
                 
                 	POP ADC_DATA_H
                 	POP	DECIMAL
                 	POP DECENA
                 	POP UNIDAD
                 RET	
                 
                 ACOMODO:
                 	CLR UNIDAD
                 	INC DECENA
                 RJMP START
                 .include "SOLAR_PANEL.inc"
                 
                 ;
                 ;							SOLAR_PANEL.inc
                 ;				
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 SOLAR_PANEL_INIT:
                +
                +
                +.if DDRC < 0x40
00025f b107     +in AUX , DDRC
                +.else 
                +lds AUX , DDRC
                 	INPUT AUX,DDRC
000260 7f0c      	ANDI AUX,(~((1<<DDC0)|(1<<DDC1)))	;Mascara para tocar los leds del panel solar
000261 6003      	ORI AUX,((1<<DDC0)|(1<<DDC1))
                +
                +
                +.if DDRC < 0x40
000262 b907     +out DDRC , AUX
                +.else 
                +sts DDRC , AUX
                 	OUTPUT DDRC,AUX
000263 d01f      	RCALL INDICATE_SOLAR_PANEL_LOW
                 	;INICIALIZO LA INFORMACION DE LA TENSION PARA TRANSMITIR POR BLUETOOTH
                +
000264 e4a8     +ldi XL , LOW ( V_SOLAR_PANEL_DATA )
000265 e0b1     +ldi XH , HIGH ( V_SOLAR_PANEL_DATA )
                 	LDIW X,V_SOLAR_PANEL_DATA
                +
000266 e370     +ldi AUX4 , '0'
000267 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
000268 e370     +ldi AUX4 , '0'
000269 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
00026a e27e     +ldi AUX4 , '.'
00026b 937d     +st X + , AUX4
                 	STI	X+,'.'
                +
00026c e370     +ldi AUX4 , '0'
00026d 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
00026e e576     +ldi AUX4 , 'V'
00026f 937d     +st X + , AUX4
                 	STI	X+,'V'
                +
000270 e07d     +ldi AUX4 , '\r'
000271 937d     +st X + , AUX4
                 	STI X+,'\r'
                +
000272 e07a     +ldi AUX4 , '\n'
000273 937d     +st X + , AUX4
                 	STI X+,'\n'
                +
000274 e070     +ldi AUX4 , 0
000275 937c     +st X , AUX4
                 	STI	X,0
                 
000276 9508      RET
                 ;-------------------------------------------------------------------------
                 
                 READ_V_SOLAR_PANEL:
                 ;RECIBE: NADA
                 ;DEVUELVE: TENSION DEL PANEL EN ADC_DATA_H
000277 e037      	LDI ADC_DATA_L,ADC_SOLAR_PANEL			;ELIJO EL PIN DEL PANEL SOLAR
000278 de00      	RCALL ADC_SELECT_INPUT					;LLAMO LA FUNCION PARA SELECCIONAR EL PANEL SOLAR
000279 de06      	RCALL ADC_SIMPLE_CONVERSION				;LLAMO LA FUNCION PARA MEDIR
00027a 9508      RET
                 
                 CHECK_IF_SOLAR_PANEL_MINIMUM:
00027b 9488      	CLC
00027c 3342      	CPI		ADC_DATA_H,MIN_SOLAR_PANEL_VALUE	;COMPARAR PARA VER SI HAY SUFICIENTE BATERIA PARA OPERAR
00027d f010      	BRCS	_INDICATE_SOLAR_PANEL_LOW						;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
00027e d009      	RCALL INDICATE_SOLAR_PANEL_OK
                 	
                 RETURN_INDICATE_SOLAR_PANEL_LOW:
00027f 9508      RET
                 
                 _INDICATE_SOLAR_PANEL_LOW:
000280 d002      	RCALL INDICATE_SOLAR_PANEL_LOW
000281 9408      	SEC										;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
000282 cffc      RJMP RETURN_INDICATE_SOLAR_PANEL_LOW
                 
                 INDICATE_SOLAR_PANEL_LOW:
                +
                +
                +.if PORTC < 0x40
000283 b108     +in AUX , PORTC
                +.else 
                +lds AUX , PORTC
                 	INPUT	AUX,PORTC
000284 7f0c      	ANDI	AUX,(~((1<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW)))
000285 6002      	ORI		AUX,((1<<PIN_SOLAR_PANEL_LED_OK)|(0<<PIN_SOLAR_PANEL_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTC < 0x40
000286 b908     +out PORTC , AUX
                +.else 
                +sts PORTC , AUX
                 	OUTPUT	PORTC,AUX
000287 9508      RET
                 
                 INDICATE_SOLAR_PANEL_OK:
                +
                +
                +.if PORTC < 0x40
000288 b108     +in AUX , PORTC
                +.else 
                +lds AUX , PORTC
                 	INPUT	AUX,PORTC
000289 7f0c      	ANDI	AUX,(~((1<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW)))
00028a 6001      	ORI		AUX,((0<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTC < 0x40
00028b b908     +out PORTC , AUX
                +.else 
                +sts PORTC , AUX
                 	OUTPUT	PORTC,AUX
00028c 9488      	CLC										;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
00028d 9508      RET
                 ;-------------------------------------------------------------------------
                 
                 ORIENTATE_SOLAR_PANEL:
00028e de02      		RCALL PWM_INIT							;TIENE QUE ESTAR EN "PWM.inc"
                 ;YA ESTAN LOS PROMEDIOS DE LOS LDR Y HAY QUE COMPARAR Y MOVER EL PANEL.
                 ;PRIMERO EN ASIMUT, LUEGO EN ELEVACION.
                 ;EL SOL SALE DEL ESTE Y SE PONE EN EL OESTE.
                 	;SI AMBOS SON 0xFn NO SE MUEVE
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
00028f 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 	INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
000291 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 	INPUT AUX1,LDR_NE_MEAN
000293 7f00      	ANDI	AUX,0xF0
000294 7f10      	ANDI	AUX1,0xF0
000295 3f00      	CPI		AUX,0xF0
000296 f411      	BRNE	NO_SON_F_AZIMUT
000297 1b01      	SUB		AUX,AUX1
000298 f081      	BREQ	AMBOS_SON_F_AZIMUT
                 NO_SON_F_AZIMUT:
                 	;COMPARAR_NO_NE:
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
000299 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
00029b 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 		INPUT AUX1,LDR_NE_MEAN
00029d 7f00      		ANDI	AUX,0xF0
00029e 7f10      		ANDI	AUX1,0xF0
00029f 1701      		CP AUX,AUX1
0002a0 f118      		BRLO _MOTOR_AZIMUT_EAST
                 	RETURN_MOTOR_AZIMUT_EAST:
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002a1 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
0002a3 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 		INPUT AUX1,LDR_NE_MEAN
0002a5 7f00      		ANDI	AUX,0xF0
0002a6 7f10      		ANDI	AUX1,0xF0
0002a7 1710      		CP AUX1,AUX
0002a8 f128      		BRLO _MOTOR_AZIMUT_WEST
                 	RETURN_MOTOR_AZIMUT_WEST:
                 AMBOS_SON_F_AZIMUT:
                 
                 ;--------------------ACA NOS MOVEMOS CON NORTE Y SUR
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002a9 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 	INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
0002ab 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 	INPUT AUX1,LDR_SO_MEAN
0002ad 7f00      	ANDI	AUX,0xF0
0002ae 7f10      	ANDI	AUX1,0xF0
0002af 3f00      	CPI		AUX,0xF0
0002b0 f411      	BRNE	NO_SON_F_ELEVATION
0002b1 1b01      	SUB		AUX,AUX1
0002b2 f081      	BREQ	AMBOS_SON_F_ELEVATION
                 NO_SON_F_ELEVATION:
                 	;COMPARAR_NO_SO:
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002b3 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
0002b5 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 		INPUT AUX1,LDR_SO_MEAN
0002b7 7f00      		ANDI	AUX,0xF0
0002b8 7f10      		ANDI	AUX1,0xF0
0002b9 1701      		CP AUX,AUX1
0002ba f138      		BRLO _MOTOR_ELEVATION_NORTH
                 	RETURN_MOTOR_ELEVATION_NORTH:
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002bb 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
0002bd 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 		INPUT AUX1,LDR_SO_MEAN
0002bf 7f00      		ANDI	AUX,0xF0
0002c0 7f10      		ANDI	AUX1,0xF0
0002c1 1710      		CP AUX1,AUX
0002c2 f0a8      		BRLO _MOTOR_ELEVATION_SOUTH
                 	RETURN_MOTOR_ELEVATION_SOUTH:
                 AMBOS_SON_F_ELEVATION:
0002c3 9508      RET
                 ;-------------------------------------------------------------------------
                 
                 _MOTOR_AZIMUT_EAST:
0002c4 1b01      	SUB AUX,AUX1
0002c5 6800      	ORI	AUX,0x80
0002c6 2f60      	MOV	AUX3,AUX
                 
0002c7 d139      	RCALL MOTOR_AZIMUT_EAST
0002c8 deea      		RCALL DELAY_50ms
0002c9 dee9      		RCALL DELAY_50ms
0002ca dee8      		RCALL DELAY_50ms
0002cb dee7      		RCALL DELAY_50ms
0002cc d162      	RCALL MOTOR_AZIMUT_OFF
                 	;	RCALL DELAY_500ms
0002cd cfd3      RJMP RETURN_MOTOR_AZIMUT_EAST
                 
                 _MOTOR_AZIMUT_WEST:
0002ce 1b10      	SUB AUX1,AUX
0002cf 6810      	ORI	AUX1,0x80
0002d0 2f61      	MOV	AUX3,AUX1
                 
0002d1 d13e      	RCALL MOTOR_AZIMUT_WEST
0002d2 dee0      		RCALL DELAY_50ms
0002d3 dedf      		RCALL DELAY_50ms
0002d4 dede      		RCALL DELAY_50ms
0002d5 dedd      		RCALL DELAY_50ms
0002d6 d158      	RCALL MOTOR_AZIMUT_OFF
0002d7 cfd1      RJMP RETURN_MOTOR_AZIMUT_WEST
                 
                 
                 _MOTOR_ELEVATION_SOUTH:
0002d8 1b10      	SUB AUX1,AUX
0002d9 6a1f      	ORI	AUX1,0xAF
0002da 2f61      	MOV	AUX3,AUX1
                 
0002db d16d      	RCALL MOTOR_ELEVATION_SOUTH
0002dc ded6      		RCALL DELAY_50ms
0002dd ded5      		RCALL DELAY_50ms
0002de ded4      		RCALL DELAY_50ms
0002df ded3      		RCALL DELAY_50ms
0002e0 d196      	RCALL MOTOR_ELEVATION_OFF
0002e1 cfe1      RJMP RETURN_MOTOR_ELEVATION_SOUTH
                 
                 _MOTOR_ELEVATION_NORTH:
0002e2 1b10      	SUB AUX1,AUX
0002e3 6a1f      	ORI	AUX1,0xAF
0002e4 2f61      	MOV	AUX3,AUX1
                 
0002e5 d172      	RCALL MOTOR_ELEVATION_NORTH
0002e6 decc      		RCALL DELAY_50ms
0002e7 decb      		RCALL DELAY_50ms
0002e8 deca      		RCALL DELAY_50ms
0002e9 dec9      		RCALL DELAY_50ms
0002ea d18c      	RCALL MOTOR_ELEVATION_OFF
0002eb cfcf      RJMP RETURN_MOTOR_ELEVATION_NORTH
                 ;-------------------------------------------------------------------------
                 
                 VPANEL_TO_ASCII:
                +
0002ec e4a8     +ldi XL , LOW ( V_SOLAR_PANEL_DATA )
0002ed e0b1     +ldi XH , HIGH ( V_SOLAR_PANEL_DATA )
                 				LDIW X,V_SOLAR_PANEL_DATA	;Apunto X a la seccin de memoria donde se guarda la tensin a panel a transmitir
                +
0002ee e5e4     +ldi ZL , LOW ( VPANEL_DIG_TABLE * 2 )
0002ef e0fa     +ldi ZH , HIGH ( VPANEL_DIG_TABLE * 2 )
                 				LDIW Z,VPANEL_DIG_TABLE*2	;Apunto Z a la seccin de ROM donde se delimita cada unidad
0002f0 2711      VPANEL_DIG:		CLR AUX1					;Ac se guardar el x1
0002f1 2722      				CLR AUX2					;Ac se guardar el x10
                 LOOP_DIG_PANEL:			
0002f2 d030      				RCALL SET_VPANEL_DIG		;Busco el nmero
0002f3 f056      				BRTS V_PANEL_DEC
0002f4 9513      				INC AUX1					;Incremento para ver si es el siguiente en el prox ciclo
0002f5 301a      				CPI AUX1,10					;Veo si super 10 para ver si tengo que poner el x10 en 1
0002f6 f010      				BRLO LOWER_THAN_10_DIG_PANEL;Si no super 10, sigo el ciclo
0002f7 2711      				CLR AUX1					;Si es 10, x1 es 0
0002f8 9523      				INC AUX2					;Si es 10, x10 es 1
0002f9 f7c6      LOWER_THAN_10_DIG_PANEL:	BRTC LOOP_DIG_PANEL
                +
0002fa e371     +ldi AUX4 , 48 + 1
0002fb 937d     +st X + , AUX4
                 				STI X+,48+1					;Si se completaron todos los ciclos, el x10 es 1
                +
0002fc e379     +ldi AUX4 , 48 + 9
0002fd 937d     +st X + , AUX4
                 				STI X+,48+9					;Si se completaron todos los ciclos, el x1 es 9
                +
0002fe e5e4     +ldi ZL , LOW ( VPANEL_DIG_TABLE * 2 )
0002ff e0fa     +ldi ZH , HIGH ( VPANEL_DIG_TABLE * 2 )
                 V_PANEL_DEC:	LDIW Z,VPANEL_DIG_TABLE*2	;Vuelvo a apuntar Z al comienzo de la tabla donde estn los nmeros que delimitan cada unidad
000300 5310      				SUBI AUX1,48				;Lo vuelvo a convertir en nmero no ASCII
000301 5320      				SUBI AUX2,48
000302 e06a      				LDI AUX3,10					;Cargo 10 en AUX3 para multiplicar el x10 por 10 y poder sumarselo al x1
000303 9f26      				MUL AUX2,AUX3				;Multiplico el x10 por 10
000304 2d20      				MOV AUX2,R0					;Paso el resultado de R0 a AUX2
000305 0f12      				ADD AUX1,AUX2				;Sumo x1 y x10 para tener el nmero completo
                +
                +
                +
                +
000306 0fe1     +ADD ZL , AUX1
000307 f41b     +BRVC NO_POINTER_OV
000308 95f3     +INC ZH
000309 1b1e     +SUB AUX1 , ZL
00030a 2f1e     +MOV AUX1 , ZL
00030b 0000     +NO_POINTER_OV : NOP
                 				ADDP Z,AUX1					;Le sumo al puntero Z la cantidad de posiciones que se tiene que mover en la tabla para ver el nmero mximo que puede tener esa unidad
00030c 9114      				LPM AUX1,Z					;Cargo el nmero delimitador
00030d 1b14      				SUB AUX1,ADC_DATA_H			;Le resto al delimitador el nmero que med
                +
00030e e27e     +ldi AUX4 , '.'
00030f 937d     +st X + , AUX4
                 				STI	X+,'.'
000310 ed22      				ldi	aux2,210		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
000311 9f12      				MUL	AUX1,AUX2
000312 2d11      				MOV	AUX1,R1
000313 1b61      				SUB AUX3,AUX1					
                +
                +
                +
                +
000314 e27f     +LDI AUX4 , 48 - 1
000315 0f67     +ADD AUX3 , AUX4
                 				ADDI AUX3,48-1		;SE TRANSFORMA EN ASCII
                 
000316 936d      vuelvo_9_panel:	ST X+,AUX3	;El ASCII del nmero en AUX.
                +
000317 e576     +ldi AUX4 , 'V'
000318 937d     +st X + , AUX4
                 				STI	X+,'V'
                +
000319 e07d     +ldi AUX4 , '\r'
00031a 937d     +st X + , AUX4
                 				STI X+,'\r'
                +
00031b e07a     +ldi AUX4 , '\n'
00031c 937d     +st X + , AUX4
                 				STI X+,'\n'
                +
00031d e070     +ldi AUX4 , 0
00031e 937c     +st X , AUX4
                 				STI	X,0
00031f 94e8      				CLT
000320 9508      RET
                 
                 ajuste_9_panel:
000321 e369      				ldi aux3,'9'
000322 cff3      				rjmp vuelvo_9_panel
                 	
                 SET_VPANEL_DIG:
000323 9105      					LPM AUX,Z+				;Leo de tabla en ROM
000324 9503      					INC AUX					;Incremento lo ledo porque se usar BRSH
000325 1740      					CP ADC_DATA_H,AUX		;Veo si el nmero es menor al de la tabla a ver si encontramos el valor
000326 f438      					BRSH END_SET_VPANEL_DIG	;Si es mayor o igual, sigo buscando
                 											;ESTO NO ES LO QUE QUERES HACER
                +
                +
                +
                +
000327 e370     +LDI AUX4 , 48
000328 0f17     +ADD AUX1 , AUX4
                 					ADDI AUX1,48			;Le sumo 48 al nmero porque los nmeros en ASCII comienzan a partir de 48
                +
                +
                +
                +
000329 e370     +LDI AUX4 , 48
00032a 0f27     +ADD AUX2 , AUX4
                 					ADDI AUX2,48
00032b 932d      					ST X+,AUX2				;Guardo el x10
00032c 931d      					ST X+,AUX1				;Guardo el x1
00032d 9468      					SET
                 .include "LDRS.inc"
00032e 9508      
                 ;
                 ;						HEADER DE LOS LDR'S
                 ;			NO USAR EL ADC5 PARA COMPARAR! FUERA DE ESCALA
                 ;------------------------------------------------------------------
                 .CSEG
                 
                 LDRS_INIT:
00032f d01e      		RCALL LDRS_POINTERS_RESET
000330 2744      LOOP:	CLR ADC_DATA_H
                +
                +
                +
                +
                +
000331 2de2     +MOV ZL , LDR_NO_LOW
000332 2df3     +MOV ZH , LDR_NO_HIGH
000333 9341     +ST Z + , ADC_DATA_H
000334 2e2e     +MOV LDR_NO_LOW , ZL
000335 2e3f     +MOV LDR_NO_HIGH , ZH
                 		SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
000336 2deb     +MOV ZL , LDR_SO_LOW
000337 2dfc     +MOV ZH , LDR_SO_HIGH
000338 9341     +ST Z + , ADC_DATA_H
000339 2ebe     +MOV LDR_SO_LOW , ZL
00033a 2ecf     +MOV LDR_SO_HIGH , ZH
                 		SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
00033b 2de6     +MOV ZL , LDR_SE_LOW
00033c 2df7     +MOV ZH , LDR_SE_HIGH
00033d 9341     +ST Z + , ADC_DATA_H
00033e 2e6e     +MOV LDR_SE_LOW , ZL
00033f 2e7f     +MOV LDR_SE_HIGH , ZH
                 		SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
000340 2de4     +MOV ZL , LDR_NE_LOW
000341 2df5     +MOV ZH , LDR_NE_HIGH
000342 9341     +ST Z + , ADC_DATA_H
000343 2e4e     +MOV LDR_NE_LOW , ZL
000344 2e5f     +MOV LDR_NE_HIGH , ZH
                 		SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
000345 9100 0174+.else 
                +lds AUX , COUNTER
                 		INPUT AUX,COUNTER
000347 9503      		INC AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
000348 9300 0174+.else 
                +sts COUNTER , AUX
                 		OUTPUT COUNTER,AUX
00034a 3008      		CPI AUX,CANT_SAMPLES			;CHEQUEAR QUE NO ESTE HACIENDO UNO DE MENOS
00034b f320      		BRLO LOOP
00034c d001      		RCALL LDRS_POINTERS_RESET
00034d 9508      RET
                 
                 LDRS_POINTERS_RESET:
                +
00034e e500     +ldi AUX , LOW ( LDR_NO_BUFFER )
00034f 2e20     +mov LDR_NO_LOW , AUX
                 	MOVI LDR_NO_LOW,LOW(LDR_NO_BUFFER)
                +
000350 e001     +ldi AUX , HIGH ( LDR_NO_BUFFER )
000351 2e30     +mov LDR_NO_HIGH , AUX
                 	MOVI LDR_NO_HIGH,HIGH(LDR_NO_BUFFER)
                 
                +
000352 e508     +ldi AUX , LOW ( LDR_NE_BUFFER )
000353 2e40     +mov LDR_NE_LOW , AUX
                 	MOVI LDR_NE_LOW,LOW(LDR_NE_BUFFER)
                +
000354 e001     +ldi AUX , HIGH ( LDR_NE_BUFFER )
000355 2e50     +mov LDR_NE_HIGH , AUX
                 	MOVI LDR_NE_HIGH,HIGH(LDR_NE_BUFFER)
                 
                +
000356 e600     +ldi AUX , LOW ( LDR_SE_BUFFER )
000357 2e60     +mov LDR_SE_LOW , AUX
                 	MOVI LDR_SE_LOW,LOW(LDR_SE_BUFFER)
                +
000358 e001     +ldi AUX , HIGH ( LDR_SE_BUFFER )
000359 2e70     +mov LDR_SE_HIGH , AUX
                 	MOVI LDR_SE_HIGH,HIGH(LDR_SE_BUFFER)
                 
                +
00035a e608     +ldi AUX , LOW ( LDR_SO_BUFFER )
00035b 2eb0     +mov LDR_SO_LOW , AUX
                 	MOVI LDR_SO_LOW,LOW(LDR_SO_BUFFER)
                +
00035c e001     +ldi AUX , HIGH ( LDR_SO_BUFFER )
00035d 2ec0     +mov LDR_SO_HIGH , AUX
                 	MOVI LDR_SO_HIGH,HIGH(LDR_SO_BUFFER)
                 
00035e 2700      	CLR AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
00035f 9300 0174+.else 
                +sts COUNTER , AUX
                 	OUTPUT COUNTER,AUX
000361 9508      RET
                 
                 LDRS_READ:
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
000362 9100 0174+.else 
                +lds AUX , COUNTER
                 	INPUT AUX,COUNTER			;CHEQUEO QUE SEA MENOR A CANT_SAMPLES. SI ES MAYOR, RESETEO LOS PUNTEROS. [EL BUFFER ESTA LLENO, SACO LA PRIMER MUESTRA].
000364 3008      	CPI AUX,CANT_SAMPLES
000365 f0f1      	BREQ _LDRS_POINTERS_RESET
                 LDRS_POINTERS_RESET_RETURN:
                 
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
000366 9100 0174+.else 
                +lds AUX , COUNTER
                 	INPUT AUX,COUNTER
000368 9503      		INC AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
000369 9300 0174+.else 
                +sts COUNTER , AUX
                 	OUTPUT COUNTER,AUX
                 
00036b d074      	RCALL READ_LDR_NO										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
00036c 2de2     +MOV ZL , LDR_NO_LOW
00036d 2df3     +MOV ZH , LDR_NO_HIGH
00036e 9341     +ST Z + , ADC_DATA_H
00036f 2e2e     +MOV LDR_NO_LOW , ZL
000370 2e3f     +MOV LDR_NO_HIGH , ZH
                 	SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
000371 d07a      	RCALL READ_LDR_NE										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
000372 2de4     +MOV ZL , LDR_NE_LOW
000373 2df5     +MOV ZH , LDR_NE_HIGH
000374 9341     +ST Z + , ADC_DATA_H
000375 2e4e     +MOV LDR_NE_LOW , ZL
000376 2e5f     +MOV LDR_NE_HIGH , ZH
                 	SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
000377 d070      	RCALL READ_LDR_SE										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
000378 2de6     +MOV ZL , LDR_SE_LOW
000379 2df7     +MOV ZH , LDR_SE_HIGH
00037a 9341     +ST Z + , ADC_DATA_H
00037b 2e6e     +MOV LDR_SE_LOW , ZL
00037c 2e7f     +MOV LDR_SE_HIGH , ZH
                 	SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
00037d d066      	RCALL READ_LDR_SO										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
00037e 2deb     +MOV ZL , LDR_SO_LOW
00037f 2dfc     +MOV ZH , LDR_SO_HIGH
000380 9341     +ST Z + , ADC_DATA_H
000381 2ebe     +MOV LDR_SO_LOW , ZL
000382 2ecf     +MOV LDR_SO_HIGH , ZH
                 	SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
000383 9508      RET
                 
                 _LDRS_POINTERS_RESET:
000384 dfc9      	RCALL LDRS_POINTERS_RESET
000385 cfe0      RJMP LDRS_POINTERS_RESET_RETURN
                 
                 LDRS_MEAN:
                 ;OBS: PARA HACER EL PROMEDIO NO IMPORTA SI NO SE TOMARON CANT_SAMPLES, EL BUFFER ESTA INICIALIZADO CON CERO.
000386 e008      	LDI	AUX,CANT_SAMPLES					;VECTMEAN NECESITA LA CANTIDAD DE LAS MUESTRAS
                 
                +
000387 e5e0     +ldi ZL , LOW ( LDR_NO_BUFFER )
000388 e0f1     +ldi ZH , HIGH ( LDR_NO_BUFFER )
                 	LDIW Z,LDR_NO_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
000389 930f     +PUSH AUX
00038a 9161     +LD AUX3 , Z +
00038b 2711     +CLR AUX1
00038c 950a     +DEC AUX
00038d 2722     +CLR AUX2
                +loop_mean :
00038e 94b8     +CLV
00038f 9171     +LD AUX4 , Z +
000390 0f67     +ADD AUX3 , AUX4
000391 1f12     +ADC AUX1 , AUX2
000392 950a     +DEC AUX
000393 f7d1     +BRNE loop_mean
000394 e023     +LDI AUX2 , 3
                +division :
000395 9516     +LSR AUX1
000396 9567     +ROR AUX3
000397 952a     +DEC AUX2
000398 f7e1     +BRNE division
000399 2f16     +MOV AUX1 , AUX3
00039a 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +out LDR_NO_MEAN , AUX1
00039b 9310 0170+.else 
                +sts LDR_NO_MEAN , AUX1
                 	OUTPUT LDR_NO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
00039d e5e8     +ldi ZL , LOW ( LDR_NE_BUFFER )
00039e e0f1     +ldi ZH , HIGH ( LDR_NE_BUFFER )
                 	LDIW Z,LDR_NE_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
00039f 930f     +PUSH AUX
0003a0 9161     +LD AUX3 , Z +
0003a1 2711     +CLR AUX1
0003a2 950a     +DEC AUX
0003a3 2722     +CLR AUX2
                +loop_mean :
0003a4 94b8     +CLV
0003a5 9171     +LD AUX4 , Z +
0003a6 0f67     +ADD AUX3 , AUX4
0003a7 1f12     +ADC AUX1 , AUX2
0003a8 950a     +DEC AUX
0003a9 f7d1     +BRNE loop_mean
0003aa e023     +LDI AUX2 , 3
                +division :
0003ab 9516     +LSR AUX1
0003ac 9567     +ROR AUX3
0003ad 952a     +DEC AUX2
0003ae f7e1     +BRNE division
0003af 2f16     +MOV AUX1 , AUX3
0003b0 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +out LDR_NE_MEAN , AUX1
0003b1 9310 0171+.else 
                +sts LDR_NE_MEAN , AUX1
                 	OUTPUT LDR_NE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
0003b3 e6e0     +ldi ZL , LOW ( LDR_SE_BUFFER )
0003b4 e0f1     +ldi ZH , HIGH ( LDR_SE_BUFFER )
                 	LDIW Z,LDR_SE_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
0003b5 930f     +PUSH AUX
0003b6 9161     +LD AUX3 , Z +
0003b7 2711     +CLR AUX1
0003b8 950a     +DEC AUX
0003b9 2722     +CLR AUX2
                +loop_mean :
0003ba 94b8     +CLV
0003bb 9171     +LD AUX4 , Z +
0003bc 0f67     +ADD AUX3 , AUX4
0003bd 1f12     +ADC AUX1 , AUX2
0003be 950a     +DEC AUX
0003bf f7d1     +BRNE loop_mean
0003c0 e023     +LDI AUX2 , 3
                +division :
0003c1 9516     +LSR AUX1
0003c2 9567     +ROR AUX3
0003c3 952a     +DEC AUX2
0003c4 f7e1     +BRNE division
0003c5 2f16     +MOV AUX1 , AUX3
0003c6 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_SE_MEAN < 0x40
                +out LDR_SE_MEAN , AUX1
0003c7 9310 0172+.else 
                +sts LDR_SE_MEAN , AUX1
                 	OUTPUT LDR_SE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
0003c9 e6e8     +ldi ZL , LOW ( LDR_SO_BUFFER )
0003ca e0f1     +ldi ZH , HIGH ( LDR_SO_BUFFER )
                 	LDIW Z,LDR_SO_BUFFER					;UBICO EL LDR_SO EN UN PUNTERO.
                +
0003cb 930f     +PUSH AUX
0003cc 9161     +LD AUX3 , Z +
0003cd 2711     +CLR AUX1
0003ce 950a     +DEC AUX
0003cf 2722     +CLR AUX2
                +loop_mean :
0003d0 94b8     +CLV
0003d1 9171     +LD AUX4 , Z +
0003d2 0f67     +ADD AUX3 , AUX4
0003d3 1f12     +ADC AUX1 , AUX2
0003d4 950a     +DEC AUX
0003d5 f7d1     +BRNE loop_mean
0003d6 e023     +LDI AUX2 , 3
                +division :
0003d7 9516     +LSR AUX1
0003d8 9567     +ROR AUX3
0003d9 952a     +DEC AUX2
0003da f7e1     +BRNE division
0003db 2f16     +MOV AUX1 , AUX3
0003dc 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +out LDR_SO_MEAN , AUX1
0003dd 9310 0173+.else 
                +sts LDR_SO_MEAN , AUX1
                 	OUTPUT LDR_SO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
0003df 9508      RET	
                 
                 
                 
                 
                 READ_LDR_NO:
0003e0 e033      	LDI ADC_DATA_L,LDR_NO
0003e1 dc97      	RCALL ADC_SELECT_INPUT
0003e2 dc9d      	RCALL ADC_SIMPLE_CONVERSION
0003e3 9508      RET
                 
                 READ_LDR_SO:
0003e4 e035      	LDI ADC_DATA_L,LDR_SO
0003e5 dc93      	RCALL ADC_SELECT_INPUT
0003e6 dc99      	RCALL ADC_SIMPLE_CONVERSION
0003e7 9508      RET
                 
                 READ_LDR_SE:
0003e8 e034      	LDI ADC_DATA_L,LDR_SE
0003e9 dc8f      	RCALL ADC_SELECT_INPUT
0003ea dc95      	RCALL ADC_SIMPLE_CONVERSION
0003eb 9508      RET
                 
                 READ_LDR_NE:
0003ec e032      	LDI ADC_DATA_L,LDR_NE
0003ed dc8b      	RCALL ADC_SELECT_INPUT
0003ee dc91      	RCALL ADC_SIMPLE_CONVERSION
                 .include "MOTORS.inc"
0003ef 9508      
                 ;
                 ;							MOTORS.inc
                 ;
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 MOTORS_INIT:
                +
                +
                +.if DDRD < 0x40
0003f0 b10a     +in AUX , DDRD
                +.else 
                +lds AUX , DDRD
                 	INPUT AUX,DDRD
0003f1 790f      	ANDI AUX,(~((1<<DDD5)|(1<<DDD6)))
0003f2 6600      	ORI AUX,((1<<DDD5)|(1<<DDD6))
                +
                +
                +.if DDRD < 0x40
0003f3 b90a     +out DDRD , AUX
                +.else 
                +sts DDRD , AUX
                 	OUTPUT DDRD,AUX
                 
                +
                +
                +.if PORTD < 0x40
0003f4 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
0003f5 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
0003f6 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
0003f7 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
0003f8 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
                +
                +
                +.if OCR1AH < 0x40
                +out OCR1AH , AUX
0003fa 9300 0089+.else 
                +sts OCR1AH , AUX
                 	OUTPUT	OCR1AH,AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
0003fc 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                +
                +
                +.if OCR1BH < 0x40
                +out OCR1BH , AUX
0003fe 9300 008b+.else 
                +sts OCR1BH , AUX
                 	OUTPUT	OCR1BH,AUX
000400 9508      RET
                 
                 MOTOR_AZIMUT_EAST:
                 ;RECIBE EN AUX3 EL VALOR A MOVERSE EN EL PWM
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000401 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000403 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
000404 6851      	ORI PWM_DATA,((1<<COM1A1)|(0<<COM1A0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
000405 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
000407 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000408 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
000409 6400      	ORI AUX,((0<<MOT_1)|(1<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
00040a b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
00040b 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
00040c 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
00040e d010      	rcall smooth_move_azimut
                 	;OUTPUT	OCR1AL,AUX1
00040f 9508      RET
                 
                 MOTOR_AZIMUT_WEST:
                 ;RECIBE EN AUX3 EL VALOR A MOVERSE EN EL PWM
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000410 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000412 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
000413 6851      	ORI PWM_DATA,((1<<COM1A1)|(0<<COM1A0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
000414 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
000416 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000417 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
000418 6200      	ORI AUX,((1<<MOT_1)|(0<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
000419 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
00041a 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
00041b 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
00041d d001      	rcall smooth_move_azimut
                 	;OUTPUT	OCR1AL,AUX1
00041e 9508      RET
                 
                 smooth_move_azimut:
00041f 2777      	clr aux4
000420 9573      _s:	inc aux4
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
000421 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
000423 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
000425 dd86      	RCALL DELAY_100us
000426 3a7a      	cpi aux4,170
000427 f410      	brsh nxt
000428 dd83      	rcall delay_100us
000429 dd82      	rcall delay_100us
                 nxt:
00042a dd81      	rcall delay_100us
00042b dd80      	rcall delay_100us
00042c 1776      	cp aux4,AUX3
00042d f390      	brlo _s
00042e 9508      ret
                 
                 MOTOR_AZIMUT_OFF:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
00042f 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000431 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
000432 6051      	ORI PWM_DATA,((1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
000433 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
000435 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000436 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
000437 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
                +
                +
                +.if OCR1AL < 0x40
                +in AUX4 , OCR1AL
000438 9170 0088+.else 
                +lds AUX4 , OCR1AL
                 	INPUT AUX4,OCR1AL
                 
                 brake_AZIMUT:
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
00043a 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
00043c 387c      	cpI aux4,140
00043d f410      	brSH	ASDF
00043e dd6d      	RCALL DELAY_100us
00043f dd6c      	RCALL DELAY_100us
000440 dd6b      ASDF:	RCALL DELAY_100us
000441 dd6a      	RCALL DELAY_100us
000442 dd69      	RCALL DELAY_100us
000443 957a      	dec aux4
000444 f7a9      	brne brake_AZIMUT
                 
000445 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
000446 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
000448 9508      RET
                 
                 MOTOR_ELEVATION_SOUTH:
                 ;RECIBE EN AUX3 EL VALOR A MOVERSE EN EL PWM
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000449 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
00044b 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
00044c 6251      	ORI PWM_DATA,((1<<COM1B1)|(0<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
00044d 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
00044f b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000450 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
000451 6200      	ORI AUX,((1<<MOT_1)|(0<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
000452 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
000453 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
000454 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 	
000456 d010      	rcall smooth_move_elevation
                 	;OUTPUT	OCR1BL,AUX1
000457 9508      RET
                 
                 MOTOR_ELEVATION_NORTH:
                 ;RECIBE EN AUX3 EL VALOR A MOVERSE EN EL PWM
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000458 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
00045a 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
00045b 6251      	ORI PWM_DATA,((1<<COM1B1)|(0<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
00045c 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
00045e b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
00045f 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
000460 6400      	ORI AUX,((0<<MOT_1)|(1<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
000461 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
000462 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
000463 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 
000465 d001      	RCALL smooth_move_elevation
000466 9508      RET
                 
                 smooth_move_elevation:
000467 2777      	clr aux4
000468 9573      _sM:	inc aux4
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
000469 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
00046b 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
00046d dd3e      	RCALL DELAY_100us
00046e 3a7a      	cpi aux4,170
00046f f410      	brsh nxtM
000470 dd3b      	rcall delay_100us
000471 dd3a      	rcall delay_100us
                 nxtM:
000472 dd39      	rcall delay_100us
000473 dd38      	rcall delay_100us
000474 1776      	cp aux4,AUX3
000475 f390      	brlo _sM
000476 9508      ret
                 
                 MOTOR_ELEVATION_OFF:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000477 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000479 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
00047a 6051      	ORI PWM_DATA,((1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
00047b 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
00047d b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
00047e 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
00047f b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
                +
                +
                +.if OCR1BL < 0x40
                +in AUX4 , OCR1BL
000480 9170 008a+.else 
                +lds AUX4 , OCR1BL
                 	INPUT AUX4,OCR1BL
                 
                 brake_elevation:
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
000482 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
000484 3a7a      	cpI aux4,170
000485 f410      	brSH	ASF
000486 dd25      	RCALL DELAY_100us
000487 dd24      	RCALL DELAY_100us
000488 dd23      ASF:	RCALL DELAY_100us
000489 dd22      	RCALL DELAY_100us
00048a dd21      	RCALL DELAY_100us
00048b 957a      	dec aux4
00048c f7a9      	brne brake_elevation
                 
00048d 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
00048e 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 
000490 9508      RET
                 
                 RETURN_TO_ORIGIN:
                 ;BIEN HARDCODEADO.
000491 eb6e      	LDI AUX3,190
000492 df6e      	RCALL MOTOR_AZIMUT_EAST
000493 dd2a      		RCALL DELAY_500ms
000494 dd29      		RCALL DELAY_500ms
000495 dd28      		RCALL DELAY_500ms
000496 dd27      		RCALL DELAY_500ms
000497 df97      	RCALL MOTOR_AZIMUT_OFF
                 .include "MESSAGES.inc"
000498 9508      
                 ;MENSAJES EN ROM
000499 4f53
00049a 414c
00049b 2052
00049c 5254
00049d 4341
00049e 454b
00049f 0d52
0004a0 480a
0004a1 4341
0004a2 4549
0004a3 444e
0004a4 204f
0004a5 4c45
0004a6 4620
0004a7 5455
0004a8 5255
0004a9 0d4f
0004aa 000a      MSJ_PROJECT_NAME:			.DB	"SOLAR TRACKER",'\r','\n',"HACIENDO EL FUTURO",'\r','\n',0
0004ab 414c
0004ac 5420
0004ad 4e45
0004ae 4953
0004af 4e4f
0004b0 4420
0004b1 2045
0004b2 414c
0004b3 4220
0004b4 5441
0004b5 5245
0004b6 4149
0004b7 4520
0004b8 3a53
0004b9 0020      MSJ_V_BAT:					.DB	"LA TENSION DE LA BATERIA ES: ",0
0004ba 414c
0004bb 5420
0004bc 4e45
0004bd 4953
0004be 4e4f
0004bf 4420
0004c0 4c45
0004c1 5020
0004c2 4e41
0004c3 4c45
0004c4 4520
0004c5 3a53
0004c6 0020      MSJ_V_PANEL:				.DB "LA TENSION DEL PANEL ES: ",0
0004c7 4e45
0004c8 4543
0004c9 444e
0004ca 5349
0004cb 4554
0004cc 4c20
0004cd 2041
0004ce 554c
0004cf 2e5a
0004d0 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(6): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(166): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
0004d1 0000      MSJ_LIGHT_ON:				.DB "ENCENDISTE LA LUZ.",'\r','\n',0
0004d2 5041
0004d3 4741
0004d4 5341
0004d5 4554
0004d6 4c20
0004d7 2041
0004d8 554c
0004d9 2e5a
0004da 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(7): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(166): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
0004db 0000      MSJ_LIGHT_OFF:				.DB "APAGASTE LA LUZ.",'\r','\n',0
0004dc 4553
0004dd 4d20
0004de 564f
0004df 4f49
0004e0 4520
0004e1 204c
0004e2 4150
0004e3 454e
0004e4 204c
0004e5 4c41
0004e6 4520
0004e7 5453
0004e8 2e45
0004e9 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(8): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(166): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
0004ea 0000      MSJ_AZIMUT_EAST:			.DB "SE MOVIO EL PANEL AL ESTE.",'\r','\n',0
0004eb 4553
0004ec 4d20
0004ed 564f
0004ee 4f49
0004ef 4520
0004f0 204c
0004f1 4150
0004f2 454e
0004f3 204c
0004f4 4c41
0004f5 4f20
0004f6 5345
0004f7 4554
0004f8 0d2e
0004f9 000a      MSJ_AZIMUT_WEST:			.DB	"SE MOVIO EL PANEL AL OESTE.",'\r','\n',0
0004fa 4553
0004fb 4d20
0004fc 564f
0004fd 4f49
0004fe 4520
0004ff 204c
000500 4150
000501 454e
000502 204c
000503 4c41
000504 4e20
000505 524f
000506 4554
000507 0d2e
000508 000a      MSJ_ELEVATION_NORTH:		.DB "SE MOVIO EL PANEL AL NORTE.",'\r','\n',0
000509 4553
00050a 4d20
00050b 564f
00050c 4f49
00050d 4520
00050e 204c
00050f 4150
000510 454e
000511 204c
000512 4c41
000513 5320
000514 5255
000515 0d2e
000516 000a      MSJ_ELEVATION_SOUTH:		.DB	"SE MOVIO EL PANEL AL SUR.",'\r','\n',0
000517 7247
000518 6361
000519 6169
00051a 2073
00051b 6f70
00051c 2072
00051d 7375
00051e 7261
00051f 6520
000520 206c
000521 4f53
000522 414c
000523 2052
000524 5254
000525 4341
000526 454b
000527 2152
000528 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(12): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(166): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
000529 0000      MSJ_DISCONNECTED_BT:		.DB "Gracias por usar el SOLAR TRACKER!",'\r','\n',0
                 ;MSJ_DISCONNECTED_BATTERY:	.DB "LA BATERIA ESTA DESCONECTADA!",'\r','\n',0
                 ;MSJ_DISCONNECTED_PANEL:	.DB "EL PANEL ESTA DESCONECTADO!",'\r','\n',0
                 
00052a 190c
00052b 3326
00052c 4c40
00052d 6659
00052e 7f73
00052f 998d
000530 b3a6
000531 cdc0
000532 e6d9
000533 fff3      VPANEL_DIG_TABLE:			.DB	12,25,38,51,64,76,89,102,115,127,141,153,166,179,192,205,217,230,243,255
000534 0100
000535 0302
000536 0504
000537 0605
000538 0807
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(17): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(166): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
000539 0009      VPANEL_DEC_TABLE:			.DB 0,1,2,3,4,5,5,6,7,8,9
                 
00053a 2010
00053b 4130
00053c 6151
00053d 8272
00053e a392
00053f c3b3
000540 e4d4
000541 fff4      VBATTERY_DIG_TABLE:			.DB 16,32,48,65,81,97,114,130,146,163,179,195,212,228,244,255
000542 0100
000543 0201
000544 0303
000545 0504
000546 0605
000547 0707
000548 0908
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(20): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(166): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
000549 0009      VBATTERY_DEC_TABLE:			.DB 0,1,1,2,3,3,4,5,5,6,7,7,8,9,9
                 
                 
                 
                 
                 	


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega88" register use summary:
r0 :   2 r1 :   2 r2 :   5 r3 :   5 r4 :   5 r5 :   5 r6 :   5 r7 :   5 
r8 :   5 r9 :   1 r10:   6 r11:   5 r12:   5 r13:   0 r14:   0 r15:   0 
r16: 270 r17:  92 r18:  40 r19:  14 r20:  19 r21:  48 r22:  40 r23: 106 
r24:   0 r25:   0 r26:  25 r27:  21 r28:   4 r29:   4 r30:  47 r31:  43 
x  :  41 y  :   1 z  :  22 
Registers used: 30 out of 35 (85.7%)

"ATmega88" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   4 add   :  17 adiw  :   0 and   :   0 
andi  :  43 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   4 break :   0 breq  :  21 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  17 brlt  :   0 brmi  :   0 
brne  :  22 brpl  :   0 brsh  :   9 brtc  :   2 brts  :   2 brvc  :   2 
brvs  :   0 bset  :   0 bst   :   0 cbi   :   0 cbr   :   1 clc   :   4 
clh   :   0 cli   :   0 cln   :   0 clr   :  31 cls   :   0 clt   :   2 
clv   :   4 clz   :   0 com   :   0 cp    :   8 cpc   :   0 cpi   :  37 
cpse  :   0 dec   :  24 eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 
icall :   0 ijmp  :   0 in    :  20 inc   :  15 ld    :  10 ldd   :   0 
ldi   : 164 lds   :  38 lpm   :   8 lsl   :   0 lsr   :   4 mov   :  56 
movw  :   4 mul   :   4 muls  :   0 mulsu :   0 neg   :   0 nop   :   4 
or    :   1 ori   :  31 out   :  21 pop   :  23 push  :  23 rcall : 147 
ret   :  51 reti  :   4 rjmp  :  32 rol   :   0 ror   :   4 sbc   :   0 
sbci  :   0 sbi   :   0 sbic  :   0 sbis  :   0 sbiw  :   0 sbr   :   2 
sbrc  :   1 sbrs  :   0 sec   :   2 seh   :   0 sei   :   1 sen   :   0 
ser   :   1 ses   :   0 set   :   2 sev   :   0 sez   :   0 sleep :   1 
spm   :   0 st    :  48 std   :   0 sts   :  62 sub   :  12 subi  :   4 
swap  :   0 tst   :   4 wdr   :   0 
Instructions used: 52 out of 111 (46.8%)

"ATmega88" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000a94   2312    354   2666    8192  32.5%
[.dseg] 0x000100 0x000177      0    119    119    1024  11.6%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 6 warnings
