
AVRASM ver. 2.1.57  C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm Mon Jun 20 20:04:02 2016

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m88def.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(8): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m88def.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(9): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar_Tracker.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(10): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\avr_macros.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(220): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\ADC.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(221): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\PWM.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(222): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\SERIAL_PORT.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(223): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\DELAY.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(224): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\LIGHT.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(225): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\BATTERY.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(226): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\SOLAR_PANEL.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(227): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\LDRS.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(228): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MOTORS.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(229): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc'
                 
                 /*
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega88.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m88def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega88
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega88
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M88DEF_INC_
                 #define _M88DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega88
                 #pragma AVRPART ADMIN PART_NAME ATmega88
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x0a
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0A_0	= 0	; 
                 .equ	OCR0A_1	= 1	; 
                 .equ	OCR0A_2	= 2	; 
                 .equ	OCR0A_3	= 3	; 
                 .equ	OCR0A_4	= 4	; 
                 .equ	OCR0A_5	= 5	; 
                 .equ	OCR0A_6	= 6	; 
                 .equ	OCR0A_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - 
                 .equ	SE	= 0	; 
                 .equ	SM0	= 1	; 
                 .equ	SM1	= 2	; 
                 .equ	SM2	= 3	; 
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x04ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0003	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0004	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x0005	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x0006	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x0007	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0008	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0009	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x000a	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x000b	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x000c	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x000d	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x000e	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x000f	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0010	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0011	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0012	; USART Rx Complete
                 .equ	UDREaddr	= 0x0013	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0014	; USART Tx Complete
                 .equ	ADCCaddr	= 0x0015	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x0016	; EEPROM Ready
                 .equ	ACIaddr	= 0x0017	; Analog Comparator
                 .equ	TWIaddr	= 0x0018	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0019	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 26	; size in words
                 
                 #endif  /* _M88DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                  * Solar_Tracker.asm
                  *
                  *  Created: 08/06/2016 07:45:11 p.m.
                  *   Author: Agustn Picard, Joaquin Ulloa, Mauro Giordano
                  */ 
                 
                 .include "m88def.inc"   	;Incluye los nombres de los registros del micro
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega88.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m88def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega88
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega88
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M88DEF_INC_
                 #endif  /* _M88DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 .include "Solar_Tracker.inc"
                 
                 
                 	 Me parece mas comodo e intuitivo
                 	poner los registros y definiciones
                 		en un header general
                 
                 ******************************************/
                 .DSEG
                 .ORG SRAM_START
                 
                 ;--------------------HEADER DE LA LUZ-----------------------------------------------
                 .EQU	LIGHT_PIN					=	PD3
                 ;-----------------------------------------------------------------------------------
                 
                 
                 ;--------------------HEADER DEL ADC-------------------------------------------------
                 .DEF	ADC_DATA_L					=	R19
                 .DEF	ADC_DATA_H					=	R20
                 
                 .EQU	ADC_BATTERY					=	6		;LA BATERIA ESTA EN EL PIN 19 [ADC6]
                 .EQU	ADC_SOLAR_PANEL				=	7		;EL PANEL ESTA EN EL PIN 22 [ADC7]
                 ;-----------------------------------------------------------------------------------
                 
                 
                 ;--------------------HEADER DEL PUERTO SERIE----------------------------------------
                 .EQU	BAUD_RATE					=	103	; 12	76.8 kbps e=0.2%	@8MHz y U2X=1
                 											; 25	38.4 kbps e=0.2%	@8MHz y U2X=1
                 											; 51	19.2 kbps e=0.2% 	@8MHz y U2X=1
                 											; 103	9600 bps  e=0.2% 	@8MHz y U2X=1
                 
                 .EQU	BUF_SIZE					=	 64	;tamao en bytes del buffer de transmisin
                 
                 ;SERIE DE COMANDOS DE RECEPCION POR BT
                 .EQU	BT_COMMAND_PROJECT_NAME		=	'q'
                 .EQU	BT_COMMAND_V_BAT			=	'2'
                 .EQU	BT_COMMAND_V_PANEL			=	'3'
                 .EQU	BT_COMMAND_LIGHT_TURN_ON	=	'4'
                 .EQU	BT_COMMAND_LIGHT_TURN_OFF	=	'5'
                 .EQU	BT_COMMAND_DISCONNECT		=	'6'
                 
000100           TX_BUF:	.BYTE	BUF_SIZE	; buffer de transmisin
                 
                 .DEF	PTR_TX_L					=	R8		;puntero al buffer de datos a transmitir
                 .DEF	PTR_TX_H					=	R9
                 .DEF	BYTES_A_TX					=	R10 	;nro. de bytes a transmitir desde el buffer
                 ;-----------------------------------------------------------------------------------
                 
                 ;--------------------------------HEADER DE LA BATERIA-------------------------------
                 .EQU	PIN_BATTERY_LED_OK			=	PD4
                 .EQU	PIN_BATTERY_LED_LOW			=	PD7
                 
                 .EQU	MIN_BATTERY_VALUE			=	170		;{0,255} RESULTADO DEL ADC QUE HACE IR A BAJO CONSUMO EL EQUIPO POR NO TENER SUFICIENTE TENSION
                 										;YA ESTA AJUSTADO! 10.6v
000140           V_BATTERY_DATA:		.BYTE 8			;[DECENA,UNIDAD,'.',DECIMAL,'V','\r','\n',0]
                 ;-----------------------------------------------------------------------------------
                 
                 ;-------------------------------HEADER DEL PANEL SOLAR------------------------------
                 .EQU	PIN_SOLAR_PANEL_LED_OK		=	PC1
                 .EQU	PIN_SOLAR_PANEL_LED_LOW		=	PC0
                 
                 .EQU	MIN_SOLAR_PANEL_VALUE		=	50		;{0,255} RESULTADO DEL ADC QUE DECIDE SI ES DE DIA O NOCHE.
                 										;FALTA AJUSTAR CON EL SOL! .... O CON LO QUE VAMOS A MOSTRAR!
000148           V_SOLAR_PANEL_DATA: .BYTE 8			;[DECENA,UNIDAD,'.',DECIMAL,'V','\r','\n',0]
                 ;-----------------------------------------------------------------------------------
                 
                 ;--------------------REGISTROS DE USO GENERAL SIN IMPORTAR QUE TENGA----------------
                 .DEF	AUX							=	R16
                 .DEF	AUX1						=	R17
                 .DEF	AUX2						=	R18
                 .DEF	AUX3						=	R22
                 .DEF	AUX4						=	R23
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DE LDRS---------------------------------------
                 .EQU CANT_SAMPLES = 8 ;TIENE QUE SER MULTIPLO DE 2
                 
000150           LDR_NO_BUFFER:						.BYTE CANT_SAMPLES
000158           LDR_NE_BUFFER:						.BYTE CANT_SAMPLES
000160           LDR_SE_BUFFER:						.BYTE CANT_SAMPLES
000168           LDR_SO_BUFFER:						.BYTE CANT_SAMPLES
000170           LDR_NO_MEAN:						.BYTE 1
000171           LDR_NE_MEAN:						.BYTE 1
000172           LDR_SE_MEAN:						.BYTE 1
000173           LDR_SO_MEAN:						.BYTE 1
000174           auxiliar_para_probar:				.byte 3			;['\r','\n',0]
000177           COUNTER:							.BYTE 2
000179           BT_FLAG:							.BYTE 1				;[FLAG=0xFF]: ESTA CONECTADO A BT. [FLAG=0x00]: NO ESTA CONECTADO A BT.
                 
                 
                 ;LAS CONSTANTES SON PARA EL MUX EN EL ADC
                 .EQU LDR_NO							=	3	;ADC2
                 .EQU LDR_NE							=	2	;ADC3
                 .EQU LDR_SE							=	4	;ADC4
                 .EQU LDR_SO							=	5	;ADC5		NO USAR EL ADC5 PARA COMPARAR! FUERA DE ESCALA LA RESISTENCIA DEL LDR
                 
                 .DEF LDR_NO_LOW						=	R2
                 .DEF LDR_NO_HIGH					=	R3
                 .DEF LDR_NE_LOW						=	R4
                 .DEF LDR_NE_HIGH					=	R5
                 .DEF LDR_SE_LOW						=	R6
                 .DEF LDR_SE_HIGH					=	R7
                 .DEF LDR_SO_LOW						=	R11
                 .DEF LDR_SO_HIGH					=	R12
                 
                 
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DEL PWM---------------------------------------
                 .DEF PWM_DATA					 	=	R21
                 
                 .EQU PWM_AZIMUT_DEFAULT				=	190		;{0,255} PARA SETEAR EL PWM
                 .EQU PWM_ELEVATION_DEFAULT			=	190		;{0,255} PARA SETEAR EL PWM
                 										;200 ES 10V APROX.
                 
                 ;.DEF MOTOR_AZIMUT					=	OCR0A
                 ;.DEF MOTOR_ELEVATION				=	OCR0B
                 
                 .EQU LIGHT							=	OCR2B
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DE MOTORES------------------------------------
                 
                 .EQU MOT_1							=	PD5
                 .EQU MOT_2							=	PD6
                 
                 ;-----------------------------------------------------------------------------------
                 .include "avr_macros.inc"	;Incluye los macros
                 
                 ; coleccin de macros para microcontroladores AVR
                 ;------------------------------------------------------------------
                 ; Sintaxis:
                 ; 	.macro NOMBRE_MACRO
                 ; 		; cuerpo de la macro
                 ;		; los parmetros de la macro se referencian como
                 ;		; @0 (1er parmetro), @1 (2do parmetro), etc.
                 ; 	.endm
                 ;------------------------------------------------------------------
                 
                 ;------------------------------------------------------------------
                 ; input: resuelve si usa "in"/"lds" segn la direccin del registro
                 ;        de E/S que se lee.
                 ;------------------------------------------------------------------
                 .macro	input ; @0= destino {r0, ... , r31}
                               ; @1= fuente I/0 ($0000-$FFFF)
                 .if	@1<0x40
                 	in	@0,@1	; si dir del reg de E/S <0x40 uso "in"
                 .else
                 	lds	@0,@1	; sino uso "lds"
                 .endif
                 .endm
                 
                 ;------------------------------------------------------------------
                 ; output: resuelve si usa "out"/"sts" segn la direccin del registro
                 ;         de E/S que se escribe.
                 ;------------------------------------------------------------------
                 .macro	output		; @0= destino I/O ($0000-$FFFF)
                 			; @1= fuente, cte o r0..r31
                 .if	@0<0x40
                 		out	@0,@1	; si dir del reg de E/S <0x40 uso "out"
                 .else
                 		sts	@0,@1	; sino uso "sts"
                 .endif
                 .endm
                 
                 .macro	ldiw		; carga puntero
                 		ldi	@0L, LOW(@1)
                 		ldi	@0H, HIGH(@1)
                 .endm
                 
                 .macro	movi	; carga registro con constante
                 		ldi	AUX,@1
                 		mov	@0,AUX
                 .endm
                 
                 .macro	outi
                 		ldi		AUX,@1
                 		output	@0,AUX  ;FIGURABA R16!!!!! OJO!
                 .endm
                 
                 
                 .macro	pushw	;@0		; Pone el puntero @0 de 16 bits en la pila
                 		push	@0L
                 		push	@0H
                 .endm
                 
                 
                 .macro	popw	;@0		; Saca el puntero @0 de 16 bits de la pila
                 		pop		@0H
                 		pop		@0L
                 .endm
                 
                 
                 .macro	pushi	;@0			; Pone en pila un registro de I/O
                 			in		AUX,@0	; usa la variable auxiliar t0
                 			push	AUX
                 .endm
                 
                 
                 .macro	popi	;@0			; Saca de pila un registro de I/O
                 			pop		AUX		; usa la variable auxiliar t0
                 			out		@0,AUX
                 .endm
                 
                 .macro	sti		;@0,@1	; Guarda una constante de modo indirecto
                 		ldi		AUX4,@1	; Usa: variable auxiliar "t0" y un puntero
                 		st		@0,AUX4	; [3 ciclos, 2 words] @0={X, Y, Z}
                 .endm
                 
                 .macro	stsi	;@0,@1	; Guarda una constante en SRAM
                 		ldi		AUX,@1	; Usa: variable auxiliar "t0".
                 		sts		@0,AUX	; [3 ciclos, 2 words] @0={any SRAM ADDRESS}
                 .endm
                 
                 ;---------------------MACROS PROPIAS-----------------------------------------------
                 .macro SLDR
                 ;STORE_LDR
                 ;PROTOTYPE: SLDR LDR_XX_LOW,LDR_XX_HIGH,ADC_DATA_H
                 ;RECIBE: ADC_DATA_H EL VALOR DEL LDR
                 ;DEVUELVE: -
                 	MOV	ZL,@0
                 	MOV	ZH,@1	
                 	ST	Z+,@2
                 	MOV	@0,ZL
                 	MOV	@1,ZH
                 .endm
                 
                 .macro LLDR
                 ;LOAD_LDR_TO_POINTER
                 ;PROTOTYPE: LLDR Z,LDR_XX_LOW,LDR_XX_HIGH
                 	LDI @0L,@1
                 	LDI @0H,@2
                 .endm
                 
                 .macro VECTMEAN	;@0,@1,@2	;Calcula la media de un vector @0 de longitud @1 y guarda la media en @2
                 		PUSH		@1
                 		LD 		AUX3,@0+
                 		CLR		@2
                 		DEC		@1
                 		CLR		AUX2
                 loop_mean:
                 		CLV
                 		LD		AUX4,@0+
                 		ADD		AUX3,AUX4
                 		ADC		@2,AUX2
                 		DEC		@1
                 		BRNE		loop_mean
                 		LDI		AUX2,3
                 division:
                 		LSR		@2
                 		ROR		AUX3
                 		DEC		AUX2
                 		BRNE		division
                 		MOV		@2,AUX3
                 		POP		@1
                 .endm
                 
                 
                 .macro SPWM 
                 ;PROTOTYPE SET_PWM: SPWM OCRnx,PWM_DATA
                 ;RECIBE: OCRnx,PWM_DATA
                 ;DEVUELVE: .
                 	OUTPUT @0,@1
                 .endm
                 
                 .macro RPWM 
                 ;PROTOTYPE RESET_PWM: RPWM OCRnx
                 ;RECIBE: OCRnx
                 ;DEVUELVE: -
                 	CLR AUX
                 	OUTPUT @0,AUX
                 .endm
                 
                 .macro ADDI
                 ;PROTOTYPE ADDI: REG,CTE
                 ;RECIBE: REG,CTE
                 ;DEVUELVE: Suma de cte al registro
                 	LDI AUX4,@1
                 	ADD @0,AUX4
                 .endm
                 
                 .macro ADDP
                 ;PROTOTYPE ADDP: POINTER,REG
                 ;RECIBE: POINTER,REG
                 ;DEVUELVE: Pointer en posicin inicial + AUX
                 	ADD @0L,@1
                 	BRVC NO_POINTER_OV
                 	INC @0H
                 	SUB @1,@0L
                 	MOV @1,@0L
                 NO_POINTER_OV: NOP
                 .endm
                 .listmac					;Permite que se expandan las macros en el listado
                 
                 .CSEG
                 .ORG 0x0000
000000 c019      RJMP SETUP	
                 
                 .ORG	INT0addr
000001 c055      RJMP	ISR_INT0
                 
                 .ORG	URXCaddr		; USART, Rx Complete
000012 c0d0      RJMP	ISR_RX_USART_COMPLETA
                 	
                 .ORG	UDREaddr		; USART Data Register Empty
000013 c0fe      RJMP	ISR_REG_USART_VACIO
                 
                 .ORG	OVF1addr
00000d c04a      RJMP	ISR_TIMER_1_OV
                 
                 ;-------------------------------SETUP--------------------------------------------
                 .ORG	INT_VECTORS_SIZE
                 SETUP:
00001a ef0f      	LDI AUX,LOW(RAMEND)
00001b bf0d      	OUT SPL,AUX
00001c e004      	LDI	AUX,HIGH(RAMEND)
00001d bf0e      	OUT SPH,AUX
                 
00001e d0ef      	RCALL BT_DISCONNECT		;[FLAG=0xFF]: ESTA CONECTADO A BT. [FLAG=0x00]: NO ESTA CONECTADO A BT.
                 	;RCALL INT_EXT_INIT
00001f d186      	RCALL BATTERY_INIT
000020 d1f9      	RCALL SOLAR_PANEL_INIT
000021 d05f      	RCALL ADC_INIT			;TIENE QUE ESTAR EN "ADC.inc"
                 
000022 d2c5      	RCALL LDRS_INIT
000023 d09b      	RCALL SERIAL_PORT_INIT	;TIENE QUE ESTAR EN "SERIAL_PORT.inc"
000024 d38c      	RCALL MOTORS_INIT
000025 9478      	SEI
                 
000026 c001      RJMP MAIN
                 
000027 d176      	RCALL LIGHT_TURN_OFF	;TIENE QUE ESTAR EN "LIGHT.inc"
                 
                 ;--------------------------------------------------------------------------------
                 /*PRUEBA:
                 	;	RCALL	READ_V_BATTERY					;MIDO LA BATERIA
                 		LDI		ADC_DATA_H,212					;230 ES 13.5V. 34 ES 2V. 
                 
                 
                 	;	rcall indicate_solar_panel_low
                 ;		rcall delay_500ms
                 
                 	;	LDIW	X,V_BATTERY_DATA
                 ;		ST		X,ADC_DATA_H
                 
                 
                 
                 		RCALL	DELAY_50ms 
                 		RCALL	DELAY_50ms 
                 
                 RJMP PRUEBA
                 	RCALL	SERIAL_PORT_INIT
                 		RCALL DELAY_100us
                 	
                 		RCALL	INDICATE_SOLAR_PANEL_LOW
                 	;	RCALL	DELAY_500ms
                 
                 
                 
                 		LDIW	Z,(MSJ_V_LDRS*2)
                 		LDIW	Y,LDR_NO_MEAN
                 		RCALL	TRANSMITIR_TENSION
                 		RCALL DELAY_50ms
                 
                 		RCALL PWM_INIT							;TIENE QUE ESTAR EN "PWM.inc"
                 		RCALL	ORIENTATE_SOLAR_PANEL
                 
                 		RJMP SLEEP_MODE
                 	
                 RJMP PRUEBA
                 */
                 ;-------------------------------PROGRAMA_PRINCIPAL-------------------------------
                 MAIN:	
                 	;RCALL	SERIAL_PORT_INIT
                 	;MIDO LA BATERIA
000028 d195      		RCALL	READ_V_BATTERY					
000029 d1ab      		RCALL	VBATTERY_TO_ASCII
00002a d197      		RCALL	CHECK_IF_BATTERY_MINIMUM		;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
00002b f0f8      		BRCS	SLEEP_MODE
00002c d1a2      		RCALL	INDICATE_BATTERY_OK
                 
                +
00002d ece8     +ldi ZL , LOW ( ( MSJ_V_BAT * 2 ) )
00002e e0f8     +ldi ZH , HIGH ( ( MSJ_V_BAT * 2 ) )
                 		LDIW	Z,(MSJ_V_BAT*2)
                +
00002f e4c0     +ldi YL , LOW ( V_BATTERY_DATA )
000030 e0d1     +ldi YH , HIGH ( V_BATTERY_DATA )
                 		LDIW	Y,V_BATTERY_DATA
000031 d11e      		RCALL	TRANSMITIR_TENSION	
000032 d14d      		RCALL	DELAY_50ms
                 
                 	;DIA O NOCHE?
000033 d1fe      		RCALL	READ_V_SOLAR_PANEL				;PARA VER SI ES DE DIA O NOCHE, MIDO LA TENSION DEL PANEL SOLAR.
000034 d271      		RCALL	VPANEL_TO_ASCII
000035 d200      		RCALL	CHECK_IF_SOLAR_PANEL_MINIMUM	;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
000036 f150      		BRCS	AT_NIGHT
                 		;RCALL	LIGHT_TURN_OFF
000037 d20b      		RCALL	INDICATE_SOLAR_PANEL_OK
                 
                +
000038 eee6     +ldi ZL , LOW ( ( MSJ_V_PANEL * 2 ) )
000039 e0f8     +ldi ZH , HIGH ( ( MSJ_V_PANEL * 2 ) )
                 		LDIW	Z,(MSJ_V_PANEL*2)
                +
00003a e4c8     +ldi YL , LOW ( V_SOLAR_PANEL_DATA )
00003b e0d1     +ldi YH , HIGH ( V_SOLAR_PANEL_DATA )
                 		LDIW	Y,V_SOLAR_PANEL_DATA
00003c d113      		RCALL	TRANSMITIR_TENSION	
00003d d142      		RCALL	DELAY_50ms
                 
                 ;SI ESTOY ACA YA TENGO BATERIA SUFICIENTE, ES DE DIA.
                 ;PRENDER EL TIMER, LA INTERRUPCION DEL ADC MANDAR A SLEEP.
                 
00003e d2e4      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
00003f d139      		RCALL	DELAY_100us
000040 d2e2      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
000041 d137      		RCALL	DELAY_100us
000042 d136      		RCALL	DELAY_100us
000043 d2df      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
000044 d134      		RCALL	DELAY_100us
000045 d2dd      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
000046 d132      		RCALL	DELAY_100us
000047 d2db      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
                 	
000048 d2fe      		RCALL	LDRS_MEAN
                 	
000049 d059      		RCALL PWM_INIT							;TIENE QUE ESTAR EN "PWM.inc"
00004a d1fe      		RCALL	ORIENTATE_SOLAR_PANEL			;HAY QUE RESOLVER ESTO TODAVIA.
                 
                 
                 ;HAY QUE HACER COSAS ANTES DE IR A SLEEP, COMO APAGAR EL ADC Y NO SE QUE MAS [COMO EL PWM DE LOS MOTORES]
                 SLEEP_MODE:
                 	/*	RCALL INDICATE_BATTERY_LOW}
                 		RCALL DELAY_50ms
                 		RCALL DELAY_50ms
                 		RCALL INDICATE_BATTERY_OK
                 		RCALL DELAY_50ms
                 		RCALL DELAY_50ms
                 		RCALL INDICATE_SOLAR_PANEL_LOW
                 		RCALL DELAY_50ms
                 		RCALL DELAY_50ms
                 		RCALL INDICATE_SOLAR_PANEL_OK
                 		RCALL DELAY_50ms
                 		RCALL DELAY_50ms
                 		*/
00004b d025      		RCALL SLEEP_TIMER_INIT
                +
                +
                +.if SMCR < 0x40
00004c b703     +in AUX , SMCR
                +.else 
                +lds AUX , SMCR
                 		INPUT AUX,SMCR
00004d 7f00      		ANDI AUX,((~((1<<SM2)|(1<<SM1)|(1<<SM0)|(1<<SE))))
00004e 6001      		ORI AUX,((0<<SM2)|(0<<SM1)|(0<<SM0)|(1<<SE))	;SETEO EL MODO IDLE.
                +
                +
                +.if SMCR < 0x40
00004f bf03     +out SMCR , AUX
                +.else 
                +sts SMCR , AUX
                 		OUTPUT SMCR,AUX
000050 9588      		SLEEP
000051 0000      		NOP
                +
                +
                +.if SMCR < 0x40
000052 b703     +in AUX , SMCR
                +.else 
                +lds AUX , SMCR
                 		INPUT AUX,SMCR
000053 7f0e      		ANDI AUX,(~(1<<SE))								;CUANDO SALGO DE SLEEP, PONGO SE=0.
000054 6000      		ORI AUX,(0<<SE)
                +
                +
                +.if SMCR < 0x40
000055 bf03     +out SMCR , AUX
                +.else 
                +sts SMCR , AUX
                 		OUTPUT SMCR,AUX
000056 cfd1      		RJMP MAIN
                 ;RJMP PRUEBA
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------MAIN_FUNCTIONS---------------------------------------
                 ISR_INT0:
000057 9518      RETI
                 
                 ISR_TIMER_1_OV:
000058 9518      RETI
                 
                 NO_SOLAR_PANEL_CONNECTED:
                +
                +
                +.if BT_FLAG < 0x40
                +in AUX , BT_FLAG
000059 9100 0179+.else 
                +lds AUX , BT_FLAG
                 	INPUT AUX,BT_FLAG
00005b 2300      	TST AUX
00005c f771      	BRNE SLEEP_MODE			;SI NO HAY CONEXION BT, NO MANDA NADA
                +
00005d e2e2     +ldi ZL , LOW ( ( MSJ_DISCONNECTED_PANEL * 2 ) )
00005e e0f9     +ldi ZH , HIGH ( ( MSJ_DISCONNECTED_PANEL * 2 ) )
                 	LDIW	Z,(MSJ_DISCONNECTED_PANEL*2)
00005f d0d3      	RCALL TRANSMITIR_MENSAJE
000060 cfea      	RJMP SLEEP_MODE
                 
                 AT_NIGHT:
                 ;	RCALL LIGHT_TURN_ON
000061 d1dc      	RCALL INDICATE_SOLAR_PANEL_LOW
000062 cfe8      	RJMP SLEEP_MODE
                 
                 INT_EXT_INIT:
                 		;SETEO EL PIN INT0 (PD2) COMO ENTRADA.
                +
                +
                +.if DDRD < 0x40
000063 b10a     +in AUX , DDRD
                +.else 
                +lds AUX , DDRD
                 		INPUT	AUX,DDRD
000064 7f0b      		ANDI	AUX,(~(1<<PD2))
                +
                +
                +.if DDRD < 0x40
000065 b90a     +out DDRD , AUX
                +.else 
                +sts DDRD , AUX
                 		OUTPUT	DDRD,AUX
                 
                 		;SETEO PARA QUE SALTE LA INT0 SI HAY CUALQUIER CAMBIO.
                +
                +
                +.if EICRA < 0x40
                +in AUX , EICRA
000066 9100 0069+.else 
                +lds AUX , EICRA
                 		INPUT	AUX,EICRA
000068 7f0c      		ANDI	AUX,(~((1<<ISC00)|(1<<ISC01)))
000069 6001      		ORI		AUX,((1<<ISC00)|(0<<ISC01))		
                +
                +
                +.if EICRA < 0x40
                +out EICRA , AUX
00006a 9300 0069+.else 
                +sts EICRA , AUX
                 		OUTPUT	EICRA,AUX
                 	
                 		;HABILITO LA INTERRUPCION INT0.
                +
                +
                +.if EIMSK < 0x40
00006c b30d     +in AUX , EIMSK
                +.else 
                +lds AUX , EIMSK
                 		INPUT	AUX,EIMSK
00006d 7f0c      		ANDI	AUX,~((1<<INT0)|(1<<INT1))		
00006e 6001      		ORI		AUX,((1<<INT0)|(0<<INT1))
                +
                +
                +.if EIMSK < 0x40
00006f bb0d     +out EIMSK , AUX
                +.else 
                +sts EIMSK , AUX
                 		OUTPUT	EIMSK,AUX
000070 9508      RET
                 
                 SLEEP_TIMER_INIT:
000071 ee0e      			LDI	AUX,0xEE		;Pongo como valor inicial del timer 34286 para que cuando haga overflow haya contado (8E6)/256
                +
                +
                +.if TCNT1L < 0x40
                +out TCNT1L , AUX
000072 9300 0084+.else 
                +sts TCNT1L , AUX
                 			OUTPUT TCNT1L,AUX
000074 e805      			LDI AUX,0x85
                +
                +
                +.if TCNT1H < 0x40
                +out TCNT1H , AUX
000075 9300 0085+.else 
                +sts TCNT1H , AUX
                 			OUTPUT TCNT1H,AUX
000077 e004      			LDI AUX,(1<<CS12)|(0<<CS11)|(0<<CS10)		;Seteo el prescaler a 256
                +
                +
                +.if TCCR1B < 0x40
                +out TCCR1B , AUX
000078 9300 0081+.else 
                +sts TCCR1B , AUX
                 			OUTPUT TCCR1B,AUX
00007a e000      			LDI AUX,0
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , AUX
00007b 9300 0080+.else 
                +sts TCCR1A , AUX
                 			OUTPUT TCCR1A,AUX
00007d e001      			LDI AUX,(1<<TOIE1)
                +
                +
                +.if TIMSK1 < 0x40
                +out TIMSK1 , AUX
00007e 9300 006f+.else 
                +sts TIMSK1 , AUX
                 			OUTPUT TIMSK1,AUX
000080 9508      RET
                 
                 .include "ADC.inc"
                 
                  * PRUEBA_ADC.asm
                  *
                  *  Created: 25/05/2016 04:10:33 a.m.
                  *   Author: MAU
                  *
                  *	ESTE PROGRAMA RECIBE POR ADC0 UN LDR Y MANDA POR LOS 4 LEDS
                  *	DE LA PLACA DEL CdR EL DATO.
                  *
                  */ 
                 
                 ; codigo
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 /*ISR_ADC_CONVERSION_COMPLETE:
                 		
                 		INPUT AUX,ADCSRA
                 		SBR AUX,ADIF
                 		OUTPUT ADCSRA,AUX
                 
                 		LDI AUX,PD7
                 		OUTPUT PORTD,AUX
                 	RETI
                 */
                 ;-------------------------------------------------------------------------
                 ;					CONVERSOR ANALOGICO-DIGITAL
                 ;-------------------------------------------------------------------------
                 
                 ADC_INIT:
                 ;ADMUX = REFS1 REFS0 ADLAR  MUX3 MUX2 MUX1 MUX0
                 ;INTERNAL VREF=VCC Y EL DATO AJUSTADO A IZQUIERDA! [ADCH:ADCL]. SE SELECCIONA POR DEFECTO EL CANAL ADC1 [LDR DE LA PLACA DE CdR MODIF]
000081 e634      	LDI ADC_DATA_L,((0<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0<<MUX3)|(1<<MUX2)|(0<<MUX1)|(0<<MUX0))
                +
                +
                +.if ADMUX < 0x40
                +out ADMUX , ADC_DATA_L
000082 9330 007c+.else 
                +sts ADMUX , ADC_DATA_L
                 	OUTPUT ADMUX,ADC_DATA_L
                 ;ADCSRA = ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0		
                 ;SE HABILITA EL ADC, AUTO TRIGGER OFF, FLAG INTERRUPCION EN CERO, PRESCALER DIV POR 64 [trabaja en aprox 100Khz]
000084 e836      	LDI ADC_DATA_L,((1<<ADEN)|(0<<ADSC)|(0<<ADATE)|(0<<ADIF)|(0<<ADIE)|(1<<ADPS2)|(1<<ADPS1)|(0<<ADPS0))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , ADC_DATA_L
000085 9330 007a+.else 
                +sts ADCSRA , ADC_DATA_L
                 	OUTPUT ADCSRA,ADC_DATA_L
                 
                 ;SETEAR ESTE REGISTRO PARA EL MODO DE AUTO TRIGGER
                 ;	LDI AUX,(0<<ADTS2)|(0<<ADTS1)|(0<<ADTS0)
                 ;	OUTPUT ADCSRB,AUX
                 
                 ;SE DESHABILITA LA PARTE DIGITAL INTERNA DEL PIN A UTILIZAR
                 ;HABILITO SOLO LOS LDRS
000087 e33c      	LDI ADC_DATA_L,((1<<ADC2D)|(1<<ADC3D)|(1<<ADC4D)|(1<<ADC5D))
                +
                +
                +.if DIDR0 < 0x40
                +out DIDR0 , ADC_DATA_L
000088 9330 007e+.else 
                +sts DIDR0 , ADC_DATA_L
                 	OUTPUT DIDR0,ADC_DATA_L
00008a 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ADC_SELECT_INPUT:
                 ;ADMUX = REFS1 REFS0 ADLAR  MUX3 MUX2 MUX1 MUX0
                 ;RECIBE: EL VALOR DEL PIN A SELECCIONAR EN ADC_DATA_L
                 ;DEVUELVE: NADA
                +
                +
                +.if ADMUX < 0x40
                +in AUX , ADMUX
00008b 9100 007c+.else 
                +lds AUX , ADMUX
                 	INPUT AUX,ADMUX
00008d 7f00      	ANDI AUX,(~((1<<MUX3)|(1<<MUX2)|(1<<MUX1)|(1<<MUX0)))
00008e 2b03      	OR AUX,ADC_DATA_L;NO HAY QUE HACER SHIFT
                +
                +
                +.if ADMUX < 0x40
                +out ADMUX , AUX
00008f 9300 007c+.else 
                +sts ADMUX , AUX
                 	OUTPUT ADMUX,AUX
                 
000091 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ADC_SIMPLE_CONVERSION:
                 ;RECIBE: -
                 ;DEVUELVE: RESULTADO DE LA CONVERSION EN ADC_DATA_H:ADC_DATA_L
                 
                +
                +
                +.if ADCSRA < 0x40
                +in AUX , ADCSRA
000092 9100 007a+.else 
                +lds AUX , ADCSRA
                 	INPUT AUX,ADCSRA
000094 6c00      	ORI AUX,((1<<ADEN)|(1<<ADSC))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , AUX
000095 9300 007a+.else 
                +sts ADCSRA , AUX
                 	OUTPUT ADCSRA,AUX
                +
                +
                +.if ADCSRA < 0x40
                +in AUX , ADCSRA
000097 9100 007a+.else 
                +lds AUX , ADCSRA
                 L2:	INPUT AUX,ADCSRA
000099 fd06      	SBRC AUX,ADSC
00009a cffc      	RJMP L2
00009b 770f      	ANDI AUX,(~(1<<ADEN))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , AUX
00009c 9300 007a+.else 
                +sts ADCSRA , AUX
                 	OUTPUT ADCSRA,AUX
                 
                +
                +
                +.if ADCL < 0x40
                +in ADC_DATA_L , ADCL
00009e 9130 0078+.else 
                +lds ADC_DATA_L , ADCL
                 	INPUT ADC_DATA_L,ADCL
                +
                +
                +.if ADCH < 0x40
                +in ADC_DATA_H , ADCH
0000a0 9140 0079+.else 
                +lds ADC_DATA_H , ADCH
                 	INPUT ADC_DATA_H,ADCH
                 
0000a2 9508      RET
                 
                 /************************** EJEMPLO! ***********************************
                 EJEMPLO_CONVERSOR:
                 		INPUT AUX,ADCSRA
                 		ORI AUX,((1<<ADEN)|(1<<ADSC))
                 		OUTPUT ADCSRA,AUX
                 
                 ESPERO:	INPUT AUX,ADCSRA
                 		SBRC AUX,ADSC
                 		RJMP ESPERO
                 		ANDI AUX,(~(1<<ADEN))
                 		OUTPUT ADCSRA,AUX
                 ;SE INICIA LA CONVERSION [ADEN=1]Y SE ESPERA A QUE TERMINE [ADSC=1] ?? O ADIF ???
                 		INPUT AUX,ADCH
                 		CPI AUX,0x00		
                 		BREQ LED1
                 		CPI AUX,0x01		
                 		BREQ LED2
                 		CPI AUX,0x02		
                 		BREQ LED3
                 		CPI AUX,0x03		
                 		BREQ LED4	
                 
                 SIGO:	RCALL DELAY
                 		RJMP EJEMPLO_CONVERSOR
                 
                 .include "PWM.inc"
                 
                 ;* 	CODIGO PWM 
                 ;*
                 ;*  Created: 29/05/2016
                 ;*  Autor: Mauro Giordano, Agustin Picard, Joaqun Ulloa
                 ;*	
                 ;*	f_outPWM = f_clkIO / (prescaler * 256)
                 ;*	Configuracion Fast Pwm
                 ;*	
                 ;*****************************************************
                 .CSEG
                 PWM_INIT:
                 ;	RCALL PWM_INIT_0
0000a3 d001      	RCALL PWM_INIT_1
                 ;	RCALL PWM_INIT_2
                 ;COMENTO LA FUNCION ANTERIOR PORQUE VAMOS A USAR MOTORES DE CONTINUA PUESTOS EN OC1A Y OC1B QUE SON LOS DEL PUERTO B SOLAMENTE.
0000a4 9508      RET
                 
                 /*PWM_INIT_0:
                 ;Se inicializan como salida los pines de PWM
                 	INPUT PWM_DATA,DDRD
                 	ANDI PWM_DATA,(~((1<<DDD5)|(1<<DDD6)))	;Mascara para tocar solo D5 Y D6
                 	ORI PWM_DATA,((1<<DDD5)|(1<<DDD6))
                 	OUTPUT DDRD,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM02=0 (por defecto), WGM01=1 y WGM00=1
                 	;Non-inverting mode: COM0A1=1 y COM0A0=0
                 	INPUT PWM_DATA,TCCR0A	;Timer/counter control register A
                 	ANDI PWM_DATA,(~((1<<WGM01)|(1<<WGM00)|(1<<COM0A1)|(1<<COM0A0)|(1<<COM0B1)|(1<<COM0B0)))
                 	ORI PWM_DATA,((1<<WGM01)|(1<<WGM00)|(1<<COM0A1)|(0<<COM0A0)|(1<<COM0B1)|(0<<COM0B0))	;fast PWM, non-inverting
                 	OUTPUT TCCR0A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                 	INPUT PWM_DATA,TCCR0B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
                 	ANDI PWM_DATA,(~((1<<CS00)|(1<<CS01)|(1<<CS02)))
                 	ORI PWM_DATA,((0<<CS00)|(1<<CS01)|(0<<CS02))	;Ver tabla prescalers al final del archivo
                 	OUTPUT TCCR0B,PWM_DATA
                 ;Se inicializa el pwm en cero
                 	CLR	AUX
                 	OUTPUT	OCR0A,AUX
                 	OUTPUT	OCR0B,AUX
                 RET
                 */
                 ;*****************************************************
                 
                 PWM_INIT_1:
                 ;Se inicializan como salida los pines de PWM
                +
                +
                +.if DDRB < 0x40
0000a5 b154     +in PWM_DATA , DDRB
                +.else 
                +lds PWM_DATA , DDRB
                 	INPUT PWM_DATA,DDRB
0000a6 7f59      	ANDI PWM_DATA,(~((1<<DDB1)|(1<<DDB2)))	;Mascara para tocar solo B1 Y B2
0000a7 6056      	ORI PWM_DATA,((1<<DDB1)|(1<<DDB2))
                +
                +
                +.if DDRB < 0x40
0000a8 b954     +out DDRB , PWM_DATA
                +.else 
                +sts DDRB , PWM_DATA
                 	OUTPUT DDRB,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM02=0 (por defecto), WGM01=1 y WGM00=1
                 	;Non-inverting mode: COM0A1=1 y COM0A0=0
                 	;Descripcion de registros en seccion 15.9 (pag 106-112)
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
0000a9 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
0000ab 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
0000ac 6f51      	ORI PWM_DATA,((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
0000ad 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                +
                +
                +.if TCCR1B < 0x40
                +in PWM_DATA , TCCR1B
0000af 9150 0081+.else 
                +lds PWM_DATA , TCCR1B
                 	INPUT PWM_DATA,TCCR1B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
0000b1 7e50      	ANDI PWM_DATA,(~((1<<WGM13)|(1<<WGM12)|(1<<CS10)|(1<<CS11)|(1<<CS12)))
0000b2 605a      	ORI PWM_DATA,((0<<WGM13)|(1<<WGM12)|(0<<CS10)|(1<<CS11)|(0<<CS12))	;Prescaler = 8
                +
                +
                +.if TCCR1B < 0x40
                +out TCCR1B , PWM_DATA
0000b3 9350 0081+.else 
                +sts TCCR1B , PWM_DATA
                 	OUTPUT TCCR1B,PWM_DATA
                 
0000b5 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
0000b6 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
0000b8 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                +
                +
                +.if OCR1AH < 0x40
                +out OCR1AH , AUX
0000ba 9300 0089+.else 
                +sts OCR1AH , AUX
                 	OUTPUT	OCR1AH,AUX
                +
                +
                +.if OCR1BH < 0x40
                +out OCR1BH , AUX
0000bc 9300 008b+.else 
                +sts OCR1BH , AUX
                 	OUTPUT	OCR1BH,AUX
0000be 9508      RET
                 
                 ;*****************************************************
                 /*PWM_INIT_2:
                 ;Se inicializan como salida los pines de PWM
                 ;Se usa uno solo de los pines (para la luz), el otro es el MOSI, lo dejamos solo para programar
                 	INPUT PWM_DATA,DDRD
                 	ANDI PWM_DATA,(~(1<<DDD3))	;Mascara para tocar solo D3
                 	ORI PWM_DATA,((1<<DDD3))
                 	OUTPUT DDRD,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM22=0 (por defecto), WGM21=1 y WGM20=1
                 	;Non-inverting mode: COM2A1=1 y COM2A0=0
                 	INPUT PWM_DATA,TCCR2A	;Timer/counter control register A
                 	ANDI PWM_DATA,(~((1<<COM2B1)|(1<<COM2B0)|(1<<WGM20)|(1<<WGM21)))
                 	ORI PWM_DATA,((1<<COM2B1)|(0<<COM2B0)|(1<<WGM20)|(1<<WGM21))	;fast PWM, non-inverting
                 	OUTPUT TCCR2A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                 	INPUT PWM_DATA,TCCR2B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
                 	ANDI PWM_DATA,(~((1<<CS20)|(1<<CS21)|(1<<CS22)))
                 	ORI PWM_DATA,((0<<CS20)|(1<<CS21)|(0<<CS22))	;Ver tabla prescalers al final del archivo
                 	OUTPUT TCCR2B,PWM_DATA
                 RET
                 */
                 
                 
                 ;*****************************************************
                 
                 /*
                 ;PWM DE 16 BITS, RECIBE EL VALOR POR PWM_DATA_L Y PWM_DATA_L_H
                 PWM_MOTOR_ELEVACION_SET:	;EL DE ELEVACION ES PD5 [MOT_1]
                 	OUTPUT OCR1BL,PWM_DATA
                 	OUTPUT OCR1BH,PWM_DATA_H	
                 RET
                 
                 PWM_MOTOR_ELEVACION_RESET:	;EL DE ELEVACION ES PD6 [MOT_2]
                 	CLR PWM_DATA
                 	OUTPUT OCR1BL,PWM_DATA	
                 	OUTPUT OCR1BH,PWM_DATA_H	
                 RET
                 */
                 
                 ;*****************************************************
                 /*
                 CS22	CS21	CS20	Description
                 0 		0 		0 		No clock source (timer/counter stopped)
                 0 		0 		1 		clkT2S/(no prescaling)
                 0 		1 		0 		clkT2S/8 (from prescaler)
                 0 		1 		1 		clkT2S/32 (from prescaler)
                 1 		0 		0 		clkT2S/64 (from prescaler)
                 1 		0 		1 		clkT2S/128 (from prescaler)
                 1 		1 		0 		clkT2S/256 (from prescaler)
                 1 		1 		1 		clkT2S/1024 (from prescaler)
                 */
                 .include "SERIAL_PORT.inc"
                 
                  * PRUEBA_PUERTO_SERIE.asm
                  *
                  *  Created: 18/05/2016 07:33:17 p.m.
                  *   Author: MAU
                  */ 
                 
                 
                 ;-------------------------------------------------------------------------
                 ; codigo
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 SERIAL_PORT_INIT:
0000bf 930f      		PUSH	AUX
0000c0 931f      		PUSH	AUX1
                +
0000c1 93af     +push XL
0000c2 93bf     +push XH
                 		PUSHW	X
                 	
0000c3 e000      		LDI		AUX,HIGH(BAUD_RATE)
                +
                +
                +.if UBRR0H < 0x40
                +out UBRR0H , AUX
0000c4 9300 00c5+.else 
                +sts UBRR0H , AUX
                 		OUTPUT		UBRR0H,AUX	; Velocidad de transmisin
0000c6 e607      		LDI		AUX,LOW(BAUD_RATE)
                +
                +
                +.if UBRR0L < 0x40
                +out UBRR0L , AUX
0000c7 9300 00c4+.else 
                +sts UBRR0L , AUX
                 		OUTPUT		UBRR0L,AUX	
                 		
0000c9 e002      		LDI		AUX,1<<U2X0		; Modo asinc., doble velocidad
                +
                +
                +.if UCSR0A < 0x40
                +out UCSR0A , AUX
0000ca 9300 00c0+.else 
                +sts UCSR0A , AUX
                 		OUTPUT		UCSR0A,AUX	
                 
                 		; Trama: 8 bits de datos, sin paridad y 1 bit de stop, 
0000cc e006      		LDI		AUX,(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(1<<UCSZ01)|(1<<UCSZ00)
                +
                +
                +.if UCSR0C < 0x40
                +out UCSR0C , AUX
0000cd 9300 00c2+.else 
                +sts UCSR0C , AUX
                 		OUTPUT		UCSR0C,AUX
                 
                 
                 		; Configura los terminales de TX y RX; y habilita
                 		; 	nicamente la int. de recepcin
0000cf e908      		LDI		AUX,(1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0)|(0<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
0000d0 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT		UCSR0B,AUX
                 
                +
0000d2 e000     +ldi AUX , LOW ( TX_BUF )
0000d3 2e80     +mov PTR_TX_L , AUX
                 		MOVI	PTR_TX_L,LOW(TX_BUF)	; inicializa puntero al 
                +
0000d4 e001     +ldi AUX , HIGH ( TX_BUF )
0000d5 2e90     +mov PTR_TX_H , AUX
                 		MOVI	PTR_TX_H,HIGH(TX_BUF)	; buffer de transmisin.
                 	
                +
0000d6 e0a0     +ldi XL , LOW ( TX_BUF )
0000d7 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF				; limpia BUF_SIZE posiciones 
0000d8 e410      		LDI		AUX1, BUF_SIZE			; del buffer de transmisin
0000d9 2700      		CLR		AUX
                 loop_limpia:
0000da 930d      		ST		X+,AUX
0000db 951a      		DEC		AUX1
0000dc f7e9      		BRNE	loop_limpia
                 					
0000dd 24aa      		CLR		BYTES_A_TX		; nada pendiente de transmisin
                 
                +
0000de 91bf     +pop XH
0000df 91af     +pop XL
                 		POPW	X
0000e0 911f      		POP		AUX1
0000e1 910f      		POP		AUX
0000e2 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ; RECEPCION: Interrumpe cada vez que se recibe un byte x RS232.
                 ;
                 ; Recibe:	UDR (byte de dato)
                 ; Devuelve: nada
                 ;-------------------------------------------------------------------------
                 ISR_RX_USART_COMPLETA:
                 
                 ;		SER AUX
                 ;		OUTPUT BT_FLAG,AUX	;[FLAG=0xFF]: ESTA CONECTADO A BT. 
                 							;[FLAG=0x00]: NO ESTA CONECTADO A BT.
                +
                +
                +.if UDR0 < 0x40
                +in AUX , UDR0
0000e3 9100 00c6+.else 
                +lds AUX , UDR0
                 		INPUT AUX,UDR0
                 
0000e5 3701      		CPI AUX,BT_COMMAND_PROJECT_NAME
0000e6 f0d9      		BREQ CALL_V_LDRS;CALL_PROJECT_NAME
                 
0000e7 3302      		CPI AUX,BT_COMMAND_V_BAT
0000e8 f069      		BREQ CALL_V_BAT
                 
0000e9 3303      		CPI AUX,BT_COMMAND_V_PANEL
0000ea f089      		BREQ CALL_V_PANEL
                 
0000eb 3304      		CPI AUX,BT_COMMAND_LIGHT_TURN_ON
0000ec f0d9      		BREQ _LIGHT_TURN_ON
                 
0000ed 3305      		CPI AUX,BT_COMMAND_LIGHT_TURN_OFF
0000ee f0d9      		BREQ _LIGHT_TURN_OFF
                 
0000ef 3306      		CPI AUX,BT_COMMAND_DISCONNECT
0000f0 f0d9      		BREQ _BT_DISCONNECT
                 
0000f1 9518      SIGO:  	RETI 
                 
                 CALL_PROJECT_NAME:
                +
0000f2 eae4     +ldi ZL , LOW ( ( MSJ_PROJECT_NAME * 2 ) )
0000f3 e0f8     +ldi ZH , HIGH ( ( MSJ_PROJECT_NAME * 2 ) )
                 		LDIW	Z,(MSJ_PROJECT_NAME*2)
0000f4 d03e      		RCALL TRANSMITIR_MENSAJE
0000f5 cffb      		RJMP SIGO
                 CALL_V_BAT:
                +
0000f6 ece8     +ldi ZL , LOW ( ( MSJ_V_BAT * 2 ) )
0000f7 e0f8     +ldi ZH , HIGH ( ( MSJ_V_BAT * 2 ) )
                 		LDIW	Z,(MSJ_V_BAT*2)
                +
0000f8 e4c0     +ldi YL , LOW ( V_BATTERY_DATA )
0000f9 e0d1     +ldi YH , HIGH ( V_BATTERY_DATA )
                 		LDIW	Y,V_BATTERY_DATA
0000fa d055      		RCALL TRANSMITIR_TENSION
0000fb cff5      		RJMP SIGO
                 CALL_V_PANEL:
                +
0000fc eee6     +ldi ZL , LOW ( ( MSJ_V_PANEL * 2 ) )
0000fd e0f8     +ldi ZH , HIGH ( ( MSJ_V_PANEL * 2 ) )
                 		LDIW	Z,(MSJ_V_PANEL*2)
                +
0000fe e4c8     +ldi YL , LOW ( V_SOLAR_PANEL_DATA )
0000ff e0d1     +ldi YH , HIGH ( V_SOLAR_PANEL_DATA )
                 		LDIW	Y,V_SOLAR_PANEL_DATA
000100 d04f      		RCALL TRANSMITIR_TENSION
000101 cfef      		RJMP SIGO
                 CALL_V_LDRS:
                +
000102 e0e0     +ldi ZL , LOW ( ( MSJ_V_LDRS * 2 ) )
000103 e0f9     +ldi ZH , HIGH ( ( MSJ_V_LDRS * 2 ) )
                 		LDIW	Z,(MSJ_V_LDRS*2)
                +
000104 e7c0     +ldi YL , LOW ( LDR_NO_MEAN )
000105 e0d1     +ldi YH , HIGH ( LDR_NO_MEAN )
                 		LDIW	Y,LDR_NO_MEAN
000106 d049      		RCALL TRANSMITIR_TENSION
000107 cfe9      		RJMP SIGO
                 _LIGHT_TURN_ON:
000108 d08d      		RCALL LIGHT_TURN_ON
000109 cfe7      		RJMP SIGO
                 _LIGHT_TURN_OFF:
00010a d093      		RCALL LIGHT_TURN_OFF
00010b cfe5      		RJMP SIGO
                 _BT_DISCONNECT:
00010c d001      		RCALL BT_DISCONNECT
00010d cfe3      		RJMP SIGO
                 BT_DISCONNECT:
00010e 2700      		CLR AUX
                +
                +
                +.if BT_FLAG < 0x40
                +out BT_FLAG , AUX
00010f 9300 0179+.else 
                +sts BT_FLAG , AUX
                 		OUTPUT BT_FLAG,AUX
000111 9508      RET
                 
                 ;------------------------------------------------------------------------
                 ; TRANSMISION: interrumpe cada vez que puede transmitir un byte.
                 ; Se transmiten "BYTES_A_TX" comenzando desde la posicin TX_BUF del
                 ; buffer. Si "BYTES_A_TX" llega a cero, se deshabilita la interrupcin.
                 ;
                 ; Recibe: 	BYTES_A_TX.
                 ; Devuelve: PTR_TX_H:PTR_TX_L, y BYTES_A_TX.
                 ;------------------------------------------------------------------------
                 ISR_REG_USART_VACIO:		; UDR est vaco
000112 930f      		PUSH	AUX
000113 931f      		PUSH	AUX1
                +
000114 b70f     +in AUX , SREG
000115 930f     +push AUX
                 		PUSHI	SREG
                +
000116 93af     +push XL
000117 93bf     +push XH
                 		PUSHW	X
                 
                 
000118 20aa      		TST		BYTES_A_TX	; hay datos pendientes de transmisin?
000119 f069      		BREQ	FIN_TRANSMISION
                 
00011a 01d4      		MOVW	XL,PTR_TX_L	; Recupera puntero al prximo byte a tx.
00011b 910d      		LD		AUX,X+		; lee byte del buffer y apunta al
                +
                +
                +.if UDR0 < 0x40
                +out UDR0 , AUX
00011c 9300 00c6+.else 
                +sts UDR0 , AUX
                 		OUTPUT		UDR0,AUX		; sgte. dato a transmitir (en la prxima int.)
                 
00011e 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
00011f f020      		BRLO	SALVA_PTR_TX
000120 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
000121 f010      		BRLO	SALVA_PTR_TX
                +
000122 e0a0     +ldi XL , LOW ( TX_BUF )
000123 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx=ptr_tx+1, (mdulo BUF_SIZE)
                 
                 SALVA_PTR_TX:
000124 014d      		MOVW	PTR_TX_L,XL	; preserva puntero a sgte. dato
                 
000125 94aa      		DEC		BYTES_A_TX	; Descuenta el nro. de bytes a tx. en 1
000126 f429      		BRNE	SIGUE_TX	; si quedan datos que transmitir
                 							;	vuelve en la prxima int.
                 ;REVISAR ESTE GRUPO DE INSTRUCCIONES
                 FIN_TRANSMISION:			; si no hay nada que enviar,
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
000127 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
000129 7d0f      		CBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
00012a 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 		;se deshabilita la interrupcin.
                 
                 sigue_tx:
                +
00012c 91bf     +pop XH
00012d 91af     +pop XL
                 		POPW	X
                +
00012e 910f     +pop AUX
00012f bf0f     +out SREG , AUX
                 		POPI	SREG
000130 911f      		POP		AUX1
000131 910f      		POP		AUX
000132 9518      		RETI
                 
                 ;-------------------------------------------------------------------------
                 ; TRANSMITIR_MENSAJE: transmite el mensaje almacenado en memoria flash a partir
                 ; de la direccin APUNTADA POR Z! que termina con 0x00 (el 0 no se transmite).
                 ; Recibe: nada
                 ; Devuelve: PTR_TX_L|H, BYTES_A_TX.  
                 ; Habilita la int. de transmisin serie con ISR en ISR_REG_USART_VACIO().
                 ;-------------------------------------------------------------------------
                 TRANSMITIR_MENSAJE:
                +
000133 93ef     +push ZL
000134 93ff     +push ZH
                 		PUSHW	Z
                +
000135 93af     +push XL
000136 93bf     +push XH
                 		PUSHW	X
000137 930f      		PUSH	AUX
                 
000138 01d4      		MOVW	XL,PTR_TX_L
                 
                 LOOP_TRANSMITIR_MENSAJE:
000139 9105      		LPM		AUX,Z+
00013a 2300      		TST		AUX
00013b f049      		BREQ	FIN_TRANSMITIR_MENSAJE
                 
00013c 930d      		ST		X+,AUX
00013d 94a3      		INC		BYTES_A_TX
                 
00013e 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
00013f f3c8      		BRLO	LOOP_TRANSMITIR_MENSAJE
000140 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
000141 f3b8      		BRLO	LOOP_TRANSMITIR_MENSAJE
                +
000142 e0a0     +ldi XL , LOW ( TX_BUF )
000143 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
000144 cff4      		RJMP	LOOP_TRANSMITIR_MENSAJE
                 	
                 FIN_TRANSMITIR_MENSAJE:
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
000145 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
                 
000147 6200      		SBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
000148 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 
00014a 910f      		POP		AUX
                +
00014b 91bf     +pop XH
00014c 91af     +pop XL
                 		POPW	X
                +
00014d 91ff     +pop ZH
00014e 91ef     +pop ZL
                 		POPW	Z
00014f 9508      		RET
                 
                 ;-------------------------------------------------------------------------
                 ; fin del cdigo
                 ;-------------------------------------------------------------------------
                 
                 
                 TRANSMITIR_TENSION:
                +
000150 93ef     +push ZL
000151 93ff     +push ZH
                 		PUSHW	Z
                +
000152 93af     +push XL
000153 93bf     +push XH
                 		PUSHW	X
000154 930f      		PUSH	AUX
                 
000155 01d4      		MOVW	XL,PTR_TX_L
                 
                 LOOP_TRANSMITIR_TENSION:
000156 9105      		LPM		AUX,Z+
000157 2300      		TST		AUX
000158 f049      		BREQ	LOOP_TRANSMITIR_DATO	;TERMINO DE MANDAR EL MENSAJE, AHORA MANDO EL DATO
                 
000159 930d      		ST		X+,AUX
00015a 94a3      		INC		BYTES_A_TX
                 
00015b 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
00015c f3c8      		BRLO	LOOP_TRANSMITIR_TENSION
00015d 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
00015e f3b8      		BRLO	LOOP_TRANSMITIR_TENSION
                +
00015f e0a0     +ldi XL , LOW ( TX_BUF )
000160 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
000161 cff4      		RJMP	LOOP_TRANSMITIR_TENSION
                 	
                 LOOP_TRANSMITIR_DATO:
000162 9109      		LD		AUX,Y+
000163 2300      		TST		AUX
000164 f049      		BREQ	FIN_TRANSMITIR_DATO
                 
000165 930d      		ST		X+,AUX
000166 94a3      		INC		BYTES_A_TX
                 
000167 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
000168 f3c8      		BRLO	LOOP_TRANSMITIR_DATO
000169 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
00016a f3b8      		BRLO	LOOP_TRANSMITIR_DATO
                +
00016b e0a0     +ldi XL , LOW ( TX_BUF )
00016c e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
00016d cff4      		RJMP	LOOP_TRANSMITIR_DATO
                 	
                 FIN_TRANSMITIR_DATO:
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
00016e 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
                 
000170 6200      		SBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
000171 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 
000173 910f      		POP		AUX
                +
000174 91bf     +pop XH
000175 91af     +pop XL
                 		POPW	X
                +
000176 91ff     +pop ZH
000177 91ef     +pop ZL
                 		POPW	Z
                 .include "DELAY.inc"
000178 9508      
                 ;		Para crear los delays, no te hagas el crack y
                 ;		us el bocho de alguien que ya lo pens:
                 ;		http://www.bretmulvey.com/avrdelay.html
                 ;
                 ;		TENER EN CUENTA QUE EL MICRO TRABAJA A 8MHZ
                 ;
                 ;***********************************************************
                 .CSEG
                 
                 DELAY_100us:
000179 e002          ldi  AUX, 2
00017a e019          ldi  AUX1, 9
00017b 951a      L4: dec  AUX1
00017c f7f1          brne L4
00017d 950a          dec  AUX
00017e f7e1          brne L4
00017f 9508      RET
                 
                 DELAY_50ms:
                 
000180 e003          ldi  AUX, 3
000181 e018          ldi  AUX1, 8
000182 e728          ldi  AUX2, 120
000183 952a      L1: dec  AUX2
000184 f7f1          brne L1
000185 951a          dec  AUX1
000186 f7e1          brne L1
000187 950a          dec  AUX
000188 f7d1          brne L1
000189 9508      RET
                 
                 DELAY_LO_QUE_SE_ME_ANTOJE:
                 
                 ;ABRI EL PROGRAMA Y LISTO.
                 ;HACER PUSH Y POP DE LOS REGS QUE SE USEN
                 
00018a 9508      RET
                 
                 DELAY_500ms:
00018b e105          ldi  AUX, 21
00018c e41b          ldi  AUX1, 75
00018d eb2f          ldi  AUX2, 191
00018e 952a      L3: dec  AUX2
00018f f7f1          brne L3
000190 951a          dec  AUX1
000191 f7e1          brne L3
000192 950a          dec  AUX
000193 f7d1          brne L3
000194 0000          nop
                 .include "LIGHT.inc"
000195 9508      
                 *	LIGHT.inc [COMO SI FUERA UN OBJETO]
                 *
                 *  Created: 01/06/2016 13:10:11 p.m.
                 *   Author: MAU
                 */ 
                 .CSEG
                 ;FUTURA MEJORA: HACER QUE LA LUZ SE MUEVA POR PWM EN FUNCION DE LA CARGA DE LA BATERIA
                 LIGHT_TURN_ON:
                 
                +
                +
                +.if BT_FLAG < 0x40
                +in AUX , BT_FLAG
000196 9100 0179+.else 
                +lds AUX , BT_FLAG
                 	INPUT AUX,BT_FLAG
000198 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: ESTA CONECTADO A BT. 
000199 f019      	BREQ ORDEN_BT_NO_HACER_NADA			;[FLAG=0x00]: NO ESTA CONECTADO A BT.
                 
00019a ef0f      	SER AUX
                +
                +
                +
                +
                +
                +
                +.if LIGHT < 0x40
                +out LIGHT , AUX
00019b 9300 00b4+.else 
                +sts LIGHT , AUX
                +OUTPUT LIGHT , AUX
                 	SPWM LIGHT,AUX
                 
                 /*	INPUT AUX,PORTD
                 	ORI AUX,(1<<LIGHT_PIN)
                 	OUTPUT PORTD,AUX*/
                 
                 ORDEN_BT_NO_HACER_NADA:
00019d 9508      RET
                 
                 LIGHT_TURN_OFF:
                 
                +
                +
                +.if BT_FLAG < 0x40
                +in AUX , BT_FLAG
00019e 9100 0179+.else 
                +lds AUX , BT_FLAG
                 	INPUT AUX,BT_FLAG
0001a0 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: ESTA CONECTADO A BT. 
0001a1 f3d9      	BREQ ORDEN_BT_NO_HACER_NADA			;[FLAG=0x00]: NO ESTA CONECTADO A BT.
                 
0001a2 2700      	CLR AUX
                +
                +
                +
                +
                +
                +
                +.if LIGHT < 0x40
                +out LIGHT , AUX
0001a3 9300 00b4+.else 
                +sts LIGHT , AUX
                +OUTPUT LIGHT , AUX
                 	SPWM LIGHT,AUX
                 
                 /*	INPUT AUX,PORTD
                 	ANDI AUX,(~(1<<LIGHT_PIN))
                 	OUTPUT PORTD,AUX*/
                 
                 .include "BATTERY.inc"
0001a5 9508      
                 ;
                 ;							BATTERY.inc
                 ;
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 BATTERY_INIT:
                +
                +
                +.if DDRD < 0x40
0001a6 b10a     +in AUX , DDRD
                +.else 
                +lds AUX , DDRD
                 	INPUT AUX,DDRD
0001a7 760f      	ANDI AUX,(~((1<<DDD4)|(1<<DDD7)))	;Mascara para tocar solo D3
0001a8 6900      	ORI AUX,((1<<DDD4)|(1<<DDD7))
                +
                +
                +.if DDRD < 0x40
0001a9 b90a     +out DDRD , AUX
                +.else 
                +sts DDRD , AUX
                 	OUTPUT DDRD,AUX
0001aa d01f      	RCALL INDICATE_BATTERY_LOW
                 
                 	;INICIALIZO LA INFORMACION DE LA TENSION PARA TRANSMITIR POR BLUETOOTH
                +
0001ab e4a0     +ldi XL , LOW ( V_BATTERY_DATA )
0001ac e0b1     +ldi XH , HIGH ( V_BATTERY_DATA )
                 	LDIW X,V_BATTERY_DATA
                +
0001ad e370     +ldi AUX4 , '0'
0001ae 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0001af e370     +ldi AUX4 , '0'
0001b0 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0001b1 e27e     +ldi AUX4 , '.'
0001b2 937d     +st X + , AUX4
                 	STI	X+,'.'
                +
0001b3 e370     +ldi AUX4 , '0'
0001b4 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0001b5 e576     +ldi AUX4 , 'V'
0001b6 937d     +st X + , AUX4
                 	STI	X+,'V'
                +
0001b7 e07d     +ldi AUX4 , '\r'
0001b8 937d     +st X + , AUX4
                 	STI X+,'\r'
                +
0001b9 e07a     +ldi AUX4 , '\n'
0001ba 937d     +st X + , AUX4
                 	STI X+,'\n'
                +
0001bb e070     +ldi AUX4 , 0
0001bc 937c     +st X , AUX4
                 	STI	X,0
                 
0001bd 9508      RET
                 
                 READ_V_BATTERY:
0001be e036      		LDI ADC_DATA_L,ADC_BATTERY			;ELIJO EL PIN DE LA BATERA
0001bf decb      		RCALL ADC_SELECT_INPUT				;LLAMO LA FUNCION PARA SELECCIONAR LA BATERIA
0001c0 ded1      		RCALL ADC_SIMPLE_CONVERSION			;LLAMO LA FUNCION PARA MEDIR
0001c1 9508      RET
                 
                 CHECK_IF_BATTERY_MINIMUM:
0001c2 9488      	CLC
0001c3 3a4a      	CPI		ADC_DATA_H,MIN_BATTERY_VALUE	;COMPARAR PARA VER SI HAY SUFICIENTE BATERIA PARA OPERAR
0001c4 f010      	BRCS	_INDICATE_BATTERY_LOW						;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
0001c5 d009      	RCALL INDICATE_BATTERY_OK
                 	
                 RETURN_INDICATE_BATTERY_LOW:
0001c6 9508      RET
                 
                 _INDICATE_BATTERY_LOW:
0001c7 d002      	RCALL INDICATE_BATTERY_LOW
0001c8 9408      	SEC										;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
0001c9 cffc      RJMP RETURN_INDICATE_BATTERY_LOW
                 
                 INDICATE_BATTERY_LOW:
                +
                +
                +.if PORTD < 0x40
0001ca b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT	AUX,PORTD
0001cb 760f      	ANDI	AUX,(~((1<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW)))
0001cc 6100      	ORI		AUX,((1<<PIN_BATTERY_LED_OK)|(0<<PIN_BATTERY_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTD < 0x40
0001cd b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT	PORTD,AUX
0001ce 9508      RET
                 
                 INDICATE_BATTERY_OK:
                +
                +
                +.if PORTD < 0x40
0001cf b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT	AUX,PORTD
0001d0 760f      	ANDI	AUX,(~((1<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW)))
0001d1 6800      	ORI		AUX,((0<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTD < 0x40
0001d2 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT	PORTD,AUX
0001d3 9488      	CLC										;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
0001d4 9508      RET
                 
                 
                 VBATTERY_TO_ASCII:
                 
                +
0001d5 e4a0     +ldi XL , LOW ( V_BATTERY_DATA )
0001d6 e0b1     +ldi XH , HIGH ( V_BATTERY_DATA )
                 					LDIW X,V_BATTERY_DATA
                +
0001d7 e6e0     +ldi ZL , LOW ( ( VBATTERY_DIG_TABLE * 2 ) )
0001d8 e0f9     +ldi ZH , HIGH ( ( VBATTERY_DIG_TABLE * 2 ) )
                 VBATTERY_DIG:		LDIW Z,(VBATTERY_DIG_TABLE*2)
0001d9 2711      					CLR AUX1
0001da 2722      					CLR AUX2
                 LOOP_DIG_BATTERY:			
0001db d032      					RCALL SET_VBATTERY_DIG
0001dc f056      					BRTS V_BATTERY_DEC
0001dd 9513      					INC AUX1
0001de 301a      					CPI AUX1,10
0001df f010      					BRLO LOWER_THAN_10_DIG_BATTERY
0001e0 2711      					CLR AUX1
0001e1 9523      					INC AUX2
0001e2 f7c6      LOWER_THAN_10_DIG_BATTERY: BRTC LOOP_DIG_BATTERY
                +
0001e3 e371     +ldi AUX4 , 48 + 1
0001e4 937d     +st X + , AUX4
                 					STI X+,48+1
                +
0001e5 e375     +ldi AUX4 , 48 + 5
0001e6 937d     +st X + , AUX4
                 					STI X+,48+5
                 
                +
0001e7 e6e0     +ldi ZL , LOW ( ( VBATTERY_DIG_TABLE * 2 ) )
0001e8 e0f9     +ldi ZH , HIGH ( ( VBATTERY_DIG_TABLE * 2 ) )
                 V_BATTERY_DEC:		LDIW Z,(VBATTERY_DIG_TABLE*2)
0001e9 5310      					SUBI AUX1,48
0001ea 5320      					SUBI AUX2,48
0001eb e06a      					LDI AUX3,10
0001ec 9f26      					MUL AUX2,AUX3
0001ed 2d20      					MOV AUX2,R0
0001ee 0f12      					ADD AUX1,AUX2
                +
                +
                +
                +
0001ef 0fe1     +ADD ZL , AUX1
0001f0 f41b     +BRVC NO_POINTER_OV
0001f1 95f3     +INC ZH
0001f2 1b1e     +SUB AUX1 , ZL
0001f3 2f1e     +MOV AUX1 , ZL
0001f4 0000     +NO_POINTER_OV : NOP
                 					ADDP Z,AUX1
0001f5 9114      					LPM AUX1,Z
0001f6 1b14      					SUB AUX1,ADC_DATA_H	;ACA AUX1 TIENE QUE ESTAR ENTRE 0 Y 15
                 	
                 
                +
0001f7 e27e     +ldi AUX4 , '.'
0001f8 937d     +st X + , AUX4
                 					STI	X+,'.'
0001f9 ea20      					ldi	aux2,160		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
0001fa 9f12      					MUL	AUX1,AUX2
0001fb 2d11      					MOV	AUX1,R1
0001fc 1b61      					SUB AUX3,AUX1					
                +
                +
                +
                +
0001fd e370     +LDI AUX4 , 48
0001fe 0f67     +ADD AUX3 , AUX4
                 					ADDI AUX3,48		;SE TRANSFORMA EN ASCII
0001ff 336a      					CPI AUX3,':'
000200 f059      					BREQ ajuste_9_bat
                 
000201 936d      vuelvo_9_bat:		ST X+,AUX3	;El ASCII del nmero en AUX.
                +
000202 e576     +ldi AUX4 , 'V'
000203 937d     +st X + , AUX4
                 					STI	X+,'V'
                +
000204 e07d     +ldi AUX4 , '\r'
000205 937d     +st X + , AUX4
                 					STI X+,'\r'
                +
000206 e07a     +ldi AUX4 , '\n'
000207 937d     +st X + , AUX4
                 					STI X+,'\n'
                +
000208 e070     +ldi AUX4 , 0
000209 937c     +st X , AUX4
                 					STI	X,0
00020a 94e8      					CLT
00020b 9508      RET	
                 
                 ajuste_9_bat:
00020c e369      		ldi aux3,'9'
00020d cff3      		rjmp vuelvo_9_bat
                 		
                 SET_VBATTERY_DIG:
00020e 9105      					LPM AUX,Z+
00020f 9503      					INC AUX
000210 1740      					CP ADC_DATA_H,AUX
000211 f438      					BRSH END_SET_VBATTERY_DIG
                +
                +
                +
                +
000212 e370     +LDI AUX4 , 48
000213 0f17     +ADD AUX1 , AUX4
                 					ADDI AUX1,48
                +
                +
                +
                +
000214 e370     +LDI AUX4 , 48
000215 0f27     +ADD AUX2 , AUX4
                 					ADDI AUX2,48
000216 932d      					ST X+,AUX2
000217 931d      					ST X+,AUX1
000218 9468      					SET
000219 9508      END_SET_VBATTERY_DIG:	RET
                 
                 
                 
                 /*
                 MAURO:
                 V_BATTERY_TO_ASCII:
                 
                 .DEF UNIDAD		= R17		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 .DEF DECENA		= R18		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 .DEF DECIMAL	= R22		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 
                 	PUSH UNIDAD
                 	PUSH DECENA
                 	PUSH DECIMAL
                 	PUSH ADC_DATA_H
                 
                 	CLR	UNIDAD
                 	CLR DECENA
                 	CLR DECIMAL
                 
                 		TST	ADC_DATA_H
                 		BREQ NULO
                 START:	CLC
                 		SUBI ADC_DATA_H,16
                 		BRCS OOB
                 		CPI ADC_DATA_H,16
                 		BRLO PASSED
                 		BREQ dec_0
                 		inc	unidad
                 		cpi unidad,10
                 		breq acomodo
                 		RJMP START
                 
                 OOB:	NEG ADC_DATA_H
                 
                 PASSED:	ldi	aux1,160		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
                 		MUL	ADC_DATA_H,AUX1
                 		MOV	ADC_DATA_H,R1
                 dec_0:	MOV	decimal,ADC_DATA_H
                 	
                 NULO:
                 		LDIW	Z,V_BATTERY_DATA
                 SUBIR_DECENA:
                 	ADDI	DECENA,48
                 	ST	Z+,DECENA
                 
                 SUBIR_UNIDAD:
                 	ADDI	UNIDAD,48
                 	ST	Z+,UNIDAD
                 
                 SUBIR_PUNTO:
                 	STI		Z+,'.'
                 
                 SUBIR_DECIMAL:
                 	ADDI	DECIMAL,48
                 	ST	Z+,DECIMAL
                 
                 SUBIR_FINAL:
                 	STI		Z+,'V'
                 	STI		Z+,'\r'
                 	STI		Z+,'\n'
                 	STI		Z,0
                 
                 	POP ADC_DATA_H
                 	POP	DECIMAL
                 	POP DECENA
                 	POP UNIDAD
                 RET	
                 
                 ACOMODO:
                 	CLR UNIDAD
                 	INC DECENA
                 RJMP START
                 .include "SOLAR_PANEL.inc"
                 
                 ;
                 ;							SOLAR_PANEL.inc
                 ;				
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 SOLAR_PANEL_INIT:
                +
                +
                +.if DDRC < 0x40
00021a b107     +in AUX , DDRC
                +.else 
                +lds AUX , DDRC
                 	INPUT AUX,DDRC
00021b 7f0c      	ANDI AUX,(~((1<<DDC0)|(1<<DDC1)))	;Mascara para tocar los leds del panel solar
00021c 6003      	ORI AUX,((1<<DDC0)|(1<<DDC1))
                +
                +
                +.if DDRC < 0x40
00021d b907     +out DDRC , AUX
                +.else 
                +sts DDRC , AUX
                 	OUTPUT DDRC,AUX
00021e d01f      	RCALL INDICATE_SOLAR_PANEL_LOW
                 
                 	;INICIALIZO LA INFORMACION DE LA TENSION PARA TRANSMITIR POR BLUETOOTH
                +
00021f e4a8     +ldi XL , LOW ( V_SOLAR_PANEL_DATA )
000220 e0b1     +ldi XH , HIGH ( V_SOLAR_PANEL_DATA )
                 	LDIW X,V_SOLAR_PANEL_DATA
                +
000221 e370     +ldi AUX4 , '0'
000222 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
000223 e370     +ldi AUX4 , '0'
000224 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
000225 e27e     +ldi AUX4 , '.'
000226 937d     +st X + , AUX4
                 	STI	X+,'.'
                +
000227 e370     +ldi AUX4 , '0'
000228 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
000229 e576     +ldi AUX4 , 'V'
00022a 937d     +st X + , AUX4
                 	STI	X+,'V'
                +
00022b e07d     +ldi AUX4 , '\r'
00022c 937d     +st X + , AUX4
                 	STI X+,'\r'
                +
00022d e07a     +ldi AUX4 , '\n'
00022e 937d     +st X + , AUX4
                 	STI X+,'\n'
                +
00022f e070     +ldi AUX4 , 0
000230 937c     +st X , AUX4
                 	STI	X,0
                 
000231 9508      RET
                 
                 READ_V_SOLAR_PANEL:
                 ;RECIBE: NADA
                 ;DEVUELVE: TENSION DEL PANEL EN ADC_DATA_H
000232 e037      	LDI ADC_DATA_L,ADC_SOLAR_PANEL			;ELIJO EL PIN DEL PANEL SOLAR
000233 de57      	RCALL ADC_SELECT_INPUT					;LLAMO LA FUNCION PARA SELECCIONAR EL PANEL SOLAR
000234 de5d      	RCALL ADC_SIMPLE_CONVERSION				;LLAMO LA FUNCION PARA MEDIR
000235 9508      RET
                 
                 CHECK_IF_SOLAR_PANEL_MINIMUM:
000236 9488      	CLC
000237 3342      	CPI		ADC_DATA_H,MIN_SOLAR_PANEL_VALUE	;COMPARAR PARA VER SI HAY SUFICIENTE BATERIA PARA OPERAR
000238 f010      	BRCS	_INDICATE_SOLAR_PANEL_LOW						;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
000239 d009      	RCALL INDICATE_SOLAR_PANEL_OK
                 	
                 RETURN_INDICATE_SOLAR_PANEL_LOW:
00023a 9508      RET
                 
                 _INDICATE_SOLAR_PANEL_LOW:
00023b d002      	RCALL INDICATE_SOLAR_PANEL_LOW
00023c 9408      	SEC										;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
00023d cffc      RJMP RETURN_INDICATE_SOLAR_PANEL_LOW
                 
                 INDICATE_SOLAR_PANEL_LOW:
                +
                +
                +.if PORTC < 0x40
00023e b108     +in AUX , PORTC
                +.else 
                +lds AUX , PORTC
                 	INPUT	AUX,PORTC
00023f 7f0c      	ANDI	AUX,(~((1<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW)))
000240 6002      	ORI		AUX,((1<<PIN_SOLAR_PANEL_LED_OK)|(0<<PIN_SOLAR_PANEL_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTC < 0x40
000241 b908     +out PORTC , AUX
                +.else 
                +sts PORTC , AUX
                 	OUTPUT	PORTC,AUX
000242 9508      RET
                 
                 INDICATE_SOLAR_PANEL_OK:
                +
                +
                +.if PORTC < 0x40
000243 b108     +in AUX , PORTC
                +.else 
                +lds AUX , PORTC
                 	INPUT	AUX,PORTC
000244 7f0c      	ANDI	AUX,(~((1<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW)))
000245 6001      	ORI		AUX,((0<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTC < 0x40
000246 b908     +out PORTC , AUX
                +.else 
                +sts PORTC , AUX
                 	OUTPUT	PORTC,AUX
000247 9488      	CLC										;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
000248 9508      RET
                 
                 
                 ORIENTATE_SOLAR_PANEL:
                 ;YA ESTAN LOS PROMEDIOS DE LOS LDR Y HAY QUE COMPARAR Y MOVER EL PANEL.
                 ;PRIMERO EN ASIMUT, LUEGO EN ELEVACION.
                 ;EL SOL SALE DEL ESTE Y SE PONE EN EL OESTE.
                 	;SI AMBOS SON 0xFn NO SE MUEVE
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
000249 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 	INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
00024b 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 	INPUT AUX1,LDR_NE_MEAN
00024d 7f00      	ANDI	AUX,0xF0
00024e 7f10      	ANDI	AUX1,0xF0
00024f 3f00      	CPI		AUX,0xF0
000250 f411      	BRNE	NO_SON_F_AZIMUT
000251 1b01      	SUB		AUX,AUX1
000252 f081      	BREQ	AMBOS_SON_F_AZIMUT
                 NO_SON_F_AZIMUT:
                 	;COMPARAR_NO_NE:
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
000253 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
000255 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 		INPUT AUX1,LDR_NE_MEAN
000257 7f00      		ANDI	AUX,0xF0
000258 7f10      		ANDI	AUX1,0xF0
000259 1701      		CP AUX,AUX1
00025a f118      		BRLO _MOTOR_AZIMUT_EAST
                 	RETURN_MOTOR_AZIMUT_EAST:
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
00025b 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
00025d 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 		INPUT AUX1,LDR_NE_MEAN
00025f 7f00      		ANDI	AUX,0xF0
000260 7f10      		ANDI	AUX1,0xF0
000261 1710      		CP AUX1,AUX
000262 f128      		BRLO _MOTOR_AZIMUT_WEST
                 	RETURN_MOTOR_AZIMUT_WEST:
                 AMBOS_SON_F_AZIMUT:
                 
                 ;--------------------ACA NOS MOVEMOS CON NORTE Y SUR
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
000263 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 	INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
000265 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 	INPUT AUX1,LDR_SO_MEAN
000267 7f00      	ANDI	AUX,0xF0
000268 7f10      	ANDI	AUX1,0xF0
000269 3f00      	CPI		AUX,0xF0
00026a f411      	BRNE	NO_SON_F_ELEVATION
00026b 1b01      	SUB		AUX,AUX1
00026c f081      	BREQ	AMBOS_SON_F_ELEVATION
                 NO_SON_F_ELEVATION:
                 	;COMPARAR_NO_SO:
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
00026d 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
00026f 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 		INPUT AUX1,LDR_SO_MEAN
000271 7f00      		ANDI	AUX,0xF0
000272 7f10      		ANDI	AUX1,0xF0
000273 1701      		CP AUX,AUX1
000274 f138      		BRLO _MOTOR_ELEVATION_NORTH
                 	RETURN_MOTOR_ELEVATION_NORTH:
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
000275 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
000277 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 		INPUT AUX1,LDR_SO_MEAN
000279 7f00      		ANDI	AUX,0xF0
00027a 7f10      		ANDI	AUX1,0xF0
00027b 1710      		CP AUX1,AUX
00027c f0a8      		BRLO _MOTOR_ELEVATION_SOUTH
                 	RETURN_MOTOR_ELEVATION_SOUTH:
                 AMBOS_SON_F_ELEVATION:
                 
00027d 9508      RET
                 
                 
                 _MOTOR_AZIMUT_EAST:
00027e 1b01      	SUB AUX,AUX1
00027f 6800      	ORI	AUX,0x80
000280 2f60      	MOV	AUX3,AUX
                 
000281 d140      	RCALL MOTOR_AZIMUT_EAST
000282 defd      		RCALL DELAY_50ms
000283 defc      		RCALL DELAY_50ms
000284 defb      		RCALL DELAY_50ms
000285 defa      		RCALL DELAY_50ms
000286 d177      	RCALL MOTOR_AZIMUT_OFF
                 	;	RCALL DELAY_500ms
000287 cfd3      RJMP RETURN_MOTOR_AZIMUT_EAST
                 
                 _MOTOR_AZIMUT_WEST:
000288 1b10      	SUB AUX1,AUX
000289 6810      	ORI	AUX1,0x80
00028a 2f61      	MOV	AUX3,AUX1
                 
00028b d145      	RCALL MOTOR_AZIMUT_WEST
00028c def3      		RCALL DELAY_50ms
00028d def2      		RCALL DELAY_50ms
00028e def1      		RCALL DELAY_50ms
00028f def0      		RCALL DELAY_50ms
000290 d16d      	RCALL MOTOR_AZIMUT_OFF
000291 cfd1      RJMP RETURN_MOTOR_AZIMUT_WEST
                 
                 
                 _MOTOR_ELEVATION_SOUTH:
000292 1b10      	SUB AUX1,AUX
000293 6a1f      	ORI	AUX1,0xAF
000294 2f61      	MOV	AUX3,AUX1
                 
000295 d14a      	RCALL MOTOR_ELEVATION_SOUTH
000296 dee9      		RCALL DELAY_50ms
000297 dee8      		RCALL DELAY_50ms
000298 dee7      		RCALL DELAY_50ms
000299 dee6      		RCALL DELAY_50ms
00029a d17d      	RCALL MOTOR_ELEVATION_OFF
00029b cfe1      RJMP RETURN_MOTOR_ELEVATION_SOUTH
                 
                 _MOTOR_ELEVATION_NORTH:
00029c 1b10      	SUB AUX1,AUX
00029d 6a1f      	ORI	AUX1,0xAF
00029e 2f61      	MOV	AUX3,AUX1
                 
00029f d14f      	RCALL MOTOR_ELEVATION_NORTH
0002a0 dedf      		RCALL DELAY_50ms
0002a1 dede      		RCALL DELAY_50ms
0002a2 dedd      		RCALL DELAY_50ms
0002a3 dedc      		RCALL DELAY_50ms
0002a4 d173      	RCALL MOTOR_ELEVATION_OFF
0002a5 cfcf      RJMP RETURN_MOTOR_ELEVATION_NORTH
                 
                 
                 
                 
                 VPANEL_TO_ASCII:
                +
0002a6 e4a8     +ldi XL , LOW ( V_SOLAR_PANEL_DATA )
0002a7 e0b1     +ldi XH , HIGH ( V_SOLAR_PANEL_DATA )
                 				LDIW X,V_SOLAR_PANEL_DATA	;Apunto X a la seccin de memoria donde se guarda la tensin a panel a transmitir
                +
0002a8 e4e0     +ldi ZL , LOW ( ( VPANEL_DIG_TABLE * 2 ) )
0002a9 e0f9     +ldi ZH , HIGH ( ( VPANEL_DIG_TABLE * 2 ) )
                 				LDIW Z,(VPANEL_DIG_TABLE*2)	;Apunto Z a la seccin de ROM donde se delimita cada unidad
0002aa 2711      VPANEL_DIG:		CLR AUX1					;Ac se guardar el x1
0002ab 2722      				CLR AUX2					;Ac se guardar el x10
                 LOOP_DIG_PANEL:			
0002ac d02f      				RCALL SET_VPANEL_DIG		;Busco el nmero
0002ad f056      				BRTS V_PANEL_DEC
0002ae 9513      				INC AUX1					;Incremento para ver si es el siguiente en el prox ciclo
0002af 301a      				CPI AUX1,10					;Veo si super 10 para ver si tengo que poner el x10 en 1
0002b0 f010      				BRLO LOWER_THAN_10_DIG_PANEL;Si no super 10, sigo el ciclo
0002b1 2711      				CLR AUX1					;Si es 10, x1 es 0
0002b2 9523      				INC AUX2					;Si es 10, x10 es 1
0002b3 f7c6      LOWER_THAN_10_DIG_PANEL:	BRTC LOOP_DIG_PANEL
                +
0002b4 e371     +ldi AUX4 , 48 + 1
0002b5 937d     +st X + , AUX4
                 				STI X+,48+1					;Si se completaron todos los ciclos, el x10 es 1
                +
0002b6 e379     +ldi AUX4 , 48 + 9
0002b7 937d     +st X + , AUX4
                 				STI X+,48+9					;Si se completaron todos los ciclos, el x1 es 9
                +
0002b8 e4e0     +ldi ZL , LOW ( ( VPANEL_DIG_TABLE * 2 ) )
0002b9 e0f9     +ldi ZH , HIGH ( ( VPANEL_DIG_TABLE * 2 ) )
                 V_PANEL_DEC:	LDIW Z,(VPANEL_DIG_TABLE*2)	;Vuelvo a apuntar Z al comienzo de la tabla donde estn los nmeros que delimitan cada unidad
0002ba 5310      				SUBI AUX1,48				;Lo vuelvo a convertir en nmero no ASCII
0002bb 5320      				SUBI AUX2,48
0002bc e06a      				LDI AUX3,10					;Cargo 10 en AUX3 para multiplicar el x10 por 10 y poder sumarselo al x1
0002bd 9f26      				MUL AUX2,AUX3				;Multiplico el x10 por 10
0002be 2d20      				MOV AUX2,R0					;Paso el resultado de R0 a AUX2
0002bf 0f12      				ADD AUX1,AUX2				;Sumo x1 y x10 para tener el nmero completo
                +
                +
                +
                +
0002c0 0fe1     +ADD ZL , AUX1
0002c1 f41b     +BRVC NO_POINTER_OV
0002c2 95f3     +INC ZH
0002c3 1b1e     +SUB AUX1 , ZL
0002c4 2f1e     +MOV AUX1 , ZL
0002c5 0000     +NO_POINTER_OV : NOP
                 				ADDP Z,AUX1					;Le sumo al puntero Z la cantidad de posiciones que se tiene que mover en la tabla para ver el nmero mximo que puede tener esa unidad
0002c6 9114      				LPM AUX1,Z					;Cargo el nmero delimitador
0002c7 1b14      				SUB AUX1,ADC_DATA_H			;Le resto al delimitador el nmero que med
                +
0002c8 e27e     +ldi AUX4 , '.'
0002c9 937d     +st X + , AUX4
                 				STI	X+,'.'
0002ca 1b61      				SUB AUX3,AUX1					
                +
                +
                +
                +
0002cb e371     +LDI AUX4 , 49
0002cc 0f67     +ADD AUX3 , AUX4
                 				ADDI AUX3,49		;SE TRANSFORMA EN ASCII
0002cd 336a      				CPI AUX3,':'
0002ce f059      				BREQ ajuste_9_panel
                 
0002cf 936d      vuelvo_9_panel:	ST X+,AUX3	;El ASCII del nmero en AUX.
                +
0002d0 e576     +ldi AUX4 , 'V'
0002d1 937d     +st X + , AUX4
                 				STI	X+,'V'
                +
0002d2 e07d     +ldi AUX4 , '\r'
0002d3 937d     +st X + , AUX4
                 				STI X+,'\r'
                +
0002d4 e07a     +ldi AUX4 , '\n'
0002d5 937d     +st X + , AUX4
                 				STI X+,'\n'
                +
0002d6 e070     +ldi AUX4 , 0
0002d7 937c     +st X , AUX4
                 				STI	X,0
0002d8 94e8      				CLT
0002d9 9508      RET
                 
                 ajuste_9_panel:
0002da e369      				ldi aux3,'9'
0002db cff3      				rjmp vuelvo_9_panel
                 	
                 
                 SET_VPANEL_DIG:
0002dc 9105      					LPM AUX,Z+				;Leo de tabla en ROM
0002dd 9503      					INC AUX					;Incremento lo ledo porque se usar BRSH
0002de 1740      					CP ADC_DATA_H,AUX		;Veo si el nmero es menor al de la tabla a ver si encontramos el valor
0002df f438      					BRSH END_SET_VPANEL_DIG	;Si es mayor o igual, sigo buscando
                 											;ESTO NO ES LO QUE QUERES HACER
                +
                +
                +
                +
0002e0 e370     +LDI AUX4 , 48
0002e1 0f17     +ADD AUX1 , AUX4
                 					ADDI AUX1,48			;Le sumo 48 al nmero porque los nmeros en ASCII comienzan a partir de 48
                +
                +
                +
                +
0002e2 e370     +LDI AUX4 , 48
0002e3 0f27     +ADD AUX2 , AUX4
                 					ADDI AUX2,48
0002e4 932d      					ST X+,AUX2				;Guardo el x10
0002e5 931d      					ST X+,AUX1				;Guardo el x1
0002e6 9468      					SET
                 .include "LDRS.inc"
0002e7 9508      
                 ;
                 ;						HEADER DE LOS LDR'S
                 ;			NO USAR EL ADC5 PARA COMPARAR! FUERA DE ESCALA
                 ;------------------------------------------------------------------
                 .CSEG
                 
                 LDRS_INIT:
0002e8 d026      		RCALL LDRS_POINTERS_RESET
0002e9 2744      LOOP:	CLR ADC_DATA_H
                +
                +
                +
                +
                +
0002ea 2de2     +MOV ZL , LDR_NO_LOW
0002eb 2df3     +MOV ZH , LDR_NO_HIGH
0002ec 9341     +ST Z + , ADC_DATA_H
0002ed 2e2e     +MOV LDR_NO_LOW , ZL
0002ee 2e3f     +MOV LDR_NO_HIGH , ZH
                 		SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
0002ef 2deb     +MOV ZL , LDR_SO_LOW
0002f0 2dfc     +MOV ZH , LDR_SO_HIGH
0002f1 9341     +ST Z + , ADC_DATA_H
0002f2 2ebe     +MOV LDR_SO_LOW , ZL
0002f3 2ecf     +MOV LDR_SO_HIGH , ZH
                 		SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
0002f4 2de6     +MOV ZL , LDR_SE_LOW
0002f5 2df7     +MOV ZH , LDR_SE_HIGH
0002f6 9341     +ST Z + , ADC_DATA_H
0002f7 2e6e     +MOV LDR_SE_LOW , ZL
0002f8 2e7f     +MOV LDR_SE_HIGH , ZH
                 		SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
0002f9 2de4     +MOV ZL , LDR_NE_LOW
0002fa 2df5     +MOV ZH , LDR_NE_HIGH
0002fb 9341     +ST Z + , ADC_DATA_H
0002fc 2e4e     +MOV LDR_NE_LOW , ZL
0002fd 2e5f     +MOV LDR_NE_HIGH , ZH
                 		SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
0002fe 9100 0177+.else 
                +lds AUX , COUNTER
                 		INPUT AUX,COUNTER
000300 9503      		INC AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
000301 9300 0177+.else 
                +sts COUNTER , AUX
                 		OUTPUT COUNTER,AUX
000303 3008      		CPI AUX,CANT_SAMPLES			;CHEQUEAR QUE NO ESTE HACIENDO UNO DE MENOS
000304 f320      		BRLO LOOP
000305 d009      		RCALL LDRS_POINTERS_RESET
                 
                +
000306 e7a4     +ldi XL , LOW ( auxiliar_para_probar )
000307 e0b1     +ldi XH , HIGH ( auxiliar_para_probar )
                 		LDIW	X,auxiliar_para_probar
                +
000308 e07d     +ldi AUX4 , '\r'
000309 937d     +st X + , AUX4
                 		STI		X+,'\r'
                +
00030a e07a     +ldi AUX4 , '\n'
00030b 937d     +st X + , AUX4
                 		STI		X+,'\n'
                +
00030c e070     +ldi AUX4 , 0
00030d 937c     +st X , AUX4
                 		STI		X,0
00030e 9508      RET
                 
                 LDRS_POINTERS_RESET:
                +
00030f e500     +ldi AUX , LOW ( LDR_NO_BUFFER )
000310 2e20     +mov LDR_NO_LOW , AUX
                 	MOVI LDR_NO_LOW,LOW(LDR_NO_BUFFER)
                +
000311 e001     +ldi AUX , HIGH ( LDR_NO_BUFFER )
000312 2e30     +mov LDR_NO_HIGH , AUX
                 	MOVI LDR_NO_HIGH,HIGH(LDR_NO_BUFFER)
                 
                +
000313 e508     +ldi AUX , LOW ( LDR_NE_BUFFER )
000314 2e40     +mov LDR_NE_LOW , AUX
                 	MOVI LDR_NE_LOW,LOW(LDR_NE_BUFFER)
                +
000315 e001     +ldi AUX , HIGH ( LDR_NE_BUFFER )
000316 2e50     +mov LDR_NE_HIGH , AUX
                 	MOVI LDR_NE_HIGH,HIGH(LDR_NE_BUFFER)
                 
                +
000317 e600     +ldi AUX , LOW ( LDR_SE_BUFFER )
000318 2e60     +mov LDR_SE_LOW , AUX
                 	MOVI LDR_SE_LOW,LOW(LDR_SE_BUFFER)
                +
000319 e001     +ldi AUX , HIGH ( LDR_SE_BUFFER )
00031a 2e70     +mov LDR_SE_HIGH , AUX
                 	MOVI LDR_SE_HIGH,HIGH(LDR_SE_BUFFER)
                 
                +
00031b e608     +ldi AUX , LOW ( LDR_SO_BUFFER )
00031c 2eb0     +mov LDR_SO_LOW , AUX
                 	MOVI LDR_SO_LOW,LOW(LDR_SO_BUFFER)
                +
00031d e001     +ldi AUX , HIGH ( LDR_SO_BUFFER )
00031e 2ec0     +mov LDR_SO_HIGH , AUX
                 	MOVI LDR_SO_HIGH,HIGH(LDR_SO_BUFFER)
                 
00031f 2700      	CLR AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
000320 9300 0177+.else 
                +sts COUNTER , AUX
                 	OUTPUT COUNTER,AUX
000322 9508      RET
                 
                 LDRS_READ:
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
000323 9100 0177+.else 
                +lds AUX , COUNTER
                 	INPUT AUX,COUNTER			;CHEQUEO QUE SEA MENOR A CANT_SAMPLES. SI ES MAYOR, RESETEO LOS PUNTEROS. [EL BUFFER ESTA LLENO, SACO LA PRIMER MUESTRA].
000325 3008      	CPI AUX,CANT_SAMPLES
000326 f0f1      	BREQ _LDRS_POINTERS_RESET
                 LDRS_POINTERS_RESET_RETURN:
                 
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
000327 9100 0177+.else 
                +lds AUX , COUNTER
                 	INPUT AUX,COUNTER
000329 9503      		INC AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
00032a 9300 0177+.else 
                +sts COUNTER , AUX
                 	OUTPUT COUNTER,AUX
                 
00032c d074      	RCALL READ_LDR_NO										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
00032d 2de2     +MOV ZL , LDR_NO_LOW
00032e 2df3     +MOV ZH , LDR_NO_HIGH
00032f 9341     +ST Z + , ADC_DATA_H
000330 2e2e     +MOV LDR_NO_LOW , ZL
000331 2e3f     +MOV LDR_NO_HIGH , ZH
                 	SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
000332 d07a      	RCALL READ_LDR_NE										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
000333 2de4     +MOV ZL , LDR_NE_LOW
000334 2df5     +MOV ZH , LDR_NE_HIGH
000335 9341     +ST Z + , ADC_DATA_H
000336 2e4e     +MOV LDR_NE_LOW , ZL
000337 2e5f     +MOV LDR_NE_HIGH , ZH
                 	SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
000338 d070      	RCALL READ_LDR_SE										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
000339 2de6     +MOV ZL , LDR_SE_LOW
00033a 2df7     +MOV ZH , LDR_SE_HIGH
00033b 9341     +ST Z + , ADC_DATA_H
00033c 2e6e     +MOV LDR_SE_LOW , ZL
00033d 2e7f     +MOV LDR_SE_HIGH , ZH
                 	SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
00033e d066      	RCALL READ_LDR_SO										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
00033f 2deb     +MOV ZL , LDR_SO_LOW
000340 2dfc     +MOV ZH , LDR_SO_HIGH
000341 9341     +ST Z + , ADC_DATA_H
000342 2ebe     +MOV LDR_SO_LOW , ZL
000343 2ecf     +MOV LDR_SO_HIGH , ZH
                 	SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
000344 9508      RET
                 
                 _LDRS_POINTERS_RESET:
000345 dfc9      	RCALL LDRS_POINTERS_RESET
000346 cfe0      RJMP LDRS_POINTERS_RESET_RETURN
                 
                 LDRS_MEAN:
                 ;OBS: PARA HACER EL PROMEDIO NO IMPORTA SI NO SE TOMARON CANT_SAMPLES, EL BUFFER ESTA INICIALIZADO CON CERO.
000347 e008      	LDI	AUX,CANT_SAMPLES					;VECTMEAN NECESITA LA CANTIDAD DE LAS MUESTRAS
                 
                +
000348 e5e0     +ldi ZL , LOW ( LDR_NO_BUFFER )
000349 e0f1     +ldi ZH , HIGH ( LDR_NO_BUFFER )
                 	LDIW Z,LDR_NO_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
00034a 930f     +PUSH AUX
00034b 9161     +LD AUX3 , Z +
00034c 2711     +CLR AUX1
00034d 950a     +DEC AUX
00034e 2722     +CLR AUX2
                +loop_mean :
00034f 94b8     +CLV
000350 9171     +LD AUX4 , Z +
000351 0f67     +ADD AUX3 , AUX4
000352 1f12     +ADC AUX1 , AUX2
000353 950a     +DEC AUX
000354 f7d1     +BRNE loop_mean
000355 e023     +LDI AUX2 , 3
                +division :
000356 9516     +LSR AUX1
000357 9567     +ROR AUX3
000358 952a     +DEC AUX2
000359 f7e1     +BRNE division
00035a 2f16     +MOV AUX1 , AUX3
00035b 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +out LDR_NO_MEAN , AUX1
00035c 9310 0170+.else 
                +sts LDR_NO_MEAN , AUX1
                 	OUTPUT LDR_NO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
00035e e5e8     +ldi ZL , LOW ( LDR_NE_BUFFER )
00035f e0f1     +ldi ZH , HIGH ( LDR_NE_BUFFER )
                 	LDIW Z,LDR_NE_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
000360 930f     +PUSH AUX
000361 9161     +LD AUX3 , Z +
000362 2711     +CLR AUX1
000363 950a     +DEC AUX
000364 2722     +CLR AUX2
                +loop_mean :
000365 94b8     +CLV
000366 9171     +LD AUX4 , Z +
000367 0f67     +ADD AUX3 , AUX4
000368 1f12     +ADC AUX1 , AUX2
000369 950a     +DEC AUX
00036a f7d1     +BRNE loop_mean
00036b e023     +LDI AUX2 , 3
                +division :
00036c 9516     +LSR AUX1
00036d 9567     +ROR AUX3
00036e 952a     +DEC AUX2
00036f f7e1     +BRNE division
000370 2f16     +MOV AUX1 , AUX3
000371 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +out LDR_NE_MEAN , AUX1
000372 9310 0171+.else 
                +sts LDR_NE_MEAN , AUX1
                 	OUTPUT LDR_NE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
000374 e6e0     +ldi ZL , LOW ( LDR_SE_BUFFER )
000375 e0f1     +ldi ZH , HIGH ( LDR_SE_BUFFER )
                 	LDIW Z,LDR_SE_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
000376 930f     +PUSH AUX
000377 9161     +LD AUX3 , Z +
000378 2711     +CLR AUX1
000379 950a     +DEC AUX
00037a 2722     +CLR AUX2
                +loop_mean :
00037b 94b8     +CLV
00037c 9171     +LD AUX4 , Z +
00037d 0f67     +ADD AUX3 , AUX4
00037e 1f12     +ADC AUX1 , AUX2
00037f 950a     +DEC AUX
000380 f7d1     +BRNE loop_mean
000381 e023     +LDI AUX2 , 3
                +division :
000382 9516     +LSR AUX1
000383 9567     +ROR AUX3
000384 952a     +DEC AUX2
000385 f7e1     +BRNE division
000386 2f16     +MOV AUX1 , AUX3
000387 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_SE_MEAN < 0x40
                +out LDR_SE_MEAN , AUX1
000388 9310 0172+.else 
                +sts LDR_SE_MEAN , AUX1
                 	OUTPUT LDR_SE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
00038a e6e8     +ldi ZL , LOW ( LDR_SO_BUFFER )
00038b e0f1     +ldi ZH , HIGH ( LDR_SO_BUFFER )
                 	LDIW Z,LDR_SO_BUFFER					;UBICO EL LDR_SO EN UN PUNTERO.
                +
00038c 930f     +PUSH AUX
00038d 9161     +LD AUX3 , Z +
00038e 2711     +CLR AUX1
00038f 950a     +DEC AUX
000390 2722     +CLR AUX2
                +loop_mean :
000391 94b8     +CLV
000392 9171     +LD AUX4 , Z +
000393 0f67     +ADD AUX3 , AUX4
000394 1f12     +ADC AUX1 , AUX2
000395 950a     +DEC AUX
000396 f7d1     +BRNE loop_mean
000397 e023     +LDI AUX2 , 3
                +division :
000398 9516     +LSR AUX1
000399 9567     +ROR AUX3
00039a 952a     +DEC AUX2
00039b f7e1     +BRNE division
00039c 2f16     +MOV AUX1 , AUX3
00039d 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +out LDR_SO_MEAN , AUX1
00039e 9310 0173+.else 
                +sts LDR_SO_MEAN , AUX1
                 	OUTPUT LDR_SO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
0003a0 9508      RET	
                 
                 
                 
                 
                 READ_LDR_NO:
0003a1 e033      	LDI ADC_DATA_L,LDR_NO
0003a2 dce8      	RCALL ADC_SELECT_INPUT
0003a3 dcee      	RCALL ADC_SIMPLE_CONVERSION
0003a4 9508      RET
                 
                 READ_LDR_SO:
0003a5 e035      	LDI ADC_DATA_L,LDR_SO
0003a6 dce4      	RCALL ADC_SELECT_INPUT
0003a7 dcea      	RCALL ADC_SIMPLE_CONVERSION
0003a8 9508      RET
                 
                 READ_LDR_SE:
0003a9 e034      	LDI ADC_DATA_L,LDR_SE
0003aa dce0      	RCALL ADC_SELECT_INPUT
0003ab dce6      	RCALL ADC_SIMPLE_CONVERSION
0003ac 9508      RET
                 
                 READ_LDR_NE:
0003ad e032      	LDI ADC_DATA_L,LDR_NE
0003ae dcdc      	RCALL ADC_SELECT_INPUT
0003af dce2      	RCALL ADC_SIMPLE_CONVERSION
                 .include "MOTORS.inc"
0003b0 9508      
                 ;
                 ;							MOTORS.inc
                 ;
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 MOTORS_INIT:
                +
                +
                +.if DDRD < 0x40
0003b1 b10a     +in AUX , DDRD
                +.else 
                +lds AUX , DDRD
                 	INPUT AUX,DDRD
0003b2 790f      	ANDI AUX,(~((1<<DDD5)|(1<<DDD6)))
0003b3 6600      	ORI AUX,((1<<DDD5)|(1<<DDD6))
                +
                +
                +.if DDRD < 0x40
0003b4 b90a     +out DDRD , AUX
                +.else 
                +sts DDRD , AUX
                 	OUTPUT DDRD,AUX
                 
                +
                +
                +.if PORTD < 0x40
0003b5 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
0003b6 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
0003b7 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
0003b8 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
0003b9 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
                +
                +
                +.if OCR1AH < 0x40
                +out OCR1AH , AUX
0003bb 9300 0089+.else 
                +sts OCR1AH , AUX
                 	OUTPUT	OCR1AH,AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
0003bd 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                +
                +
                +.if OCR1BH < 0x40
                +out OCR1BH , AUX
0003bf 9300 008b+.else 
                +sts OCR1BH , AUX
                 	OUTPUT	OCR1BH,AUX
0003c1 9508      RET
                 
                 MOTOR_AZIMUT_EAST:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
0003c2 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
0003c4 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
0003c5 6851      	ORI PWM_DATA,((1<<COM1A1)|(0<<COM1A0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
0003c6 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
0003c8 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
0003c9 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
0003ca 6400      	ORI AUX,((0<<MOT_1)|(1<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
0003cb b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
0003cc 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
0003cd 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
0003cf d062      	rcall smooth_move_azimut
                 	;OUTPUT	OCR1AL,AUX1
0003d0 9508      RET
                 
                 MOTOR_AZIMUT_WEST:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
0003d1 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
0003d3 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
0003d4 6851      	ORI PWM_DATA,((1<<COM1A1)|(0<<COM1A0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
0003d5 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
0003d7 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
0003d8 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
0003d9 6200      	ORI AUX,((1<<MOT_1)|(0<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
0003da b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
0003db 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
0003dc 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
0003de d053      	rcall smooth_move_azimut
                 	;OUTPUT	OCR1AL,AUX1
0003df 9508      RET
                 
                 MOTOR_ELEVATION_SOUTH:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
0003e0 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
0003e2 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
0003e3 6251      	ORI PWM_DATA,((1<<COM1B1)|(0<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
0003e4 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
0003e6 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
0003e7 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
0003e8 6200      	ORI AUX,((1<<MOT_1)|(0<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
0003e9 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
0003ea 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
0003eb 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 	
0003ed d054      	rcall smooth_move_elevation
                 	;OUTPUT	OCR1BL,AUX1
0003ee 9508      RET
                 
                 
                 
                 MOTOR_ELEVATION_NORTH:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
0003ef 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
0003f1 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
0003f2 6251      	ORI PWM_DATA,((1<<COM1B1)|(0<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
0003f3 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
0003f5 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
0003f6 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
0003f7 6400      	ORI AUX,((0<<MOT_1)|(1<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
0003f8 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
0003f9 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
0003fa 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 
0003fc d045      	RCALL smooth_move_elevation
                 	;OUTPUT	OCR1BL,AUX1
                 
0003fd 9508      RET
                 
                 MOTOR_AZIMUT_OFF:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
0003fe 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000400 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
000401 6051      	ORI PWM_DATA,((1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
000402 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
000404 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000405 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
000406 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
                +
                +
                +.if OCR1AL < 0x40
                +in AUX4 , OCR1AL
000407 9170 0088+.else 
                +lds AUX4 , OCR1AL
                 	INPUT AUX4,OCR1AL
                 
                 brake_AZIMUT:
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
000409 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
00040b 387c      	cpI aux4,140
00040c f410      	brSH	ASDF
00040d dd6b      	RCALL DELAY_100us
00040e dd6a      	RCALL DELAY_100us
00040f dd69      ASDF:	RCALL DELAY_100us
000410 dd68      	RCALL DELAY_100us
000411 dd67      	RCALL DELAY_100us
000412 957a      	dec aux4
000413 f7a9      	brne brake_AZIMUT
                 
000414 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
000415 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
                 
000417 9508      RET
                 
                 MOTOR_ELEVATION_OFF:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000418 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
00041a 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
00041b 6051      	ORI PWM_DATA,((1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
00041c 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
00041e b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
00041f 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
000420 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
                +
                +
                +.if OCR1BL < 0x40
                +in AUX4 , OCR1BL
000421 9170 008a+.else 
                +lds AUX4 , OCR1BL
                 	INPUT AUX4,OCR1BL
                 
                 brake_elevation:
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
000423 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
000425 3a7a      	cpI aux4,170
000426 f410      	brSH	ASF
000427 dd51      	RCALL DELAY_100us
000428 dd50      	RCALL DELAY_100us
000429 dd4f      ASF:	RCALL DELAY_100us
00042a dd4e      	RCALL DELAY_100us
00042b dd4d      	RCALL DELAY_100us
00042c 957a      	dec aux4
00042d f7a9      	brne brake_elevation
                 
00042e 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
00042f 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 
000431 9508      RET
                 smooth_move_azimut:
000432 2777      	clr aux4
000433 9573      _s:	inc aux4
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
000434 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
000436 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
000438 dd40      	RCALL DELAY_100us
000439 3a7a      	cpi aux4,170
00043a f410      	brsh nxt
00043b dd3d      	rcall delay_100us
00043c dd3c      	rcall delay_100us
                 nxt:
00043d dd3b      	rcall delay_100us
00043e dd3a      	rcall delay_100us
00043f 1776      	cp aux4,AUX3
000440 f390      	brlo _s
000441 9508      ret
                 
                 smooth_move_elevation:
000442 2777      	clr aux4
000443 9573      _sM:	inc aux4
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
000444 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
000446 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
000448 dd30      	RCALL DELAY_100us
000449 3a7a      	cpi aux4,170
00044a f410      	brsh nxtM
00044b dd2d      	rcall delay_100us
00044c dd2c      	rcall delay_100us
                 nxtM:
00044d dd2b      	rcall delay_100us
00044e dd2a      	rcall delay_100us
00044f 1776      	cp aux4,AUX3
000450 f390      	brlo _sM
000451 9508      ret
                 .include "MESSAGES.inc"
                 
                 ;MENSAJES EN ROM
000452 4f53
000453 414c
000454 2052
000455 5254
000456 4341
000457 454b
000458 0d52
000459 480a
00045a 4341
00045b 4549
00045c 444e
00045d 204f
00045e 4c45
00045f 4620
000460 5455
000461 5255
000462 0d4f
000463 000a      MSJ_PROJECT_NAME:			.DB	"SOLAR TRACKER",'\r','\n',"HACIENDO EL FUTURO",'\r','\n',0
000464 414c
000465 5420
000466 4e45
000467 4953
000468 4e4f
000469 4420
00046a 2045
00046b 414c
00046c 4220
00046d 5441
00046e 5245
00046f 4149
000470 4520
000471 3a53
000472 0020      MSJ_V_BAT:					.DB	"LA TENSION DE LA BATERIA ES: ",0
000473 414c
000474 5420
000475 4e45
000476 4953
000477 4e4f
000478 4420
000479 4c45
00047a 5020
00047b 4e41
00047c 4c45
00047d 4520
00047e 3a53
00047f 0020      MSJ_V_PANEL:				.DB "LA TENSION DEL PANEL ES: ",0
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(6): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(229): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
000480 0000      MSJ_V_LDRS:					.DB 0
000481 414c
000482 4220
000483 5441
000484 5245
000485 4149
000486 4520
000487 5453
000488 2041
000489 4544
00048a 4353
00048b 4e4f
00048c 4345
00048d 4154
00048e 4144
00048f 0d21
000490 000a      MSJ_DISCONNECTED_BATTERY:	.DB "LA BATERIA ESTA DESCONECTADA!",'\r','\n',0
000491 4c45
000492 5020
000493 4e41
000494 4c45
000495 4520
000496 5453
000497 2041
000498 4544
000499 4353
00049a 4e4f
00049b 4345
00049c 4154
00049d 4f44
00049e 0d21
00049f 000a      MSJ_DISCONNECTED_PANEL:		.DB "EL PANEL ESTA DESCONECTADO!",'\r','\n',0
                 
0004a0 190c
0004a1 3326
0004a2 4c40
0004a3 6659
0004a4 7f73
0004a5 998d
0004a6 b3a6
0004a7 cdc0
0004a8 e6d9
0004a9 fff3      VPANEL_DIG_TABLE:			.DB	12,25,38,51,64,76,89,102,115,127,141,153,166,179,192,205,217,230,243,255
0004aa 0100
0004ab 0302
0004ac 0504
0004ad 0605
0004ae 0807
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(11): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(229): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
0004af 0009      VPANEL_DEC_TABLE:			.DB 0,1,2,3,4,5,5,6,7,8,9
                 
0004b0 2010
0004b1 4130
0004b2 6151
0004b3 8272
0004b4 a392
0004b5 c3b3
0004b6 e4d4
0004b7 fff4      VBATTERY_DIG_TABLE:			.DB 16,32,48,65,81,97,114,130,146,163,179,195,212,228,244,255
0004b8 0100
0004b9 0201
0004ba 0303
0004bb 0504
0004bc 0605
0004bd 0707
0004be 0908
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(14): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(229): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
0004bf 0009      VBATTERY_DEC_TABLE:			.DB 0,1,1,2,3,3,4,5,5,6,7,7,8,9,9
                 
                 
                 
                 
                 	


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega88" register use summary:
r0 :   2 r1 :   1 r2 :   5 r3 :   5 r4 :   5 r5 :   5 r6 :   5 r7 :   5 
r8 :   5 r9 :   1 r10:   6 r11:   5 r12:   5 r13:   0 r14:   0 r15:   0 
r16: 268 r17:  90 r18:  38 r19:  14 r20:  16 r21:  36 r22:  36 r23: 106 
r24:   0 r25:   0 r26:  26 r27:  22 r28:   5 r29:   5 r30:  41 r31:  37 
x  :  44 y  :   1 z  :  22 
Registers used: 30 out of 35 (85.7%)

"ATmega88" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   4 add   :  14 adiw  :   0 and   :   0 
andi  :  42 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   4 break :   0 breq  :  17 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  17 brlt  :   0 brmi  :   0 
brne  :  23 brpl  :   0 brsh  :   6 brtc  :   2 brts  :   2 brvc  :   2 
brvs  :   0 bset  :   0 bst   :   0 cbi   :   0 cbr   :   1 clc   :   4 
clh   :   0 cli   :   0 cln   :   0 clr   :  30 cls   :   0 clt   :   2 
clv   :   4 clz   :   0 com   :   0 cp    :   8 cpc   :   0 cpi   :  30 
cpse  :   0 dec   :  24 eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 
icall :   0 ijmp  :   0 in    :  20 inc   :  15 ld    :  10 ldd   :   0 
ldi   : 149 lds   :  38 lpm   :   8 lsl   :   0 lsr   :   4 mov   :  55 
movw  :   4 mul   :   3 muls  :   0 mulsu :   0 neg   :   0 nop   :   4 
or    :   1 ori   :  29 out   :  22 pop   :  23 push  :  23 rcall : 119 
ret   :  49 reti  :   4 rjmp  :  29 rol   :   0 ror   :   4 sbc   :   0 
sbci  :   0 sbi   :   0 sbic  :   0 sbis  :   0 sbiw  :   0 sbr   :   2 
sbrc  :   1 sbrs  :   0 sec   :   2 seh   :   0 sei   :   1 sen   :   0 
ser   :   1 ses   :   0 set   :   2 sev   :   0 sez   :   0 sleep :   1 
spm   :   0 st    :  51 std   :   0 sts   :  59 sub   :  12 subi  :   4 
swap  :   0 tst   :   5 wdr   :   0 
Instructions used: 52 out of 111 (46.8%)

"ATmega88" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000980   2170    220   2390    8192  29.2%
[.dseg] 0x000100 0x00017a      0    122    122    1024  11.9%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 3 warnings
