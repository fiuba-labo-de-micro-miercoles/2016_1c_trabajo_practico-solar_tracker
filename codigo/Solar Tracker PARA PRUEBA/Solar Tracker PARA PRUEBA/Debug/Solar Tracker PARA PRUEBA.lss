
AVRASM ver. 2.1.57  C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm Wed Jun 22 01:34:36 2016

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m88def.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(8): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m88def.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(9): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar_Tracker.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(10): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\avr_macros.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(163): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\ADC.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(164): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\PWM.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(165): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\SERIAL_PORT.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(166): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\DELAY.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(167): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\LIGHT.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(168): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\BATTERY.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(169): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\SOLAR_PANEL.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(170): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\LDRS.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(171): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MOTORS.inc'
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(172): Including file 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc'
                 
                 /*
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega88.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m88def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega88
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega88
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M88DEF_INC_
                 #define _M88DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega88
                 #pragma AVRPART ADMIN PART_NAME ATmega88
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x0a
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0A_0	= 0	; 
                 .equ	OCR0A_1	= 1	; 
                 .equ	OCR0A_2	= 2	; 
                 .equ	OCR0A_3	= 3	; 
                 .equ	OCR0A_4	= 4	; 
                 .equ	OCR0A_5	= 5	; 
                 .equ	OCR0A_6	= 6	; 
                 .equ	OCR0A_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - 
                 .equ	SE	= 0	; 
                 .equ	SM0	= 1	; 
                 .equ	SM1	= 2	; 
                 .equ	SM2	= 3	; 
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x04ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0003	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0004	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x0005	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x0006	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x0007	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0008	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0009	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x000a	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x000b	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x000c	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x000d	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x000e	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x000f	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0010	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0011	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0012	; USART Rx Complete
                 .equ	UDREaddr	= 0x0013	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0014	; USART Tx Complete
                 .equ	ADCCaddr	= 0x0015	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x0016	; EEPROM Ready
                 .equ	ACIaddr	= 0x0017	; Analog Comparator
                 .equ	TWIaddr	= 0x0018	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0019	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 26	; size in words
                 
                 #endif  /* _M88DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                  * Solar_Tracker.asm
                  *
                  *  Created: 08/06/2016 07:45:11 p.m.
                  *   Author: Agustn Picard, Joaquin Ulloa, Mauro Giordano
                  */ 
                 
                 .include "m88def.inc"   	;Incluye los nombres de los registros del micro
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega88.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m88def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega88
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega88
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M88DEF_INC_
                 #endif  /* _M88DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 .include "Solar_Tracker.inc"
                 
                 
                 	 Me parece mas comodo e intuitivo
                 	poner los registros y definiciones
                 		en un header general
                 
                 ******************************************/
                 .DSEG
                 .ORG SRAM_START
                 
                 ;--------------------HEADER DE LA LUZ-----------------------------------------------
                 .EQU	LIGHT_PIN					=	PD3
                 ;-----------------------------------------------------------------------------------
                 
                 
                 ;--------------------HEADER DEL ADC-------------------------------------------------
                 .DEF	ADC_DATA_L					=	R19
                 .DEF	ADC_DATA_H					=	R20
                 
                 .EQU	ADC_BATTERY					=	6		;LA BATERIA ESTA EN EL PIN 19 [ADC6]
                 .EQU	ADC_SOLAR_PANEL				=	7		;EL PANEL ESTA EN EL PIN 22 [ADC7]
                 ;-----------------------------------------------------------------------------------
                 
                 
                 ;--------------------HEADER DEL PUERTO SERIE----------------------------------------
                 .EQU	BAUD_RATE					=	103	; 12	76.8 kbps e=0.2%	@8MHz y U2X=1
                 											; 25	38.4 kbps e=0.2%	@8MHz y U2X=1
                 											; 51	19.2 kbps e=0.2% 	@8MHz y U2X=1
                 											; 103	9600 bps  e=0.2% 	@8MHz y U2X=1
                 
                 .EQU	BUF_SIZE					=	 64	;tamao en bytes del buffer de transmisin
                 
                 ;SERIE DE COMANDOS DE RECEPCION POR BT
                 .EQU	BT_COMMAND_PROJECT_NAME			=	'q'
                 .EQU	BT_COMMAND_V_BAT				=	'w'
                 .EQU	BT_COMMAND_V_PANEL				=	'e'
                 .EQU	BT_COMMAND_LIGHT_TURN_ON		=	'r'
                 .EQU	BT_COMMAND_LIGHT_TURN_OFF		=	't'
                 .EQU	BT_COMMAND_MANUAL_LIGHT_OFF		=	'y'
                 .EQU	BT_COMMAND_ELEVATION_NORTH		=	'u'
                 .EQU	BT_COMMAND_ELEVATION_SOUTH		=	'i'
                 .EQU	BT_COMMAND_AZIMUT_EAST			=	'o'
                 .EQU	BT_COMMAND_AZIMUT_WEST			=	'p'
                 .EQU	BT_COMMAND_RESET				=	'z'
                 .EQU	BT_COMMAND_MANUAL_MOTORS_OFF	=	'l'
                 
000100           TX_BUF:	.BYTE	BUF_SIZE	; buffer de transmisin
                 
                 .DEF	PTR_TX_L					=	R8		;puntero al buffer de datos a transmitir
                 .DEF	PTR_TX_H					=	R9
                 .DEF	BYTES_A_TX					=	R10 	;nro. de bytes a transmitir desde el buffer
                 ;-----------------------------------------------------------------------------------
                 
                 ;--------------------------------HEADER DE LA BATERIA-------------------------------
                 .EQU	PIN_BATTERY_LED_OK			=	PD4
                 .EQU	PIN_BATTERY_LED_LOW			=	PD7
                 
                 .EQU	MIN_BATTERY_VALUE			=	170		;{0,255} RESULTADO DEL ADC QUE HACE IR A BAJO CONSUMO EL EQUIPO POR NO TENER SUFICIENTE TENSION
                 										;YA ESTA AJUSTADO! 10.6v
000140           V_BATTERY_DATA:		.BYTE 8			;[DECENA,UNIDAD,'.',DECIMAL,'V','\r','\n',0]
                 ;-----------------------------------------------------------------------------------
                 
                 ;-------------------------------HEADER DEL PANEL SOLAR------------------------------
                 .EQU	PIN_SOLAR_PANEL_LED_OK		=	PC1
                 .EQU	PIN_SOLAR_PANEL_LED_LOW		=	PC0
                 
                 .EQU	MIN_SOLAR_PANEL_VALUE		=	30	;{0,255} RESULTADO DEL ADC QUE DECIDE SI ES DE DIA O NOCHE.
                 										;FALTA AJUSTAR CON EL SOL! .... O CON LO QUE VAMOS A MOSTRAR!
000148           V_SOLAR_PANEL_DATA: .BYTE 8			;[DECENA,UNIDAD,'.',DECIMAL,'V','\r','\n',0]
                 ;-----------------------------------------------------------------------------------
                 
                 ;--------------------REGISTROS DE USO GENERAL SIN IMPORTAR QUE TENGA----------------
                 .DEF	AUX							=	R16
                 .DEF	AUX1						=	R17
                 .DEF	AUX2						=	R18
                 .DEF	AUX3						=	R22
                 .DEF	AUX4						=	R23
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DE LDRS---------------------------------------
                 .EQU CANT_SAMPLES = 8 ;TIENE QUE SER MULTIPLO DE 2
                 
000150           LDR_NO_BUFFER:						.BYTE CANT_SAMPLES
000158           LDR_NE_BUFFER:						.BYTE CANT_SAMPLES
000160           LDR_SE_BUFFER:						.BYTE CANT_SAMPLES
000168           LDR_SO_BUFFER:						.BYTE CANT_SAMPLES
000170           LDR_NO_MEAN:						.BYTE 1
000171           LDR_NE_MEAN:						.BYTE 1
000172           LDR_SE_MEAN:						.BYTE 1
000173           LDR_SO_MEAN:						.BYTE 1
000174           COUNTER:							.BYTE 2
000176           BT_MANUAL_LIGHT:					.BYTE 1				;[FLAG=0xFF]: SE MANEJA MANUAL. [FLAG=0x00]: SE MANEJA AUTOMATICO.
000177           BT_MANUAL_MOTORS:					.BYTE 1				;[FLAG=0xFF]: SE MANEJA MANUAL. [FLAG=0x00]: SE MANEJA AUTOMATICO.
000178           FLAG_AT_NIGHT:						.BYTE 1
                 
                 ;LAS CONSTANTES SON PARA EL MUX EN EL ADC
                 .EQU LDR_NO							=	3	;ADC2
                 .EQU LDR_NE							=	2	;ADC3
                 .EQU LDR_SE							=	4	;ADC4
                 .EQU LDR_SO							=	5	;ADC5		NO USAR EL ADC5 PARA COMPARAR! FUERA DE ESCALA LA RESISTENCIA DEL LDR
                 
                 .DEF LDR_NO_LOW						=	R2
                 .DEF LDR_NO_HIGH					=	R3
                 .DEF LDR_NE_LOW						=	R4
                 .DEF LDR_NE_HIGH					=	R5
                 .DEF LDR_SE_LOW						=	R6
                 .DEF LDR_SE_HIGH					=	R7
                 .DEF LDR_SO_LOW						=	R11
                 .DEF LDR_SO_HIGH					=	R12
                 
                 
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DEL PWM---------------------------------------
                 .DEF PWM_DATA					 	=	R21
                 
                 .EQU PWM_AZIMUT_DEFAULT				=	190		;{0,255} PARA SETEAR EL PWM
                 .EQU PWM_ELEVATION_DEFAULT			=	190		;{0,255} PARA SETEAR EL PWM
                 										;200 ES 10V APROX.
                 
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------HEADER DE MOTORES------------------------------------
                 
                 .EQU MOT_1							=	PD5
                 .EQU MOT_2							=	PD6
                 
                 ;-----------------------------------------------------------------------------------
                 .include "avr_macros.inc"	;Incluye los macros
                 
                 ; coleccin de macros para microcontroladores AVR
                 ;------------------------------------------------------------------
                 ; Sintaxis:
                 ; 	.macro NOMBRE_MACRO
                 ; 		; cuerpo de la macro
                 ;		; los parmetros de la macro se referencian como
                 ;		; @0 (1er parmetro), @1 (2do parmetro), etc.
                 ; 	.endm
                 ;------------------------------------------------------------------
                 
                 ;------------------------------------------------------------------
                 ; input: resuelve si usa "in"/"lds" segn la direccin del registro
                 ;        de E/S que se lee.
                 ;------------------------------------------------------------------
                 .macro	input ; @0= destino {r0, ... , r31}
                               ; @1= fuente I/0 ($0000-$FFFF)
                 .if	@1<0x40
                 	in	@0,@1	; si dir del reg de E/S <0x40 uso "in"
                 .else
                 	lds	@0,@1	; sino uso "lds"
                 .endif
                 .endm
                 
                 ;------------------------------------------------------------------
                 ; output: resuelve si usa "out"/"sts" segn la direccin del registro
                 ;         de E/S que se escribe.
                 ;------------------------------------------------------------------
                 .macro	output		; @0= destino I/O ($0000-$FFFF)
                 			; @1= fuente, cte o r0..r31
                 .if	@0<0x40
                 		out	@0,@1	; si dir del reg de E/S <0x40 uso "out"
                 .else
                 		sts	@0,@1	; sino uso "sts"
                 .endif
                 .endm
                 
                 .macro	ldiw		; carga puntero
                 		ldi	@0L, LOW(@1)
                 		ldi	@0H, HIGH(@1)
                 .endm
                 
                 .macro	movi	; carga registro con constante
                 		ldi	AUX,@1
                 		mov	@0,AUX
                 .endm
                 
                 .macro	outi
                 		ldi		AUX,@1
                 		output	@0,AUX  ;FIGURABA R16!!!!! OJO!
                 .endm
                 
                 
                 .macro	pushw	;@0		; Pone el puntero @0 de 16 bits en la pila
                 		push	@0L
                 		push	@0H
                 .endm
                 
                 
                 .macro	popw	;@0		; Saca el puntero @0 de 16 bits de la pila
                 		pop		@0H
                 		pop		@0L
                 .endm
                 
                 
                 .macro	pushi	;@0			; Pone en pila un registro de I/O
                 			in		AUX,@0	; usa la variable auxiliar t0
                 			push	AUX
                 .endm
                 
                 
                 .macro	popi	;@0			; Saca de pila un registro de I/O
                 			pop		AUX		; usa la variable auxiliar t0
                 			out		@0,AUX
                 .endm
                 
                 .macro	sti		;@0,@1	; Guarda una constante de modo indirecto
                 		ldi		AUX4,@1	; Usa: variable auxiliar "t0" y un puntero
                 		st		@0,AUX4	; [3 ciclos, 2 words] @0={X, Y, Z}
                 .endm
                 
                 .macro	stsi	;@0,@1	; Guarda una constante en SRAM
                 		ldi		AUX,@1	; Usa: variable auxiliar "t0".
                 		sts		@0,AUX	; [3 ciclos, 2 words] @0={any SRAM ADDRESS}
                 .endm
                 
                 ;---------------------MACROS PROPIAS-----------------------------------------------
                 .macro SLDR
                 ;STORE_LDR
                 ;PROTOTYPE: SLDR LDR_XX_LOW,LDR_XX_HIGH,ADC_DATA_H
                 ;RECIBE: ADC_DATA_H EL VALOR DEL LDR
                 ;DEVUELVE: -
                 	MOV	ZL,@0
                 	MOV	ZH,@1	
                 	ST	Z+,@2
                 	MOV	@0,ZL
                 	MOV	@1,ZH
                 .endm
                 
                 .macro LLDR
                 ;LOAD_LDR_TO_POINTER
                 ;PROTOTYPE: LLDR Z,LDR_XX_LOW,LDR_XX_HIGH
                 	LDI @0L,@1
                 	LDI @0H,@2
                 .endm
                 
                 .macro VECTMEAN	;@0,@1,@2	;Calcula la media de un vector @0 de longitud @1 y guarda la media en @2
                 		PUSH		@1
                 		LD 		AUX3,@0+
                 		CLR		@2
                 		DEC		@1
                 		CLR		AUX2
                 loop_mean:
                 		CLV
                 		LD		AUX4,@0+
                 		ADD		AUX3,AUX4
                 		ADC		@2,AUX2
                 		DEC		@1
                 		BRNE		loop_mean
                 		LDI		AUX2,3
                 division:
                 		LSR		@2
                 		ROR		AUX3
                 		DEC		AUX2
                 		BRNE		division
                 		MOV		@2,AUX3
                 		POP		@1
                 .endm
                 
                 
                 .macro SPWM 
                 ;PROTOTYPE SET_PWM: SPWM OCRnx,PWM_DATA
                 ;RECIBE: OCRnx,PWM_DATA
                 ;DEVUELVE: .
                 	OUTPUT @0,@1
                 .endm
                 
                 .macro RPWM 
                 ;PROTOTYPE RESET_PWM: RPWM OCRnx
                 ;RECIBE: OCRnx
                 ;DEVUELVE: -
                 	CLR AUX
                 	OUTPUT @0,AUX
                 .endm
                 
                 .macro ADDI
                 ;PROTOTYPE ADDI: REG,CTE
                 ;RECIBE: REG,CTE
                 ;DEVUELVE: Suma de cte al registro
                 	LDI AUX4,@1
                 	ADD @0,AUX4
                 .endm
                 
                 .macro ADDP
                 ;PROTOTYPE ADDP: POINTER,REG
                 ;RECIBE: POINTER,REG
                 ;DEVUELVE: Pointer en posicin inicial + AUX
                 	ADD @0L,@1
                 	BRVC NO_POINTER_OV
                 	INC @0H
                 	SUB @1,@0L
                 	MOV @1,@0L
                 NO_POINTER_OV: NOP
                 .endm
                 .listmac					;Permite que se expandan las macros en el listado
                 
                 .CSEG
                 .ORG 0x0000
000000 c019      RJMP SETUP	
                 
                 .ORG	INT0addr
000001 c04f      RJMP	ISR_INT0
                 
                 .ORG	URXCaddr		; USART, Rx Complete
000012 c0fa      RJMP	ISR_RX_USART_COMPLETA
                 	
                 .ORG	UDREaddr		; USART Data Register Empty
000013 c162      RJMP	ISR_REG_USART_VACIO
                 
                 .ORG	OVF1addr
00000d c044      RJMP	ISR_TIMER_1_OV
                 
                 ;-------------------------------SETUP--------------------------------------------
                 .ORG	INT_VECTORS_SIZE
                 SETUP:
00001a ef0f      	LDI AUX,LOW(RAMEND)
00001b bf0d      	OUT SPL,AUX
00001c e004      	LDI	AUX,HIGH(RAMEND)
00001d bf0e      	OUT SPH,AUX
                 
00001e d149      	RCALL BT_MANUAL_LIGHT_OFF	;[FLAG=0xFF]: LA LUZ SE MANEJA MANUALMENTE. [FLAG=0x00]: LA LUZ SE MANEJA AUTOMATICAMENTE.
00001f d14f      	RCALL BT_MANUAL_MOTORS_OFF	;[FLAG=0xFF]: LOS MOTORES SE MANEJAN MANUALMENTE. [FLAG=0x00]: LOS MOTORES SE MANEJAN AUTOMATICAMENTE.
000020 d036      	RCALL FLAG_AT_NIGHT_OFF
000021 d20c      	RCALL BATTERY_INIT
000022 d27f      	RCALL SOLAR_PANEL_INIT
000023 d047      	RCALL ADC_INIT					;TIENE QUE ESTAR EN "ADC.inc"
                 
000024 d34d      	RCALL LDRS_INIT
000025 d098      	RCALL SERIAL_PORT_INIT			;TIENE QUE ESTAR EN "SERIAL_PORT.inc"
000026 d066      	RCALL PWM_INIT
000027 d40b      	RCALL MOTORS_INIT
000028 9478      	SEI
                 
                +
000029 efe6     +ldi ZL , LOW ( ( MSJ_PROJECT_NAME * 2 ) )
00002a e0f9     +ldi ZH , HIGH ( ( MSJ_PROJECT_NAME * 2 ) )
                 	LDIW	Z,(MSJ_PROJECT_NAME*2)
00002b d16b      	RCALL	TRANSMITIR_MENSAJE
00002c d1c2      	RCALL	DELAY_50ms
                 
00002d c000      RJMP MAIN
                 
                 ;-------------------------------PROGRAMA_PRINCIPAL-------------------------------
                 MAIN:
                 
                 	;MIDO LA BATERIA
00002e d217      		RCALL	READ_V_BATTERY					
00002f d22d      		RCALL	VBATTERY_TO_ASCII
000030 d219      		RCALL	CHECK_IF_BATTERY_MINIMUM		;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
000031 f098      		BRCS	SLEEP_MODE
000032 d224      		RCALL	INDICATE_BATTERY_OK
                 
                 /*		LDIW	Z,(MSJ_V_BAT*2)
                 		LDIW	Y,V_BATTERY_DATA
                 		RCALL	TRANSMITIR_TENSION	
                 		RCALL	DELAY_50ms
                 */
                 	;DIA O NOCHE?
000033 d286      		RCALL	READ_V_SOLAR_PANEL				;PARA VER SI ES DE DIA O NOCHE, MIDO LA TENSION DEL PANEL SOLAR.
000034 d2fa      		RCALL	VPANEL_TO_ASCII
000035 d288      		RCALL	CHECK_IF_SOLAR_PANEL_MINIMUM	;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
000036 f0e0      		BRCS	AT_NIGHT
000037 d293      		RCALL	INDICATE_SOLAR_PANEL_OK
000038 d1e7      		RCALL	LIGHT_TURN_OFF
000039 d01d      		RCALL	FLAG_AT_NIGHT_OFF
                 /*		LDIW	Z,(MSJ_V_PANEL*2)
                 		LDIW	Y,V_SOLAR_PANEL_DATA
                 		RCALL	TRANSMITIR_TENSION	
                 		RCALL	DELAY_50ms*/
                 ;SI ESTOY ACA YA TENGO BATERIA SUFICIENTE, ES DE DIA.
00003a d36a      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
00003b d1a1      		RCALL	DELAY_100us
00003c d368      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
00003d d19f      		RCALL	DELAY_100us
00003e d366      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
00003f d19d      		RCALL	DELAY_100us
000040 d364      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
000041 d19b      		RCALL	DELAY_100us
000042 d362      		RCALL	LDRS_READ						;LEE LOS LDR'S Y LOS MANDA A RAM.
000043 d385      		RCALL	LDRS_MEAN
                 
000044 d28c      		RCALL	ORIENTATE_SOLAR_PANEL			;HAY QUE RESOLVER ESTO TODAVIA.
                 
                 SLEEP_MODE:
000045 d015      		RCALL SLEEP_TIMER_INIT
                +
                +
                +.if SMCR < 0x40
000046 b703     +in AUX , SMCR
                +.else 
                +lds AUX , SMCR
                 		INPUT AUX,SMCR
000047 7f00      		ANDI AUX,((~((1<<SM2)|(1<<SM1)|(1<<SM0)|(1<<SE))))
000048 6001      		ORI AUX,((0<<SM2)|(0<<SM1)|(0<<SM0)|(1<<SE))	;SETEO EL MODO IDLE.
                +
                +
                +.if SMCR < 0x40
000049 bf03     +out SMCR , AUX
                +.else 
                +sts SMCR , AUX
                 		OUTPUT SMCR,AUX
00004a 9588      		SLEEP
00004b 0000      		NOP
                +
                +
                +.if SMCR < 0x40
00004c b703     +in AUX , SMCR
                +.else 
                +lds AUX , SMCR
                 		INPUT AUX,SMCR
00004d 7f0e      		ANDI AUX,(~(1<<SE))								;CUANDO SALGO DE SLEEP, PONGO SE=0.
00004e 6000      		ORI AUX,(0<<SE)
                +
                +
                +.if SMCR < 0x40
00004f bf03     +out SMCR , AUX
                +.else 
                +sts SMCR , AUX
                 		OUTPUT SMCR,AUX
000050 cfdd      RJMP MAIN
                 ;-----------------------------------------------------------------------------------
                 
                 ;------------------------------MAIN_FUNCTIONS---------------------------------------
                 ISR_INT0:
000051 9518      RETI
                 
                 ISR_TIMER_1_OV:
000052 9518      RETI
                 
                 AT_NIGHT:
000053 d1b1      		RCALL LIGHT_TURN_ON
000054 d271      		RCALL INDICATE_SOLAR_PANEL_LOW
000055 d48e      		RCALL RETURN_TO_ORIGIN
000056 cfee      	RJMP SLEEP_MODE
                 
                 FLAG_AT_NIGHT_OFF:
000057 2700      	CLR AUX
                +
                +
                +.if FLAG_AT_NIGHT < 0x40
                +out FLAG_AT_NIGHT , AUX
000058 9300 0178+.else 
                +sts FLAG_AT_NIGHT , AUX
                 	OUTPUT FLAG_AT_NIGHT,AUX
00005a 9508      RET
                 
                 /*------------NO LA UTILIZAMOS, YA QUE EN 'IDLE' SE DESPIERTA POR TRANSMISION BT.
                 INT_EXT_INIT:
                 		;SETEO EL PIN INT0 (PD2) COMO ENTRADA.
                 		INPUT	AUX,DDRD
                 		ANDI	AUX,(~(1<<PD2))
                 		OUTPUT	DDRD,AUX
                 
                 		;SETEO PARA QUE SALTE LA INT0 SI HAY CUALQUIER CAMBIO.
                 		ANDI	AUX,(~((1<<ISC00)|(1<<ISC01)))
                 		ORI		AUX,((1<<ISC00)|(0<<ISC01))		
                 		OUTPUT	EICRA,AUX
                 	
                 		;HABILITO LA INTERRUPCION INT0.
                 		INPUT	AUX,EIMSK
                 		ANDI	AUX,~((1<<INT0)|(1<<INT1))		
                 		ORI		AUX,((1<<INT0)|(0<<INT1))
                 		OUTPUT	EIMSK,AUX
                 RET
                 */
                 
                 SLEEP_TIMER_INIT:
00005b ee0e      			LDI	AUX,0xEE		;Pongo como valor inicial del timer 34286 para que cuando haga overflow haya contado (8E6)/256
                +
                +
                +.if TCNT1L < 0x40
                +out TCNT1L , AUX
00005c 9300 0084+.else 
                +sts TCNT1L , AUX
                 			OUTPUT TCNT1L,AUX
00005e e805      			LDI AUX,0x85
                +
                +
                +.if TCNT1H < 0x40
                +out TCNT1H , AUX
00005f 9300 0085+.else 
                +sts TCNT1H , AUX
                 			OUTPUT TCNT1H,AUX
000061 e004      			LDI AUX,(1<<CS12)|(0<<CS11)|(0<<CS10)		;Seteo el prescaler a 256
                +
                +
                +.if TCCR1B < 0x40
                +out TCCR1B , AUX
000062 9300 0081+.else 
                +sts TCCR1B , AUX
                 			OUTPUT TCCR1B,AUX
000064 e000      			LDI AUX,0
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , AUX
000065 9300 0080+.else 
                +sts TCCR1A , AUX
                 			OUTPUT TCCR1A,AUX
000067 e001      			LDI AUX,(1<<TOIE1)
                +
                +
                +.if TIMSK1 < 0x40
                +out TIMSK1 , AUX
000068 9300 006f+.else 
                +sts TIMSK1 , AUX
                 			OUTPUT TIMSK1,AUX
00006a 9508      RET
                 
                 .include "ADC.inc"
                 
                  * PRUEBA_ADC.asm
                  *
                  *  Created: 25/05/2016 04:10:33 a.m.
                  *   Author: MAU
                  *
                  *	ESTE PROGRAMA RECIBE POR ADC0 UN LDR Y MANDA POR LOS 4 LEDS
                  *	DE LA PLACA DEL CdR EL DATO.
                  *
                  */ 
                 
                 ; codigo
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 /*ISR_ADC_CONVERSION_COMPLETE:
                 		
                 		INPUT AUX,ADCSRA
                 		SBR AUX,ADIF
                 		OUTPUT ADCSRA,AUX
                 
                 		LDI AUX,PD7
                 		OUTPUT PORTD,AUX
                 	RETI
                 */
                 ;-------------------------------------------------------------------------
                 ;					CONVERSOR ANALOGICO-DIGITAL
                 ;-------------------------------------------------------------------------
                 
                 ADC_INIT:
                 ;ADMUX = REFS1 REFS0 ADLAR  MUX3 MUX2 MUX1 MUX0
                 ;INTERNAL VREF=VCC Y EL DATO AJUSTADO A IZQUIERDA! [ADCH:ADCL]. SE SELECCIONA POR DEFECTO EL CANAL ADC1 [LDR DE LA PLACA DE CdR MODIF]
00006b e634      	LDI ADC_DATA_L,((0<<REFS1)|(1<<REFS0)|(1<<ADLAR)|(0<<MUX3)|(1<<MUX2)|(0<<MUX1)|(0<<MUX0))
                +
                +
                +.if ADMUX < 0x40
                +out ADMUX , ADC_DATA_L
00006c 9330 007c+.else 
                +sts ADMUX , ADC_DATA_L
                 	OUTPUT ADMUX,ADC_DATA_L
                 ;ADCSRA = ADEN ADSC ADATE ADIF ADIE ADPS2 ADPS1 ADPS0		
                 ;SE HABILITA EL ADC, AUTO TRIGGER OFF, FLAG INTERRUPCION EN CERO, PRESCALER DIV POR 64 [trabaja en aprox 100Khz]
00006e e836      	LDI ADC_DATA_L,((1<<ADEN)|(0<<ADSC)|(0<<ADATE)|(0<<ADIF)|(0<<ADIE)|(1<<ADPS2)|(1<<ADPS1)|(0<<ADPS0))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , ADC_DATA_L
00006f 9330 007a+.else 
                +sts ADCSRA , ADC_DATA_L
                 	OUTPUT ADCSRA,ADC_DATA_L
                 
                 ;SETEAR ESTE REGISTRO PARA EL MODO DE AUTO TRIGGER
                 ;	LDI AUX,(0<<ADTS2)|(0<<ADTS1)|(0<<ADTS0)
                 ;	OUTPUT ADCSRB,AUX
                 
                 ;SE DESHABILITA LA PARTE DIGITAL INTERNA DEL PIN A UTILIZAR
                 ;HABILITO SOLO LOS LDRS
000071 e33c      	LDI ADC_DATA_L,((1<<ADC2D)|(1<<ADC3D)|(1<<ADC4D)|(1<<ADC5D))
                +
                +
                +.if DIDR0 < 0x40
                +out DIDR0 , ADC_DATA_L
000072 9330 007e+.else 
                +sts DIDR0 , ADC_DATA_L
                 	OUTPUT DIDR0,ADC_DATA_L
000074 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ADC_SELECT_INPUT:
                 ;ADMUX = REFS1 REFS0 ADLAR  MUX3 MUX2 MUX1 MUX0
                 ;RECIBE: EL VALOR DEL PIN A SELECCIONAR EN ADC_DATA_L
                 ;DEVUELVE: NADA
                +
                +
                +.if ADMUX < 0x40
                +in AUX , ADMUX
000075 9100 007c+.else 
                +lds AUX , ADMUX
                 	INPUT AUX,ADMUX
000077 7f00      	ANDI AUX,(~((1<<MUX3)|(1<<MUX2)|(1<<MUX1)|(1<<MUX0)))
000078 2b03      	OR AUX,ADC_DATA_L;NO HAY QUE HACER SHIFT
                +
                +
                +.if ADMUX < 0x40
                +out ADMUX , AUX
000079 9300 007c+.else 
                +sts ADMUX , AUX
                 	OUTPUT ADMUX,AUX
                 
00007b 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ADC_SIMPLE_CONVERSION:
                 ;RECIBE: -
                 ;DEVUELVE: RESULTADO DE LA CONVERSION EN ADC_DATA_H:ADC_DATA_L
                 
                +
                +
                +.if ADCSRA < 0x40
                +in AUX , ADCSRA
00007c 9100 007a+.else 
                +lds AUX , ADCSRA
                 	INPUT AUX,ADCSRA
00007e 6c00      	ORI AUX,((1<<ADEN)|(1<<ADSC))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , AUX
00007f 9300 007a+.else 
                +sts ADCSRA , AUX
                 	OUTPUT ADCSRA,AUX
                +
                +
                +.if ADCSRA < 0x40
                +in AUX , ADCSRA
000081 9100 007a+.else 
                +lds AUX , ADCSRA
                 L2:	INPUT AUX,ADCSRA
000083 fd06      	SBRC AUX,ADSC
000084 cffc      	RJMP L2
000085 770f      	ANDI AUX,(~(1<<ADEN))
                +
                +
                +.if ADCSRA < 0x40
                +out ADCSRA , AUX
000086 9300 007a+.else 
                +sts ADCSRA , AUX
                 	OUTPUT ADCSRA,AUX
                 
                +
                +
                +.if ADCL < 0x40
                +in ADC_DATA_L , ADCL
000088 9130 0078+.else 
                +lds ADC_DATA_L , ADCL
                 	INPUT ADC_DATA_L,ADCL
                +
                +
                +.if ADCH < 0x40
                +in ADC_DATA_H , ADCH
00008a 9140 0079+.else 
                +lds ADC_DATA_H , ADCH
                 	INPUT ADC_DATA_H,ADCH
                 
00008c 9508      RET
                 
                 /************************** EJEMPLO! ***********************************
                 EJEMPLO_CONVERSOR:
                 		INPUT AUX,ADCSRA
                 		ORI AUX,((1<<ADEN)|(1<<ADSC))
                 		OUTPUT ADCSRA,AUX
                 
                 ESPERO:	INPUT AUX,ADCSRA
                 		SBRC AUX,ADSC
                 		RJMP ESPERO
                 		ANDI AUX,(~(1<<ADEN))
                 		OUTPUT ADCSRA,AUX
                 ;SE INICIA LA CONVERSION [ADEN=1]Y SE ESPERA A QUE TERMINE [ADSC=1] ?? O ADIF ???
                 		INPUT AUX,ADCH
                 		CPI AUX,0x00		
                 		BREQ LED1
                 		CPI AUX,0x01		
                 		BREQ LED2
                 		CPI AUX,0x02		
                 		BREQ LED3
                 		CPI AUX,0x03		
                 		BREQ LED4	
                 
                 SIGO:	RCALL DELAY
                 		RJMP EJEMPLO_CONVERSOR
                 
                 .include "PWM.inc"
                 
                 ;* 	CODIGO PWM 
                 ;*
                 ;*  Created: 29/05/2016
                 ;*  Autor: Mauro Giordano, Agustin Picard, Joaqun Ulloa
                 ;*	
                 ;*	f_outPWM = f_clkIO / (prescaler * 256)
                 ;*	Configuracion Fast Pwm
                 ;*	
                 ;*****************************************************
                 .CSEG
                 PWM_INIT:
                 ;	RCALL PWM_INIT_0
00008d d002      	RCALL PWM_SOLAR_PANEL_INIT
00008e d01b      	RCALL PWM_LIGHT_INIT
                 ;COMENTO LA FUNCION ANTERIOR PORQUE VAMOS A USAR MOTORES DE CONTINUA PUESTOS EN OC1A Y OC1B QUE SON LOS DEL PUERTO B SOLAMENTE.
00008f 9508      RET
                 
                 /*PWM_INIT_0:
                 ;Se inicializan como salida los pines de PWM
                 	INPUT PWM_DATA,DDRD
                 	ANDI PWM_DATA,(~((1<<DDD5)|(1<<DDD6)))	;Mascara para tocar solo D5 Y D6
                 	ORI PWM_DATA,((1<<DDD5)|(1<<DDD6))
                 	OUTPUT DDRD,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM02=0 (por defecto), WGM01=1 y WGM00=1
                 	;Non-inverting mode: COM0A1=1 y COM0A0=0
                 	INPUT PWM_DATA,TCCR0A	;Timer/counter control register A
                 	ANDI PWM_DATA,(~((1<<WGM01)|(1<<WGM00)|(1<<COM0A1)|(1<<COM0A0)|(1<<COM0B1)|(1<<COM0B0)))
                 	ORI PWM_DATA,((1<<WGM01)|(1<<WGM00)|(1<<COM0A1)|(0<<COM0A0)|(1<<COM0B1)|(0<<COM0B0))	;fast PWM, non-inverting
                 	OUTPUT TCCR0A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                 	INPUT PWM_DATA,TCCR0B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
                 	ANDI PWM_DATA,(~((1<<CS00)|(1<<CS01)|(1<<CS02)))
                 	ORI PWM_DATA,((0<<CS00)|(1<<CS01)|(0<<CS02))	;Ver tabla prescalers al final del archivo
                 	OUTPUT TCCR0B,PWM_DATA
                 ;Se inicializa el pwm en cero
                 	CLR	AUX
                 	OUTPUT	OCR0A,AUX
                 	OUTPUT	OCR0B,AUX
                 RET
                 */
                 ;*****************************************************
                 
                 PWM_SOLAR_PANEL_INIT:
                 ;Se inicializan como salida los pines de PWM
                +
                +
                +.if DDRB < 0x40
000090 b154     +in PWM_DATA , DDRB
                +.else 
                +lds PWM_DATA , DDRB
                 	INPUT PWM_DATA,DDRB
000091 7f59      	ANDI PWM_DATA,(~((1<<DDB1)|(1<<DDB2)))	;Mascara para tocar solo B1 Y B2
000092 6056      	ORI PWM_DATA,((1<<DDB1)|(1<<DDB2))
                +
                +
                +.if DDRB < 0x40
000093 b954     +out DDRB , PWM_DATA
                +.else 
                +sts DDRB , PWM_DATA
                 	OUTPUT DDRB,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM02=0 (por defecto), WGM01=1 y WGM00=1
                 	;Non-inverting mode: COM0A1=1 y COM0A0=0
                 	;Descripcion de registros en seccion 15.9 (pag 106-112)
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000094 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000096 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
000097 6f51      	ORI PWM_DATA,((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
000098 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                +
                +
                +.if TCCR1B < 0x40
                +in PWM_DATA , TCCR1B
00009a 9150 0081+.else 
                +lds PWM_DATA , TCCR1B
                 	INPUT PWM_DATA,TCCR1B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
00009c 7e50      	ANDI PWM_DATA,(~((1<<WGM13)|(1<<WGM12)|(1<<CS10)|(1<<CS11)|(1<<CS12)))
00009d 605a      	ORI PWM_DATA,((0<<WGM13)|(1<<WGM12)|(0<<CS10)|(1<<CS11)|(0<<CS12))	;Prescaler = 8
                +
                +
                +.if TCCR1B < 0x40
                +out TCCR1B , PWM_DATA
00009e 9350 0081+.else 
                +sts TCCR1B , PWM_DATA
                 	OUTPUT TCCR1B,PWM_DATA
                 
0000a0 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
0000a1 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
0000a3 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                +
                +
                +.if OCR1AH < 0x40
                +out OCR1AH , AUX
0000a5 9300 0089+.else 
                +sts OCR1AH , AUX
                 	OUTPUT	OCR1AH,AUX
                +
                +
                +.if OCR1BH < 0x40
                +out OCR1BH , AUX
0000a7 9300 008b+.else 
                +sts OCR1BH , AUX
                 	OUTPUT	OCR1BH,AUX
0000a9 9508      RET
                 
                 ;*****************************************************
                 PWM_LIGHT_INIT:
                 ;Se inicializan como salida los pines de PWM
                 ;Se usa uno solo de los pines (para la luz), el otro es el MOSI, lo dejamos solo para programar
                +
                +
                +.if DDRD < 0x40
0000aa b15a     +in PWM_DATA , DDRD
                +.else 
                +lds PWM_DATA , DDRD
                 	INPUT PWM_DATA,DDRD
0000ab 7f57      	ANDI PWM_DATA,(~(1<<DDD3))	;Mascara para tocar solo D3
0000ac 6058      	ORI PWM_DATA,((1<<DDD3))
                +
                +
                +.if DDRD < 0x40
0000ad b95a     +out DDRD , PWM_DATA
                +.else 
                +sts DDRD , PWM_DATA
                 	OUTPUT DDRD,PWM_DATA
                 ;Se inicializan como Fast PWM y non-inverting mode
                 	;Fast PWM: WGM22=0 (por defecto), WGM21=1 y WGM20=1
                 	;Non-inverting mode: COM2A1=1 y COM2A0=0
                +
                +
                +.if TCCR2A < 0x40
                +in PWM_DATA , TCCR2A
0000ae 9150 00b0+.else 
                +lds PWM_DATA , TCCR2A
                 	INPUT PWM_DATA,TCCR2A	;Timer/counter control register A
0000b0 7c5c      	ANDI PWM_DATA,(~((1<<COM2B1)|(1<<COM2B0)|(1<<WGM20)|(1<<WGM21)))
0000b1 6253      	ORI PWM_DATA,((1<<COM2B1)|(0<<COM2B0)|(1<<WGM20)|(1<<WGM21))	;fast PWM, non-inverting
                +
                +
                +.if TCCR2A < 0x40
                +out TCCR2A , PWM_DATA
0000b2 9350 00b0+.else 
                +sts TCCR2A , PWM_DATA
                 	OUTPUT TCCR2A,PWM_DATA
                 ;Se inicializa el prescaler del PWM
                +
                +
                +.if TCCR2B < 0x40
                +in PWM_DATA , TCCR2B
0000b4 9150 00b1+.else 
                +lds PWM_DATA , TCCR2B
                 	INPUT PWM_DATA,TCCR2B	;Timer/counter control register B
                 	;hacer mascara de forma tal que los bits 0, 1, 2 no se toquen
0000b6 7f58      	ANDI PWM_DATA,(~((1<<CS20)|(1<<CS21)|(1<<CS22)))
0000b7 6052      	ORI PWM_DATA,((0<<CS20)|(1<<CS21)|(0<<CS22))	;Ver tabla prescalers al final del archivo
                +
                +
                +.if TCCR2B < 0x40
                +out TCCR2B , PWM_DATA
0000b8 9350 00b1+.else 
                +sts TCCR2B , PWM_DATA
                 	OUTPUT TCCR2B,PWM_DATA
                 
0000ba 2700      	CLR	AUX
                +
                +
                +.if OCR2B < 0x40
                +out OCR2B , AUX
0000bb 9300 00b4+.else 
                +sts OCR2B , AUX
                 	OUTPUT	OCR2B,AUX
                 
0000bd 9508      RET
                 
                 
                 
                 ;*****************************************************
                 
                 /*
                 ;PWM DE 16 BITS, RECIBE EL VALOR POR PWM_DATA_L Y PWM_DATA_L_H
                 PWM_MOTOR_ELEVACION_SET:	;EL DE ELEVACION ES PD5 [MOT_1]
                 	OUTPUT OCR1BL,PWM_DATA
                 	OUTPUT OCR1BH,PWM_DATA_H	
                 RET
                 
                 PWM_MOTOR_ELEVACION_RESET:	;EL DE ELEVACION ES PD6 [MOT_2]
                 	CLR PWM_DATA
                 	OUTPUT OCR1BL,PWM_DATA	
                 	OUTPUT OCR1BH,PWM_DATA_H	
                 RET
                 */
                 
                 ;*****************************************************
                 /*
                 CS22	CS21	CS20	Description
                 0 		0 		0 		No clock source (timer/counter stopped)
                 0 		0 		1 		clkT2S/(no prescaling)
                 0 		1 		0 		clkT2S/8 (from prescaler)
                 0 		1 		1 		clkT2S/32 (from prescaler)
                 1 		0 		0 		clkT2S/64 (from prescaler)
                 1 		0 		1 		clkT2S/128 (from prescaler)
                 1 		1 		0 		clkT2S/256 (from prescaler)
                 1 		1 		1 		clkT2S/1024 (from prescaler)
                 */
                 .include "SERIAL_PORT.inc"
                 
                  * PRUEBA_PUERTO_SERIE.asm
                  *
                  *  Created: 18/05/2016 07:33:17 p.m.
                  *   Author: MAU
                  */ 
                 
                 
                 ;-------------------------------------------------------------------------
                 ; codigo
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 SERIAL_PORT_INIT:
0000be 930f      		PUSH	AUX
0000bf 931f      		PUSH	AUX1
                +
0000c0 93af     +push XL
0000c1 93bf     +push XH
                 		PUSHW	X
                 	
0000c2 e000      		LDI		AUX,HIGH(BAUD_RATE)
                +
                +
                +.if UBRR0H < 0x40
                +out UBRR0H , AUX
0000c3 9300 00c5+.else 
                +sts UBRR0H , AUX
                 		OUTPUT		UBRR0H,AUX	; Velocidad de transmisin
0000c5 e607      		LDI		AUX,LOW(BAUD_RATE)
                +
                +
                +.if UBRR0L < 0x40
                +out UBRR0L , AUX
0000c6 9300 00c4+.else 
                +sts UBRR0L , AUX
                 		OUTPUT		UBRR0L,AUX	
                 		
0000c8 e002      		LDI		AUX,1<<U2X0		; Modo asinc., doble velocidad
                +
                +
                +.if UCSR0A < 0x40
                +out UCSR0A , AUX
0000c9 9300 00c0+.else 
                +sts UCSR0A , AUX
                 		OUTPUT		UCSR0A,AUX	
                 
                 		; Trama: 8 bits de datos, sin paridad y 1 bit de stop, 
0000cb e006      		LDI		AUX,(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(1<<UCSZ01)|(1<<UCSZ00)
                +
                +
                +.if UCSR0C < 0x40
                +out UCSR0C , AUX
0000cc 9300 00c2+.else 
                +sts UCSR0C , AUX
                 		OUTPUT		UCSR0C,AUX
                 
                 
                 		; Configura los terminales de TX y RX; y habilita
                 		; 	nicamente la int. de recepcin
0000ce e908      		LDI		AUX,(1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0)|(0<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
0000cf 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT		UCSR0B,AUX
                 
                +
0000d1 e000     +ldi AUX , LOW ( TX_BUF )
0000d2 2e80     +mov PTR_TX_L , AUX
                 		MOVI	PTR_TX_L,LOW(TX_BUF)	; inicializa puntero al 
                +
0000d3 e001     +ldi AUX , HIGH ( TX_BUF )
0000d4 2e90     +mov PTR_TX_H , AUX
                 		MOVI	PTR_TX_H,HIGH(TX_BUF)	; buffer de transmisin.
                 	
                +
0000d5 e0a0     +ldi XL , LOW ( TX_BUF )
0000d6 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF				; limpia BUF_SIZE posiciones 
0000d7 e410      		LDI		AUX1, BUF_SIZE			; del buffer de transmisin
0000d8 2700      		CLR		AUX
                 loop_limpia:
0000d9 930d      		ST		X+,AUX
0000da 951a      		DEC		AUX1
0000db f7e9      		BRNE	loop_limpia
                 					
0000dc 24aa      		CLR		BYTES_A_TX		; nada pendiente de transmisin
                 
                +
0000dd 91bf     +pop XH
0000de 91af     +pop XL
                 		POPW	X
0000df 911f      		POP		AUX1
0000e0 910f      		POP		AUX
0000e1 9508      RET
                 
                 ;-------------------------------------------------------------------------
                 ; RECEPCION: Interrumpe cada vez que se recibe un byte x RS232.
                 ;
                 ; Recibe:	UDR (byte de dato)
                 ; Devuelve: nada
                 ;-------------------------------------------------------------------------
                 _LIGHT_TURN_ON:
0000e2 2700      		CLR AUX
                +
                +
                +.if BT_MANUAL_LIGHT < 0x40
                +out BT_MANUAL_LIGHT , AUX
0000e3 9300 0176+.else 
                +sts BT_MANUAL_LIGHT , AUX
                 		OUTPUT BT_MANUAL_LIGHT,AUX
0000e5 d11f      		RCALL LIGHT_TURN_ON
0000e6 ef0f      		SER AUX
                +
                +
                +.if BT_MANUAL_LIGHT < 0x40
                +out BT_MANUAL_LIGHT , AUX
0000e7 9300 0176+.else 
                +sts BT_MANUAL_LIGHT , AUX
                 		OUTPUT BT_MANUAL_LIGHT,AUX
                +
0000e9 e6e0     +ldi ZL , LOW ( ( MSJ_LIGHT_ON * 2 ) )
0000ea e0fa     +ldi ZH , HIGH ( ( MSJ_LIGHT_ON * 2 ) )
                 		LDIW	Z,(MSJ_LIGHT_ON*2)
0000eb d0ab      		RCALL TRANSMITIR_MENSAJE
0000ec c03d      	RJMP SIGO
                 _LIGHT_TURN_OFF:
0000ed 2700      		CLR AUX
                +
                +
                +.if BT_MANUAL_LIGHT < 0x40
                +out BT_MANUAL_LIGHT , AUX
0000ee 9300 0176+.else 
                +sts BT_MANUAL_LIGHT , AUX
                 		OUTPUT BT_MANUAL_LIGHT,AUX
0000f0 d12f      		RCALL LIGHT_TURN_OFF
0000f1 ef0f      		SER AUX
                +
                +
                +.if BT_MANUAL_LIGHT < 0x40
                +out BT_MANUAL_LIGHT , AUX
0000f2 9300 0176+.else 
                +sts BT_MANUAL_LIGHT , AUX
                 		OUTPUT BT_MANUAL_LIGHT,AUX
                +
0000f4 e7e6     +ldi ZL , LOW ( ( MSJ_LIGHT_OFF * 2 ) )
0000f5 e0fa     +ldi ZH , HIGH ( ( MSJ_LIGHT_OFF * 2 ) )
                 		LDIW	Z,(MSJ_LIGHT_OFF*2)
0000f6 d0a0      		RCALL TRANSMITIR_MENSAJE
0000f7 d128      		RCALL LIGHT_TURN_OFF
0000f8 c031      	RJMP SIGO
                 CALL_PROJECT_NAME:
                +
0000f9 efe6     +ldi ZL , LOW ( ( MSJ_PROJECT_NAME * 2 ) )
0000fa e0f9     +ldi ZH , HIGH ( ( MSJ_PROJECT_NAME * 2 ) )
                 		LDIW	Z,(MSJ_PROJECT_NAME*2)
0000fb d09b      		RCALL TRANSMITIR_MENSAJE
0000fc c02d      	RJMP SIGO
                 CALL_V_BAT:
                +
0000fd e2e8     +ldi ZL , LOW ( ( MSJ_V_BAT * 2 ) )
0000fe e0fa     +ldi ZH , HIGH ( ( MSJ_V_BAT * 2 ) )
                 		LDIW	Z,(MSJ_V_BAT*2)
                +
0000ff e4c0     +ldi YL , LOW ( V_BATTERY_DATA )
000100 e0d1     +ldi YH , HIGH ( V_BATTERY_DATA )
                 		LDIW	Y,V_BATTERY_DATA
000101 d0b2      		RCALL TRANSMITIR_TENSION
000102 c027      	RJMP SIGO
                 CALL_V_PANEL:
                +
000103 e4e6     +ldi ZL , LOW ( ( MSJ_V_PANEL * 2 ) )
000104 e0fa     +ldi ZH , HIGH ( ( MSJ_V_PANEL * 2 ) )
                 		LDIW	Z,(MSJ_V_PANEL*2)
                +
000105 e4c8     +ldi YL , LOW ( V_SOLAR_PANEL_DATA )
000106 e0d1     +ldi YH , HIGH ( V_SOLAR_PANEL_DATA )
                 		LDIW	Y,V_SOLAR_PANEL_DATA
000107 d0ac      		RCALL TRANSMITIR_TENSION
000108 c021      	RJMP SIGO
                 _BT_MANUAL_LIGHT_OFF:
000109 d05e      		RCALL BT_MANUAL_LIGHT_OFF
00010a c01f      	RJMP SIGO
                 _BT_COMMAND_MANUAL_MOTORS_OFF:
00010b d063      		RCALL BT_MANUAL_MOTORS_OFF
00010c c01d      	RJMP SIGO
                 
                 ISR_RX_USART_COMPLETA:
                 
                +
                +
                +.if UDR0 < 0x40
                +in AUX , UDR0
00010d 9100 00c6+.else 
                +lds AUX , UDR0
                 		INPUT AUX,UDR0
                 
00010f 3701      		CPI AUX,BT_COMMAND_PROJECT_NAME
000110 f341      		BREQ CALL_PROJECT_NAME
                 
000111 3707      		CPI AUX,BT_COMMAND_V_BAT
000112 f351      		BREQ CALL_V_BAT
                 
000113 3605      		CPI AUX,BT_COMMAND_V_PANEL
000114 f371      		BREQ CALL_V_PANEL
                 
000115 3702      		CPI AUX,BT_COMMAND_LIGHT_TURN_ON
000116 f259      		BREQ _LIGHT_TURN_ON
                 
000117 3704      		CPI AUX,BT_COMMAND_LIGHT_TURN_OFF
000118 f2a1      		BREQ _LIGHT_TURN_OFF
                 
000119 3709      		CPI AUX,BT_COMMAND_MANUAL_LIGHT_OFF
00011a f371      		BREQ _BT_MANUAL_LIGHT_OFF
                 
00011b 360c      		CPI AUX,BT_COMMAND_MANUAL_MOTORS_OFF
00011c f371      		BREQ _BT_COMMAND_MANUAL_MOTORS_OFF
                 
00011d 360f      		CPI AUX,BT_COMMAND_AZIMUT_EAST
00011e f069      		BREQ _MOVE_AZIMUT_EAST
                 
00011f 3700      		CPI AUX,BT_COMMAND_AZIMUT_WEST
000120 f0d1      		BREQ _MOVE_AZIMUT_WEST
                 
000121 3705      		CPI AUX,BT_COMMAND_ELEVATION_NORTH
000122 f139      		BREQ _MOVE_ELEVATION_NORTH
                 
000123 3609      		CPI AUX,BT_COMMAND_ELEVATION_SOUTH
000124 f1a1      		BREQ _MOVE_ELEVATION_SOUTH
                 
000125 370a      		CPI AUX,BT_COMMAND_RESET
000126 f021      		BREQ _RESET
                 
                +
000127 e6e2     +ldi ZL , LOW ( ( MSJ_INVALID_COMMAND * 2 ) )
000128 e0fb     +ldi ZH , HIGH ( ( MSJ_INVALID_COMMAND * 2 ) )
                 		LDIW	Z,(MSJ_INVALID_COMMAND*2)
000129 d06d      		RCALL TRANSMITIR_MENSAJE
                 
00012a 9518      SIGO:  	RETI 
                 
                 _RESET:
00012b ceee      	RJMP SETUP
                 
                 _MOVE_AZIMUT_EAST:
00012c 2700      		CLR AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
00012d 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
                +
00012f e8ea     +ldi ZL , LOW ( ( MSJ_AZIMUT_EAST * 2 ) )
000130 e0fa     +ldi ZH , HIGH ( ( MSJ_AZIMUT_EAST * 2 ) )
                 		LDIW	Z,(MSJ_AZIMUT_EAST*2)
000131 d065      		RCALL TRANSMITIR_MENSAJE
000132 ed6c      		LDI	AUX3,220
000133 d310      		RCALL MOTOR_AZIMUT_EAST
000134 d0c5      		RCALL DELAY_500ms
000135 d0c4      		RCALL DELAY_500ms
000136 d379      		RCALL MOTOR_AZIMUT_OFF
000137 ef0f      		SER AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
000138 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
00013a cfef      	RJMP SIGO
                 _MOVE_AZIMUT_WEST:
00013b 2700      		CLR AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
00013c 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
                +
00013e eae8     +ldi ZL , LOW ( ( MSJ_AZIMUT_WEST * 2 ) )
00013f e0fa     +ldi ZH , HIGH ( ( MSJ_AZIMUT_WEST * 2 ) )
                 		LDIW	Z,(MSJ_AZIMUT_WEST*2)
000140 d056      		RCALL TRANSMITIR_MENSAJE
000141 eb6e      		LDI	AUX3,190
000142 d314      		RCALL MOTOR_AZIMUT_WEST
000143 d0b6      		RCALL DELAY_500ms
000144 d0b5      		RCALL DELAY_500ms
000145 d36a      		RCALL MOTOR_AZIMUT_OFF
000146 ef0f      		SER AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
000147 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
000149 cfe0      	RJMP SIGO
                 _MOVE_ELEVATION_NORTH:
00014a 2700      		CLR AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
00014b 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
                +
00014d ece6     +ldi ZL , LOW ( ( MSJ_ELEVATION_NORTH * 2 ) )
00014e e0fa     +ldi ZH , HIGH ( ( MSJ_ELEVATION_NORTH * 2 ) )
                 		LDIW	Z,(MSJ_ELEVATION_NORTH*2)
00014f d047      		RCALL TRANSMITIR_MENSAJE
000150 eb6e      		LDI	AUX3,190
000151 d33b      		RCALL MOTOR_ELEVATION_NORTH
000152 d0a7      		RCALL DELAY_500ms
000153 d0a6      		RCALL DELAY_500ms
000154 d375      		RCALL MOTOR_ELEVATION_OFF
000155 ef0f      		SER AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
000156 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
000158 cfd1      	RJMP SIGO
                 _MOVE_ELEVATION_SOUTH:
000159 2700      		CLR AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
00015a 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
                +
00015c eee4     +ldi ZL , LOW ( ( MSJ_ELEVATION_SOUTH * 2 ) )
00015d e0fa     +ldi ZH , HIGH ( ( MSJ_ELEVATION_SOUTH * 2 ) )
                 		LDIW	Z,(MSJ_ELEVATION_SOUTH*2)
00015e d038      		RCALL TRANSMITIR_MENSAJE
00015f eb6e      		LDI	AUX3,190
000160 d319      		RCALL MOTOR_ELEVATION_SOUTH
000161 d098      		RCALL DELAY_500ms
000162 d097      		RCALL DELAY_500ms
000163 d366      		RCALL MOTOR_ELEVATION_OFF
000164 ef0f      		SER AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
000165 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
000167 cfc2      	RJMP SIGO
                 
                 BT_MANUAL_LIGHT_OFF:
                +
000168 e0e0     +ldi ZL , LOW ( ( MSJ_MANUAL_LIGHT_OFF * 2 ) )
000169 e0fb     +ldi ZH , HIGH ( ( MSJ_MANUAL_LIGHT_OFF * 2 ) )
                 		LDIW	Z,(MSJ_MANUAL_LIGHT_OFF*2)
00016a d02c      		RCALL TRANSMITIR_MENSAJE
00016b 2700      		CLR AUX
                +
                +
                +.if BT_MANUAL_LIGHT < 0x40
                +out BT_MANUAL_LIGHT , AUX
00016c 9300 0176+.else 
                +sts BT_MANUAL_LIGHT , AUX
                 		OUTPUT BT_MANUAL_LIGHT,AUX 
00016e 9508      RET
                 
                 BT_MANUAL_MOTORS_OFF:
                +
00016f e2ee     +ldi ZL , LOW ( ( MSJ_MANUAL_MOTORS_OFF * 2 ) )
000170 e0fb     +ldi ZH , HIGH ( ( MSJ_MANUAL_MOTORS_OFF * 2 ) )
                 		LDIW	Z,(MSJ_MANUAL_MOTORS_OFF*2)
000171 d025      		RCALL TRANSMITIR_MENSAJE
000172 2700      		CLR AUX
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +out BT_MANUAL_MOTORS , AUX
000173 9300 0177+.else 
                +sts BT_MANUAL_MOTORS , AUX
                 		OUTPUT BT_MANUAL_MOTORS,AUX
000175 9508      RET
                 ;------------------------------------------------------------------------
                 
                 ;------------------------------------------------------------------------
                 ; TRANSMISION: interrumpe cada vez que puede transmitir un byte.
                 ; Se transmiten "BYTES_A_TX" comenzando desde la posicin TX_BUF del
                 ; buffer. Si "BYTES_A_TX" llega a cero, se deshabilita la interrupcin.
                 ;
                 ; Recibe: 	BYTES_A_TX.
                 ; Devuelve: PTR_TX_H:PTR_TX_L, y BYTES_A_TX.
                 ;------------------------------------------------------------------------
                 ISR_REG_USART_VACIO:		; UDR est vaco
000176 930f      		PUSH	AUX
000177 931f      		PUSH	AUX1
                +
000178 b70f     +in AUX , SREG
000179 930f     +push AUX
                 		PUSHI	SREG
                +
00017a 93af     +push XL
00017b 93bf     +push XH
                 		PUSHW	X
                 
                 
00017c 20aa      		TST		BYTES_A_TX	; hay datos pendientes de transmisin?
00017d f069      		BREQ	FIN_TRANSMISION
                 
00017e 01d4      		MOVW	XL,PTR_TX_L	; Recupera puntero al prximo byte a tx.
00017f 910d      		LD		AUX,X+		; lee byte del buffer y apunta al
                +
                +
                +.if UDR0 < 0x40
                +out UDR0 , AUX
000180 9300 00c6+.else 
                +sts UDR0 , AUX
                 		OUTPUT		UDR0,AUX		; sgte. dato a transmitir (en la prxima int.)
                 
000182 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
000183 f020      		BRLO	SALVA_PTR_TX
000184 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
000185 f010      		BRLO	SALVA_PTR_TX
                +
000186 e0a0     +ldi XL , LOW ( TX_BUF )
000187 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx=ptr_tx+1, (mdulo BUF_SIZE)
                 
                 SALVA_PTR_TX:
000188 014d      		MOVW	PTR_TX_L,XL	; preserva puntero a sgte. dato
                 
000189 94aa      		DEC		BYTES_A_TX	; Descuenta el nro. de bytes a tx. en 1
00018a f429      		BRNE	SIGUE_TX	; si quedan datos que transmitir
                 							;	vuelve en la prxima int.
                 ;REVISAR ESTE GRUPO DE INSTRUCCIONES
                 FIN_TRANSMISION:			; si no hay nada que enviar,
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
00018b 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
00018d 7d0f      		CBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
00018e 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 		;se deshabilita la interrupcin.
                 
                 sigue_tx:
                +
000190 91bf     +pop XH
000191 91af     +pop XL
                 		POPW	X
                +
000192 910f     +pop AUX
000193 bf0f     +out SREG , AUX
                 		POPI	SREG
000194 911f      		POP		AUX1
000195 910f      		POP		AUX
000196 9518      		RETI
                 
                 ;-------------------------------------------------------------------------
                 ; TRANSMITIR_MENSAJE: transmite el mensaje almacenado en memoria flash a partir
                 ; de la direccin APUNTADA POR Z! que termina con 0x00 (el 0 no se transmite).
                 ; Recibe: nada
                 ; Devuelve: PTR_TX_L|H, BYTES_A_TX.  
                 ; Habilita la int. de transmisin serie con ISR en ISR_REG_USART_VACIO().
                 ;-------------------------------------------------------------------------
                 TRANSMITIR_MENSAJE:
                +
000197 93ef     +push ZL
000198 93ff     +push ZH
                 		PUSHW	Z
                +
000199 93af     +push XL
00019a 93bf     +push XH
                 		PUSHW	X
00019b 930f      		PUSH	AUX
                 
00019c 01d4      		MOVW	XL,PTR_TX_L
                 
                 LOOP_TRANSMITIR_MENSAJE:
00019d 9105      		LPM		AUX,Z+
00019e 2300      		TST		AUX
00019f f049      		BREQ	FIN_TRANSMITIR_MENSAJE
                 
0001a0 930d      		ST		X+,AUX
0001a1 94a3      		INC		BYTES_A_TX
                 
0001a2 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
0001a3 f3c8      		BRLO	LOOP_TRANSMITIR_MENSAJE
0001a4 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
0001a5 f3b8      		BRLO	LOOP_TRANSMITIR_MENSAJE
                +
0001a6 e0a0     +ldi XL , LOW ( TX_BUF )
0001a7 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
0001a8 cff4      		RJMP	LOOP_TRANSMITIR_MENSAJE
                 	
                 FIN_TRANSMITIR_MENSAJE:
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
0001a9 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
                 
0001ab 6200      		SBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
0001ac 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 
0001ae 910f      		POP		AUX
                +
0001af 91bf     +pop XH
0001b0 91af     +pop XL
                 		POPW	X
                +
0001b1 91ff     +pop ZH
0001b2 91ef     +pop ZL
                 		POPW	Z
0001b3 9508      		RET
                 
                 ;-------------------------------------------------------------------------
                 ; fin del cdigo
                 ;-------------------------------------------------------------------------
                 
                 
                 TRANSMITIR_TENSION:
                +
0001b4 93ef     +push ZL
0001b5 93ff     +push ZH
                 		PUSHW	Z
                +
0001b6 93af     +push XL
0001b7 93bf     +push XH
                 		PUSHW	X
0001b8 930f      		PUSH	AUX
                 
0001b9 01d4      		MOVW	XL,PTR_TX_L
                 
                 LOOP_TRANSMITIR_TENSION:
0001ba 9105      		LPM		AUX,Z+
0001bb 2300      		TST		AUX
0001bc f049      		BREQ	LOOP_TRANSMITIR_DATO	;TERMINO DE MANDAR EL MENSAJE, AHORA MANDO EL DATO
                 
0001bd 930d      		ST		X+,AUX
0001be 94a3      		INC		BYTES_A_TX
                 
0001bf 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
0001c0 f3c8      		BRLO	LOOP_TRANSMITIR_TENSION
0001c1 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
0001c2 f3b8      		BRLO	LOOP_TRANSMITIR_TENSION
                +
0001c3 e0a0     +ldi XL , LOW ( TX_BUF )
0001c4 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
0001c5 cff4      		RJMP	LOOP_TRANSMITIR_TENSION
                 	
                 LOOP_TRANSMITIR_DATO:
0001c6 9109      		LD		AUX,Y+
0001c7 2300      		TST		AUX
0001c8 f049      		BREQ	FIN_TRANSMITIR_DATO
                 
0001c9 930d      		ST		X+,AUX
0001ca 94a3      		INC		BYTES_A_TX
                 
0001cb 34a0      		CPI		XL,LOW(TX_BUF+BUF_SIZE)
0001cc f3c8      		BRLO	LOOP_TRANSMITIR_DATO
0001cd 30b1      		CPI		XH,HIGH(TX_BUF+BUF_SIZE)
0001ce f3b8      		BRLO	LOOP_TRANSMITIR_DATO
                +
0001cf e0a0     +ldi XL , LOW ( TX_BUF )
0001d0 e0b1     +ldi XH , HIGH ( TX_BUF )
                 		LDIW	X,TX_BUF	; ptr_tx++ mdulo BUF_SIZE
                 
0001d1 cff4      		RJMP	LOOP_TRANSMITIR_DATO
                 	
                 FIN_TRANSMITIR_DATO:
                +
                +
                +.if UCSR0B < 0x40
                +in AUX , UCSR0B
0001d2 9100 00c1+.else 
                +lds AUX , UCSR0B
                 		INPUT	AUX,UCSR0B
                 
0001d4 6200      		SBR		AUX,(1<<UDRIE0)
                +
                +
                +.if UCSR0B < 0x40
                +out UCSR0B , AUX
0001d5 9300 00c1+.else 
                +sts UCSR0B , AUX
                 		OUTPUT	UCSR0B,AUX
                 
0001d7 910f      		POP		AUX
                +
0001d8 91bf     +pop XH
0001d9 91af     +pop XL
                 		POPW	X
                +
0001da 91ff     +pop ZH
0001db 91ef     +pop ZL
                 		POPW	Z
                 .include "DELAY.inc"
0001dc 9508      
                 ;		Para crear los delays, no te hagas el crack y
                 ;		us el bocho de alguien que ya lo pens:
                 ;		http://www.bretmulvey.com/avrdelay.html
                 ;
                 ;		TENER EN CUENTA QUE EL MICRO TRABAJA A 8MHZ
                 ;
                 ;***********************************************************
                 .CSEG
                 
                 DELAY_100us:
0001dd e002          ldi  AUX, 2
0001de e019          ldi  AUX1, 9
0001df 951a      L4: dec  AUX1
0001e0 f7f1          brne L4
0001e1 950a          dec  AUX
0001e2 f7e1          brne L4
0001e3 9508      RET
                 
                 DELAY_25ms:
0001e4 e022          ldi  r18, 2
0001e5 e034          ldi  r19, 4
0001e6 eb4b          ldi  r20, 187
0001e7 954a      L5: dec  r20
0001e8 f7f1          brne L5
0001e9 953a          dec  r19
0001ea f7e1          brne L5
0001eb 952a          dec  r18
0001ec f7d1          brne L5
0001ed 0000          nop
0001ee 9508      RET
                 
                 DELAY_50ms:
                 
0001ef e003          ldi  AUX, 3
0001f0 e018          ldi  AUX1, 8
0001f1 e728          ldi  AUX2, 120
0001f2 952a      L1: dec  AUX2
0001f3 f7f1          brne L1
0001f4 951a          dec  AUX1
0001f5 f7e1          brne L1
0001f6 950a          dec  AUX
0001f7 f7d1          brne L1
0001f8 9508      RET
                 
                 DELAY_LO_QUE_SE_ME_ANTOJE:
                 
                 ;ABRI EL PROGRAMA Y LISTO.
                 ;HACER PUSH Y POP DE LOS REGS QUE SE USEN
                 
0001f9 9508      RET
                 
                 DELAY_500ms:
0001fa e105          ldi  AUX, 21
0001fb e41b          ldi  AUX1, 75
0001fc eb2f          ldi  AUX2, 191
0001fd 952a      L3: dec  AUX2
0001fe f7f1          brne L3
0001ff 951a          dec  AUX1
000200 f7e1          brne L3
000201 950a          dec  AUX
000202 f7d1          brne L3
000203 0000          nop
                 .include "LIGHT.inc"
000204 9508      
                 *	LIGHT.inc [COMO SI FUERA UN OBJETO]
                 *
                 *  Created: 01/06/2016 13:10:11 p.m.
                 *   Author: MAU
                 */ 
                 .CSEG
                 ;FUTURA MEJORA: HACER QUE LA LUZ SE MUEVA POR PWM EN FUNCION DE LA CARGA DE LA BATERIA
                 LIGHT_TURN_ON:
                +
                +
                +.if BT_MANUAL_LIGHT < 0x40
                +in AUX , BT_MANUAL_LIGHT
000205 9100 0176+.else 
                +lds AUX , BT_MANUAL_LIGHT
                 	INPUT AUX,BT_MANUAL_LIGHT
000207 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: LA LUZ SE MANEJA MANUAL.
000208 f0b1      	BREQ ORDEN_BT_NO_TOCAR_LUZ		;[FLAG=0x00]: LA LUZ SE MANEJA AUTOMATICA.
                 
                +
                +
                +.if TCCR2A < 0x40
                +in PWM_DATA , TCCR2A
000209 9150 00b0+.else 
                +lds PWM_DATA , TCCR2A
                 	INPUT PWM_DATA,TCCR2A	;Timer/counter control register A
00020b 7c5c      	ANDI PWM_DATA,(~((1<<COM2B1)|(1<<COM2B0)|(1<<WGM20)|(1<<WGM21)))
00020c 6253      	ORI PWM_DATA,((1<<COM2B1)|(0<<COM2B0)|(1<<WGM20)|(1<<WGM21))	;fast PWM, non-inverting
                +
                +
                +.if TCCR2A < 0x40
                +out TCCR2A , PWM_DATA
00020d 9350 00b0+.else 
                +sts TCCR2A , PWM_DATA
                 	OUTPUT TCCR2A,PWM_DATA
                 
00020f d036      	RCALL READ_V_BATTERY
000210 e604      	LDI AUX,100
000211 3e46      	CPI	ADC_DATA_H,230
000212 f420      	BRSH EXC_CHARGE
000213 3a4a      	CPI	ADC_DATA_H,170
000214 f420      	BRSH GOOD_CHARGE
000215 3946      	CPI	ADC_DATA_H,150
000216 f420      	BRSH BAD_CHARGE
                 EXC_CHARGE:
                +
                +
                +
                +
000217 e372     +LDI AUX4 , 50
000218 0f07     +ADD AUX , AUX4
                 	ADDI AUX,50
                 GOOD_CHARGE:
                +
                +
                +
                +
000219 e372     +LDI AUX4 , 50
00021a 0f07     +ADD AUX , AUX4
                 	ADDI AUX,50
                 BAD_CHARGE:
                +
                +
                +
                +
00021b e377     +LDI AUX4 , 55
00021c 0f07     +ADD AUX , AUX4
                 	ADDI AUX,55
                +
                +
                +.if OCR2B < 0x40
                +out OCR2B , AUX
00021d 9300 00b4+.else 
                +sts OCR2B , AUX
                 	OUTPUT OCR2B,AUX
                 
                 ;	SER AUX
                 ;	OUTPUT OCR2B,AUX
                 /*
                 	RCALL READ_V_SOLAR_PANEL
                 	CPI	ADC_DATA_H,230
                 	BRSH EXC_SUN
                 	CPI	ADC_DATA_H,170
                 	BRSH GOOD_SUN
                 	CPI	ADC_DATA_H,150
                 	BRSH BAD_SUN
                 BAD_SUN:
                 	ADDI AUX,50
                 GOOD_SUN:
                 	ADDI AUX,50
                 EXC_SUN:
                 	ADDI AUX,55
                 	OUTPUT OCR2B,AUX
                 */
                 ORDEN_BT_NO_TOCAR_LUZ:
00021f 9508      RET
                 
                 LIGHT_TURN_OFF:
                +
                +
                +.if BT_MANUAL_LIGHT < 0x40
                +in AUX , BT_MANUAL_LIGHT
000220 9100 0176+.else 
                +lds AUX , BT_MANUAL_LIGHT
                 	INPUT AUX,BT_MANUAL_LIGHT
000222 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: LA LUZ SE MANEJA MANUAL. 
000223 f3d9      	BREQ ORDEN_BT_NO_TOCAR_LUZ			;[FLAG=0x00]: LA LUZ SE MANEJA AUTOMATICA.
                 
                +
                +
                +.if TCCR2A < 0x40
                +in PWM_DATA , TCCR2A
000224 9150 00b0+.else 
                +lds PWM_DATA , TCCR2A
                 	INPUT PWM_DATA,TCCR2A	;Timer/counter control register A
000226 7c5c      	ANDI PWM_DATA,(~((1<<COM2B1)|(1<<COM2B0)|(1<<WGM20)|(1<<WGM21)))
000227 6053      	ORI PWM_DATA,((0<<COM2B1)|(0<<COM2B0)|(1<<WGM20)|(1<<WGM21))	;fast PWM, non-inverting
                +
                +
                +.if TCCR2A < 0x40
                +out TCCR2A , PWM_DATA
000228 9350 00b0+.else 
                +sts TCCR2A , PWM_DATA
                 	OUTPUT TCCR2A,PWM_DATA
                 
00022a 2700      	CLR AUX
                +
                +
                +.if OCR2B < 0x40
                +out OCR2B , AUX
00022b 9300 00b4+.else 
                +sts OCR2B , AUX
                 	OUTPUT OCR2B,AUX
                 .include "BATTERY.inc"
00022d 9508      
                 ;
                 ;							BATTERY.inc
                 ;
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 BATTERY_INIT:
                +
                +
                +.if DDRD < 0x40
00022e b10a     +in AUX , DDRD
                +.else 
                +lds AUX , DDRD
                 	INPUT AUX,DDRD
00022f 760f      	ANDI AUX,(~((1<<DDD4)|(1<<DDD7)))	;Mascara para tocar solo D3
000230 6900      	ORI AUX,((1<<DDD4)|(1<<DDD7))
                +
                +
                +.if DDRD < 0x40
000231 b90a     +out DDRD , AUX
                +.else 
                +sts DDRD , AUX
                 	OUTPUT DDRD,AUX
000232 d01f      	RCALL INDICATE_BATTERY_LOW
                 
                 	;INICIALIZO LA INFORMACION DE LA TENSION PARA TRANSMITIR POR BLUETOOTH
                +
000233 e4a0     +ldi XL , LOW ( V_BATTERY_DATA )
000234 e0b1     +ldi XH , HIGH ( V_BATTERY_DATA )
                 	LDIW X,V_BATTERY_DATA
                +
000235 e370     +ldi AUX4 , '0'
000236 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
000237 e370     +ldi AUX4 , '0'
000238 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
000239 e27e     +ldi AUX4 , '.'
00023a 937d     +st X + , AUX4
                 	STI	X+,'.'
                +
00023b e370     +ldi AUX4 , '0'
00023c 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
00023d e576     +ldi AUX4 , 'V'
00023e 937d     +st X + , AUX4
                 	STI	X+,'V'
                +
00023f e07d     +ldi AUX4 , '\r'
000240 937d     +st X + , AUX4
                 	STI X+,'\r'
                +
000241 e07a     +ldi AUX4 , '\n'
000242 937d     +st X + , AUX4
                 	STI X+,'\n'
                +
000243 e070     +ldi AUX4 , 0
000244 937c     +st X , AUX4
                 	STI	X,0
                 
000245 9508      RET
                 
                 READ_V_BATTERY:
000246 e036      		LDI ADC_DATA_L,ADC_BATTERY			;ELIJO EL PIN DE LA BATERA
000247 de2d      		RCALL ADC_SELECT_INPUT				;LLAMO LA FUNCION PARA SELECCIONAR LA BATERIA
000248 de33      		RCALL ADC_SIMPLE_CONVERSION			;LLAMO LA FUNCION PARA MEDIR
000249 9508      RET
                 
                 CHECK_IF_BATTERY_MINIMUM:
00024a 9488      	CLC
00024b 3a4a      	CPI		ADC_DATA_H,MIN_BATTERY_VALUE	;COMPARAR PARA VER SI HAY SUFICIENTE BATERIA PARA OPERAR
00024c f010      	BRCS	_INDICATE_BATTERY_LOW						;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
00024d d009      	RCALL INDICATE_BATTERY_OK
                 	
                 RETURN_INDICATE_BATTERY_LOW:
00024e 9508      RET
                 
                 _INDICATE_BATTERY_LOW:
00024f d002      	RCALL INDICATE_BATTERY_LOW
000250 9408      	SEC										;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
000251 cffc      RJMP RETURN_INDICATE_BATTERY_LOW
                 
                 INDICATE_BATTERY_LOW:
                +
                +
                +.if PORTD < 0x40
000252 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT	AUX,PORTD
000253 760f      	ANDI	AUX,(~((1<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW)))
000254 6100      	ORI		AUX,((1<<PIN_BATTERY_LED_OK)|(0<<PIN_BATTERY_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTD < 0x40
000255 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT	PORTD,AUX
000256 9508      RET
                 
                 INDICATE_BATTERY_OK:
                +
                +
                +.if PORTD < 0x40
000257 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT	AUX,PORTD
000258 760f      	ANDI	AUX,(~((1<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW)))
000259 6800      	ORI		AUX,((0<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTD < 0x40
00025a b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT	PORTD,AUX
00025b 9488      	CLC										;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
00025c 9508      RET
                 
                 
                 VBATTERY_TO_ASCII:
                 
                +
00025d e4a0     +ldi XL , LOW ( V_BATTERY_DATA )
00025e e0b1     +ldi XH , HIGH ( V_BATTERY_DATA )
                 					LDIW X,V_BATTERY_DATA
                +
00025f eae6     +ldi ZL , LOW ( ( VBATTERY_DIG_TABLE * 2 ) )
000260 e0fb     +ldi ZH , HIGH ( ( VBATTERY_DIG_TABLE * 2 ) )
                 VBATTERY_DIG:		LDIW Z,(VBATTERY_DIG_TABLE*2)
000261 2711      					CLR AUX1
000262 2722      					CLR AUX2
                 LOOP_DIG_BATTERY:			
000263 d032      					RCALL SET_VBATTERY_DIG
000264 f056      					BRTS V_BATTERY_DEC
000265 9513      					INC AUX1
000266 301a      					CPI AUX1,10
000267 f010      					BRLO LOWER_THAN_10_DIG_BATTERY
000268 2711      					CLR AUX1
000269 9523      					INC AUX2
00026a f7c6      LOWER_THAN_10_DIG_BATTERY: BRTC LOOP_DIG_BATTERY
                +
00026b e371     +ldi AUX4 , 48 + 1
00026c 937d     +st X + , AUX4
                 					STI X+,48+1
                +
00026d e375     +ldi AUX4 , 48 + 5
00026e 937d     +st X + , AUX4
                 					STI X+,48+5
                 
                +
00026f eae6     +ldi ZL , LOW ( ( VBATTERY_DIG_TABLE * 2 ) )
000270 e0fb     +ldi ZH , HIGH ( ( VBATTERY_DIG_TABLE * 2 ) )
                 V_BATTERY_DEC:		LDIW Z,(VBATTERY_DIG_TABLE*2)
000271 5310      					SUBI AUX1,48
000272 5320      					SUBI AUX2,48
000273 e06a      					LDI AUX3,10
000274 9f26      					MUL AUX2,AUX3
000275 2d20      					MOV AUX2,R0
000276 0f12      					ADD AUX1,AUX2
                +
                +
                +
                +
000277 0fe1     +ADD ZL , AUX1
000278 f41b     +BRVC NO_POINTER_OV
000279 95f3     +INC ZH
00027a 1b1e     +SUB AUX1 , ZL
00027b 2f1e     +MOV AUX1 , ZL
00027c 0000     +NO_POINTER_OV : NOP
                 					ADDP Z,AUX1
00027d 9114      					LPM AUX1,Z
00027e 1b14      					SUB AUX1,ADC_DATA_H	;ACA AUX1 TIENE QUE ESTAR ENTRE 0 Y 15
                 	
                 
                +
00027f e27e     +ldi AUX4 , '.'
000280 937d     +st X + , AUX4
                 					STI	X+,'.'
000281 ea20      					ldi	aux2,160		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
000282 9f12      					MUL	AUX1,AUX2
000283 2d11      					MOV	AUX1,R1
000284 1b61      					SUB AUX3,AUX1					
                +
                +
                +
                +
000285 e370     +LDI AUX4 , 48
000286 0f67     +ADD AUX3 , AUX4
                 					ADDI AUX3,48		;SE TRANSFORMA EN ASCII
000287 336a      					CPI AUX3,':'
000288 f059      					BREQ ajuste_9_bat
                 
000289 936d      vuelvo_9_bat:		ST X+,AUX3	;El ASCII del nmero en AUX.
                +
00028a e576     +ldi AUX4 , 'V'
00028b 937d     +st X + , AUX4
                 					STI	X+,'V'
                +
00028c e07d     +ldi AUX4 , '\r'
00028d 937d     +st X + , AUX4
                 					STI X+,'\r'
                +
00028e e07a     +ldi AUX4 , '\n'
00028f 937d     +st X + , AUX4
                 					STI X+,'\n'
                +
000290 e070     +ldi AUX4 , 0
000291 937c     +st X , AUX4
                 					STI	X,0
000292 94e8      					CLT
000293 9508      RET	
                 
                 ajuste_9_bat:
000294 e369      		ldi aux3,'9'
000295 cff3      		rjmp vuelvo_9_bat
                 		
                 SET_VBATTERY_DIG:
000296 9105      					LPM AUX,Z+
000297 9503      					INC AUX
000298 1740      					CP ADC_DATA_H,AUX
000299 f438      					BRSH END_SET_VBATTERY_DIG
                +
                +
                +
                +
00029a e370     +LDI AUX4 , 48
00029b 0f17     +ADD AUX1 , AUX4
                 					ADDI AUX1,48
                +
                +
                +
                +
00029c e370     +LDI AUX4 , 48
00029d 0f27     +ADD AUX2 , AUX4
                 					ADDI AUX2,48
00029e 932d      					ST X+,AUX2
00029f 931d      					ST X+,AUX1
0002a0 9468      					SET
0002a1 9508      END_SET_VBATTERY_DIG:	RET
                 
                 
                 
                 /*
                 MAURO:
                 V_BATTERY_TO_ASCII:
                 
                 .DEF UNIDAD		= R17		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 .DEF DECENA		= R18		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 .DEF DECIMAL	= R22		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
                 
                 	PUSH UNIDAD
                 	PUSH DECENA
                 	PUSH DECIMAL
                 	PUSH ADC_DATA_H
                 
                 	CLR	UNIDAD
                 	CLR DECENA
                 	CLR DECIMAL
                 
                 		TST	ADC_DATA_H
                 		BREQ NULO
                 START:	CLC
                 		SUBI ADC_DATA_H,16
                 		BRCS OOB
                 		CPI ADC_DATA_H,16
                 		BRLO PASSED
                 		BREQ dec_0
                 		inc	unidad
                 		cpi unidad,10
                 		breq acomodo
                 		RJMP START
                 
                 OOB:	NEG ADC_DATA_H
                 
                 PASSED:	ldi	aux1,160		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
                 		MUL	ADC_DATA_H,AUX1
                 		MOV	ADC_DATA_H,R1
                 dec_0:	MOV	decimal,ADC_DATA_H
                 	
                 NULO:
                 		LDIW	Z,V_BATTERY_DATA
                 SUBIR_DECENA:
                 	ADDI	DECENA,48
                 	ST	Z+,DECENA
                 
                 SUBIR_UNIDAD:
                 	ADDI	UNIDAD,48
                 	ST	Z+,UNIDAD
                 
                 SUBIR_PUNTO:
                 	STI		Z+,'.'
                 
                 SUBIR_DECIMAL:
                 	ADDI	DECIMAL,48
                 	ST	Z+,DECIMAL
                 
                 SUBIR_FINAL:
                 	STI		Z+,'V'
                 	STI		Z+,'\r'
                 	STI		Z+,'\n'
                 	STI		Z,0
                 
                 	POP ADC_DATA_H
                 	POP	DECIMAL
                 	POP DECENA
                 	POP UNIDAD
                 RET	
                 
                 ACOMODO:
                 	CLR UNIDAD
                 	INC DECENA
                 RJMP START
                 .include "SOLAR_PANEL.inc"
                 
                 ;
                 ;							SOLAR_PANEL.inc
                 ;				
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 SOLAR_PANEL_INIT:
                +
                +
                +.if DDRC < 0x40
0002a2 b107     +in AUX , DDRC
                +.else 
                +lds AUX , DDRC
                 	INPUT AUX,DDRC
0002a3 7f0c      	ANDI AUX,(~((1<<DDC0)|(1<<DDC1)))	;Mascara para tocar los leds del panel solar
0002a4 6003      	ORI AUX,((1<<DDC0)|(1<<DDC1))
                +
                +
                +.if DDRC < 0x40
0002a5 b907     +out DDRC , AUX
                +.else 
                +sts DDRC , AUX
                 	OUTPUT DDRC,AUX
0002a6 d01f      	RCALL INDICATE_SOLAR_PANEL_LOW
                 	;INICIALIZO LA INFORMACION DE LA TENSION PARA TRANSMITIR POR BLUETOOTH
                +
0002a7 e4a8     +ldi XL , LOW ( V_SOLAR_PANEL_DATA )
0002a8 e0b1     +ldi XH , HIGH ( V_SOLAR_PANEL_DATA )
                 	LDIW X,V_SOLAR_PANEL_DATA
                +
0002a9 e370     +ldi AUX4 , '0'
0002aa 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0002ab e370     +ldi AUX4 , '0'
0002ac 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0002ad e27e     +ldi AUX4 , '.'
0002ae 937d     +st X + , AUX4
                 	STI	X+,'.'
                +
0002af e370     +ldi AUX4 , '0'
0002b0 937d     +st X + , AUX4
                 	STI	X+,'0'
                +
0002b1 e576     +ldi AUX4 , 'V'
0002b2 937d     +st X + , AUX4
                 	STI	X+,'V'
                +
0002b3 e07d     +ldi AUX4 , '\r'
0002b4 937d     +st X + , AUX4
                 	STI X+,'\r'
                +
0002b5 e07a     +ldi AUX4 , '\n'
0002b6 937d     +st X + , AUX4
                 	STI X+,'\n'
                +
0002b7 e070     +ldi AUX4 , 0
0002b8 937c     +st X , AUX4
                 	STI	X,0
                 
0002b9 9508      RET
                 ;-------------------------------------------------------------------------
                 
                 READ_V_SOLAR_PANEL:
                 ;RECIBE: NADA
                 ;DEVUELVE: TENSION DEL PANEL EN ADC_DATA_H
0002ba e037      	LDI ADC_DATA_L,ADC_SOLAR_PANEL			;ELIJO EL PIN DEL PANEL SOLAR
0002bb ddb9      	RCALL ADC_SELECT_INPUT					;LLAMO LA FUNCION PARA SELECCIONAR EL PANEL SOLAR
0002bc ddbf      	RCALL ADC_SIMPLE_CONVERSION				;LLAMO LA FUNCION PARA MEDIR
0002bd 9508      RET
                 
                 CHECK_IF_SOLAR_PANEL_MINIMUM:
0002be 9488      	CLC
0002bf 314e      	CPI		ADC_DATA_H,MIN_SOLAR_PANEL_VALUE	;COMPARAR PARA VER SI HAY SUFICIENTE SOL.
0002c0 f010      	BRCS	_INDICATE_SOLAR_PANEL_LOW						;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
0002c1 d009      	RCALL INDICATE_SOLAR_PANEL_OK
                 	
                 RETURN_INDICATE_SOLAR_PANEL_LOW:
0002c2 9508      RET
                 
                 _INDICATE_SOLAR_PANEL_LOW:
0002c3 d002      	RCALL INDICATE_SOLAR_PANEL_LOW
0002c4 9408      	SEC										;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
0002c5 cffc      RJMP RETURN_INDICATE_SOLAR_PANEL_LOW
                 
                 INDICATE_SOLAR_PANEL_LOW:
                +
                +
                +.if PORTC < 0x40
0002c6 b108     +in AUX , PORTC
                +.else 
                +lds AUX , PORTC
                 	INPUT	AUX,PORTC
0002c7 7f0c      	ANDI	AUX,(~((1<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW)))
0002c8 6002      	ORI		AUX,((1<<PIN_SOLAR_PANEL_LED_OK)|(0<<PIN_SOLAR_PANEL_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTC < 0x40
0002c9 b908     +out PORTC , AUX
                +.else 
                +sts PORTC , AUX
                 	OUTPUT	PORTC,AUX
0002ca 9508      RET
                 
                 INDICATE_SOLAR_PANEL_OK:
                +
                +
                +.if PORTC < 0x40
0002cb b108     +in AUX , PORTC
                +.else 
                +lds AUX , PORTC
                 	INPUT	AUX,PORTC
0002cc 7f0c      	ANDI	AUX,(~((1<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW)))
0002cd 6001      	ORI		AUX,((0<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW))		;PRENDE POR CERO.
                +
                +
                +.if PORTC < 0x40
0002ce b908     +out PORTC , AUX
                +.else 
                +sts PORTC , AUX
                 	OUTPUT	PORTC,AUX
0002cf 9488      	CLC										;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
0002d0 9508      RET
                 ;-------------------------------------------------------------------------
                 
                 ORIENTATE_SOLAR_PANEL:
0002d1 ddbe      		RCALL PWM_SOLAR_PANEL_INIT					;TIENE QUE ESTAR EN "PWM.inc"
                 ;YA ESTAN LOS PROMEDIOS DE LOS LDR Y HAY QUE COMPARAR Y MOVER EL PANEL.
                 ;PRIMERO EN ASIMUT, LUEGO EN ELEVACION.
                 ;EL SOL SALE DEL ESTE Y SE PONE EN EL OESTE.
                 	;SI AMBOS SON 0xFn NO SE MUEVE
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002d2 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 	INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
0002d4 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 	INPUT AUX1,LDR_NE_MEAN
0002d6 7f00      	ANDI	AUX,0xF0
0002d7 7f10      	ANDI	AUX1,0xF0
0002d8 3f00      	CPI		AUX,0xF0
0002d9 f411      	BRNE	NO_SON_F_AZIMUT
0002da 1b01      	SUB		AUX,AUX1
0002db f081      	BREQ	AMBOS_SON_F_AZIMUT
                 NO_SON_F_AZIMUT:
                 	;COMPARAR_NO_NE:			;ACA TENGO QUE HACER EL PROMEDIO DE (NO+SO)/2 = NO/2 + SO/2. HAGO LO ULTIMO ASI NO HAY OVERFLOW.
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002dc 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN	
                 		;INPUT AUX2,LDR_SO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
0002de 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 		INPUT AUX1,LDR_NE_MEAN
                 		;INPUT AUX3,LDR_SE_MEAN
                 		;LSR AUX
                 		;LSR AUX2				;DIVIDO POR 2 ANTES DE SUMARLOS
                 		;LSR AUX1
                 		;LSR AUX3
                 		;ADD AUX,AUX2			;PROMEDIO DE NO Y SO.
                 		;ADD AUX1,AUX3			;PROMEDIO DE NE Y SE.
0002e0 7f00      		ANDI	AUX,0xF0
0002e1 7f10      		ANDI	AUX1,0xF0
0002e2 1701      		CP AUX,AUX1
0002e3 f118      		BRLO _MOTOR_AZIMUT_EAST
                 	RETURN_MOTOR_AZIMUT_EAST:
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002e4 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +in AUX1 , LDR_NE_MEAN
0002e6 9110 0171+.else 
                +lds AUX1 , LDR_NE_MEAN
                 		INPUT AUX1,LDR_NE_MEAN
0002e8 7f00      		ANDI	AUX,0xF0
0002e9 7f10      		ANDI	AUX1,0xF0
0002ea 1710      		CP AUX1,AUX
0002eb f128      		BRLO _MOTOR_AZIMUT_WEST
                 	RETURN_MOTOR_AZIMUT_WEST:
                 AMBOS_SON_F_AZIMUT:
                 
                 ;--------------------ACA NOS MOVEMOS CON NORTE Y SUR
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002ec 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 	INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
0002ee 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 	INPUT AUX1,LDR_SO_MEAN
0002f0 7f00      	ANDI	AUX,0xF0
0002f1 7f10      	ANDI	AUX1,0xF0
0002f2 3f00      	CPI		AUX,0xF0
0002f3 f411      	BRNE	NO_SON_F_ELEVATION
0002f4 1b01      	SUB		AUX,AUX1
0002f5 f081      	BREQ	AMBOS_SON_F_ELEVATION
                 NO_SON_F_ELEVATION:
                 	;COMPARAR_NO_SO:
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002f6 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                 	;INPUT AUX2,LDR_NE_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
0002f8 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 		INPUT AUX1,LDR_SO_MEAN
                 	;INPUT AUX3,LDR_SE_MEAN
                 	;LSR AUX				;DIVIDO POR 2 ANTES DE SUMARLOS
                 	;LSR AUX2
                 	;LSR AUX1
                 	;LSR AUX3
                 	;ADD AUX,AUX2			;PROMEDIO DE NO Y NE.
                 	;ADD AUX1,AUX3			;PROMEDIO DE SO Y SE.
0002fa 7f00      		ANDI	AUX,0xF0
0002fb 7f10      		ANDI	AUX1,0xF0
0002fc 1701      		CP AUX,AUX1
0002fd f138      		BRLO _MOTOR_ELEVATION_NORTH
                 	RETURN_MOTOR_ELEVATION_NORTH:
                 
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +in AUX , LDR_NO_MEAN
0002fe 9100 0170+.else 
                +lds AUX , LDR_NO_MEAN
                 		INPUT AUX,LDR_NO_MEAN
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +in AUX1 , LDR_SO_MEAN
000300 9110 0173+.else 
                +lds AUX1 , LDR_SO_MEAN
                 		INPUT AUX1,LDR_SO_MEAN
000302 7f00      		ANDI	AUX,0xF0
000303 7f10      		ANDI	AUX1,0xF0
000304 1710      		CP AUX1,AUX
000305 f0a8      		BRLO _MOTOR_ELEVATION_SOUTH
                 	RETURN_MOTOR_ELEVATION_SOUTH:
                 AMBOS_SON_F_ELEVATION:
000306 9508      RET
                 ;-------------------------------------------------------------------------
                 
                 _MOTOR_AZIMUT_EAST:
000307 1b01      	SUB AUX,AUX1
000308 6800      	ORI	AUX,0x80
000309 2f60      	MOV	AUX3,AUX
                 
00030a d139      	RCALL MOTOR_AZIMUT_EAST
00030b dee3      		RCALL DELAY_50ms
00030c dee2      		RCALL DELAY_50ms
00030d dee1      		RCALL DELAY_50ms
00030e dee0      		RCALL DELAY_50ms
00030f d1a0      	RCALL MOTOR_AZIMUT_OFF
                 	;	RCALL DELAY_500ms
000310 cfd3      RJMP RETURN_MOTOR_AZIMUT_EAST
                 
                 _MOTOR_AZIMUT_WEST:
000311 1b10      	SUB AUX1,AUX
000312 6810      	ORI	AUX1,0x80
000313 2f61      	MOV	AUX3,AUX1
                 
000314 d142      	RCALL MOTOR_AZIMUT_WEST
000315 ded9      		RCALL DELAY_50ms
000316 ded8      		RCALL DELAY_50ms
000317 ded7      		RCALL DELAY_50ms
000318 ded6      		RCALL DELAY_50ms
000319 d196      	RCALL MOTOR_AZIMUT_OFF
00031a cfd1      RJMP RETURN_MOTOR_AZIMUT_WEST
                 
                 
                 _MOTOR_ELEVATION_SOUTH:
00031b 1b10      	SUB AUX1,AUX
00031c 6a1f      	ORI	AUX1,0xAF
00031d 2f61      	MOV	AUX3,AUX1
                 
00031e d15b      	RCALL MOTOR_ELEVATION_SOUTH
00031f decf      		RCALL DELAY_50ms
000320 dece      		RCALL DELAY_50ms
000321 decd      		RCALL DELAY_50ms
000322 decc      		RCALL DELAY_50ms
000323 d1a6      	RCALL MOTOR_ELEVATION_OFF
000324 cfe1      RJMP RETURN_MOTOR_ELEVATION_SOUTH
                 
                 _MOTOR_ELEVATION_NORTH:
000325 1b10      	SUB AUX1,AUX
000326 6a1f      	ORI	AUX1,0xAF
000327 2f61      	MOV	AUX3,AUX1
                 
000328 d164      	RCALL MOTOR_ELEVATION_NORTH
000329 dec5      		RCALL DELAY_50ms
00032a dec4      		RCALL DELAY_50ms
00032b dec3      		RCALL DELAY_50ms
00032c dec2      		RCALL DELAY_50ms
00032d d19c      	RCALL MOTOR_ELEVATION_OFF
00032e cfcf      RJMP RETURN_MOTOR_ELEVATION_NORTH
                 ;-------------------------------------------------------------------------
                 
                 VPANEL_TO_ASCII:
                +
00032f e4a8     +ldi XL , LOW ( V_SOLAR_PANEL_DATA )
000330 e0b1     +ldi XH , HIGH ( V_SOLAR_PANEL_DATA )
                 				LDIW X,V_SOLAR_PANEL_DATA	;Apunto X a la seccin de memoria donde se guarda la tensin a panel a transmitir
                +
000331 e8e6     +ldi ZL , LOW ( VPANEL_DIG_TABLE * 2 )
000332 e0fb     +ldi ZH , HIGH ( VPANEL_DIG_TABLE * 2 )
                 				LDIW Z,VPANEL_DIG_TABLE*2	;Apunto Z a la seccin de ROM donde se delimita cada unidad
000333 2711      VPANEL_DIG:		CLR AUX1					;Ac se guardar el x1
000334 2722      				CLR AUX2					;Ac se guardar el x10
                 LOOP_DIG_PANEL:			
000335 d030      				RCALL SET_VPANEL_DIG		;Busco el nmero
000336 f056      				BRTS V_PANEL_DEC
000337 9513      				INC AUX1					;Incremento para ver si es el siguiente en el prox ciclo
000338 301a      				CPI AUX1,10					;Veo si super 10 para ver si tengo que poner el x10 en 1
000339 f010      				BRLO LOWER_THAN_10_DIG_PANEL;Si no super 10, sigo el ciclo
00033a 2711      				CLR AUX1					;Si es 10, x1 es 0
00033b 9523      				INC AUX2					;Si es 10, x10 es 1
00033c f7c6      LOWER_THAN_10_DIG_PANEL:	BRTC LOOP_DIG_PANEL
                +
00033d e371     +ldi AUX4 , 48 + 1
00033e 937d     +st X + , AUX4
                 				STI X+,48+1					;Si se completaron todos los ciclos, el x10 es 1
                +
00033f e379     +ldi AUX4 , 48 + 9
000340 937d     +st X + , AUX4
                 				STI X+,48+9					;Si se completaron todos los ciclos, el x1 es 9
                +
000341 e8e6     +ldi ZL , LOW ( VPANEL_DIG_TABLE * 2 )
000342 e0fb     +ldi ZH , HIGH ( VPANEL_DIG_TABLE * 2 )
                 V_PANEL_DEC:	LDIW Z,VPANEL_DIG_TABLE*2	;Vuelvo a apuntar Z al comienzo de la tabla donde estn los nmeros que delimitan cada unidad
000343 5310      				SUBI AUX1,48				;Lo vuelvo a convertir en nmero no ASCII
000344 5320      				SUBI AUX2,48
000345 e06a      				LDI AUX3,10					;Cargo 10 en AUX3 para multiplicar el x10 por 10 y poder sumarselo al x1
000346 9f26      				MUL AUX2,AUX3				;Multiplico el x10 por 10
000347 2d20      				MOV AUX2,R0					;Paso el resultado de R0 a AUX2
000348 0f12      				ADD AUX1,AUX2				;Sumo x1 y x10 para tener el nmero completo
                +
                +
                +
                +
000349 0fe1     +ADD ZL , AUX1
00034a f41b     +BRVC NO_POINTER_OV
00034b 95f3     +INC ZH
00034c 1b1e     +SUB AUX1 , ZL
00034d 2f1e     +MOV AUX1 , ZL
00034e 0000     +NO_POINTER_OV : NOP
                 				ADDP Z,AUX1					;Le sumo al puntero Z la cantidad de posiciones que se tiene que mover en la tabla para ver el nmero mximo que puede tener esa unidad
00034f 9114      				LPM AUX1,Z					;Cargo el nmero delimitador
000350 1b14      				SUB AUX1,ADC_DATA_H			;Le resto al delimitador el nmero que med
                +
000351 e27e     +ldi AUX4 , '.'
000352 937d     +st X + , AUX4
                 				STI	X+,'.'
000353 ed22      				ldi	aux2,210		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
000354 9f12      				MUL	AUX1,AUX2
000355 2d11      				MOV	AUX1,R1
000356 1b61      				SUB AUX3,AUX1					
                +
                +
                +
                +
000357 e27f     +LDI AUX4 , 48 - 1
000358 0f67     +ADD AUX3 , AUX4
                 				ADDI AUX3,48-1		;SE TRANSFORMA EN ASCII
                 
000359 936d      vuelvo_9_panel:	ST X+,AUX3	;El ASCII del nmero en AUX.
                +
00035a e576     +ldi AUX4 , 'V'
00035b 937d     +st X + , AUX4
                 				STI	X+,'V'
                +
00035c e07d     +ldi AUX4 , '\r'
00035d 937d     +st X + , AUX4
                 				STI X+,'\r'
                +
00035e e07a     +ldi AUX4 , '\n'
00035f 937d     +st X + , AUX4
                 				STI X+,'\n'
                +
000360 e070     +ldi AUX4 , 0
000361 937c     +st X , AUX4
                 				STI	X,0
000362 94e8      				CLT
000363 9508      RET
                 
                 ajuste_9_panel:
000364 e369      				ldi aux3,'9'
000365 cff3      				rjmp vuelvo_9_panel
                 	
                 SET_VPANEL_DIG:
000366 9105      					LPM AUX,Z+				;Leo de tabla en ROM
000367 9503      					INC AUX					;Incremento lo ledo porque se usar BRSH
000368 1740      					CP ADC_DATA_H,AUX		;Veo si el nmero es menor al de la tabla a ver si encontramos el valor
000369 f438      					BRSH END_SET_VPANEL_DIG	;Si es mayor o igual, sigo buscando
                 											;ESTO NO ES LO QUE QUERES HACER
                +
                +
                +
                +
00036a e370     +LDI AUX4 , 48
00036b 0f17     +ADD AUX1 , AUX4
                 					ADDI AUX1,48			;Le sumo 48 al nmero porque los nmeros en ASCII comienzan a partir de 48
                +
                +
                +
                +
00036c e370     +LDI AUX4 , 48
00036d 0f27     +ADD AUX2 , AUX4
                 					ADDI AUX2,48
00036e 932d      					ST X+,AUX2				;Guardo el x10
00036f 931d      					ST X+,AUX1				;Guardo el x1
000370 9468      					SET
                 .include "LDRS.inc"
000371 9508      
                 ;
                 ;						HEADER DE LOS LDR'S
                 ;			NO USAR EL ADC5 PARA COMPARAR! FUERA DE ESCALA
                 ;------------------------------------------------------------------
                 .CSEG
                 
                 LDRS_INIT:
000372 d01e      		RCALL LDRS_POINTERS_RESET
000373 2744      LOOP:	CLR ADC_DATA_H
                +
                +
                +
                +
                +
000374 2de2     +MOV ZL , LDR_NO_LOW
000375 2df3     +MOV ZH , LDR_NO_HIGH
000376 9341     +ST Z + , ADC_DATA_H
000377 2e2e     +MOV LDR_NO_LOW , ZL
000378 2e3f     +MOV LDR_NO_HIGH , ZH
                 		SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
000379 2deb     +MOV ZL , LDR_SO_LOW
00037a 2dfc     +MOV ZH , LDR_SO_HIGH
00037b 9341     +ST Z + , ADC_DATA_H
00037c 2ebe     +MOV LDR_SO_LOW , ZL
00037d 2ecf     +MOV LDR_SO_HIGH , ZH
                 		SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
00037e 2de6     +MOV ZL , LDR_SE_LOW
00037f 2df7     +MOV ZH , LDR_SE_HIGH
000380 9341     +ST Z + , ADC_DATA_H
000381 2e6e     +MOV LDR_SE_LOW , ZL
000382 2e7f     +MOV LDR_SE_HIGH , ZH
                 		SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H
                +
                +
                +
                +
                +
000383 2de4     +MOV ZL , LDR_NE_LOW
000384 2df5     +MOV ZH , LDR_NE_HIGH
000385 9341     +ST Z + , ADC_DATA_H
000386 2e4e     +MOV LDR_NE_LOW , ZL
000387 2e5f     +MOV LDR_NE_HIGH , ZH
                 		SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
000388 9100 0174+.else 
                +lds AUX , COUNTER
                 		INPUT AUX,COUNTER
00038a 9503      		INC AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
00038b 9300 0174+.else 
                +sts COUNTER , AUX
                 		OUTPUT COUNTER,AUX
00038d 3008      		CPI AUX,CANT_SAMPLES			;CHEQUEAR QUE NO ESTE HACIENDO UNO DE MENOS
00038e f320      		BRLO LOOP
00038f d001      		RCALL LDRS_POINTERS_RESET
000390 9508      RET
                 
                 LDRS_POINTERS_RESET:
                +
000391 e500     +ldi AUX , LOW ( LDR_NO_BUFFER )
000392 2e20     +mov LDR_NO_LOW , AUX
                 	MOVI LDR_NO_LOW,LOW(LDR_NO_BUFFER)
                +
000393 e001     +ldi AUX , HIGH ( LDR_NO_BUFFER )
000394 2e30     +mov LDR_NO_HIGH , AUX
                 	MOVI LDR_NO_HIGH,HIGH(LDR_NO_BUFFER)
                 
                +
000395 e508     +ldi AUX , LOW ( LDR_NE_BUFFER )
000396 2e40     +mov LDR_NE_LOW , AUX
                 	MOVI LDR_NE_LOW,LOW(LDR_NE_BUFFER)
                +
000397 e001     +ldi AUX , HIGH ( LDR_NE_BUFFER )
000398 2e50     +mov LDR_NE_HIGH , AUX
                 	MOVI LDR_NE_HIGH,HIGH(LDR_NE_BUFFER)
                 
                +
000399 e600     +ldi AUX , LOW ( LDR_SE_BUFFER )
00039a 2e60     +mov LDR_SE_LOW , AUX
                 	MOVI LDR_SE_LOW,LOW(LDR_SE_BUFFER)
                +
00039b e001     +ldi AUX , HIGH ( LDR_SE_BUFFER )
00039c 2e70     +mov LDR_SE_HIGH , AUX
                 	MOVI LDR_SE_HIGH,HIGH(LDR_SE_BUFFER)
                 
                +
00039d e608     +ldi AUX , LOW ( LDR_SO_BUFFER )
00039e 2eb0     +mov LDR_SO_LOW , AUX
                 	MOVI LDR_SO_LOW,LOW(LDR_SO_BUFFER)
                +
00039f e001     +ldi AUX , HIGH ( LDR_SO_BUFFER )
0003a0 2ec0     +mov LDR_SO_HIGH , AUX
                 	MOVI LDR_SO_HIGH,HIGH(LDR_SO_BUFFER)
                 
0003a1 2700      	CLR AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
0003a2 9300 0174+.else 
                +sts COUNTER , AUX
                 	OUTPUT COUNTER,AUX
0003a4 9508      RET
                 
                 LDRS_READ:
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
0003a5 9100 0174+.else 
                +lds AUX , COUNTER
                 	INPUT AUX,COUNTER			;CHEQUEO QUE SEA MENOR A CANT_SAMPLES. SI ES MAYOR, RESETEO LOS PUNTEROS. [EL BUFFER ESTA LLENO, SACO LA PRIMER MUESTRA].
0003a7 3008      	CPI AUX,CANT_SAMPLES
0003a8 f0f1      	BREQ _LDRS_POINTERS_RESET
                 LDRS_POINTERS_RESET_RETURN:
                 
                +
                +
                +.if COUNTER < 0x40
                +in AUX , COUNTER
0003a9 9100 0174+.else 
                +lds AUX , COUNTER
                 	INPUT AUX,COUNTER
0003ab 9503      		INC AUX
                +
                +
                +.if COUNTER < 0x40
                +out COUNTER , AUX
0003ac 9300 0174+.else 
                +sts COUNTER , AUX
                 	OUTPUT COUNTER,AUX
                 
0003ae d074      	RCALL READ_LDR_NO										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
0003af 2de2     +MOV ZL , LDR_NO_LOW
0003b0 2df3     +MOV ZH , LDR_NO_HIGH
0003b1 9341     +ST Z + , ADC_DATA_H
0003b2 2e2e     +MOV LDR_NO_LOW , ZL
0003b3 2e3f     +MOV LDR_NO_HIGH , ZH
                 	SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
0003b4 d07a      	RCALL READ_LDR_NE										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
0003b5 2de4     +MOV ZL , LDR_NE_LOW
0003b6 2df5     +MOV ZH , LDR_NE_HIGH
0003b7 9341     +ST Z + , ADC_DATA_H
0003b8 2e4e     +MOV LDR_NE_LOW , ZL
0003b9 2e5f     +MOV LDR_NE_HIGH , ZH
                 	SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
0003ba d070      	RCALL READ_LDR_SE										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
0003bb 2de6     +MOV ZL , LDR_SE_LOW
0003bc 2df7     +MOV ZH , LDR_SE_HIGH
0003bd 9341     +ST Z + , ADC_DATA_H
0003be 2e6e     +MOV LDR_SE_LOW , ZL
0003bf 2e7f     +MOV LDR_SE_HIGH , ZH
                 	SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
                 
0003c0 d066      	RCALL READ_LDR_SO										;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
                +
                +
                +
                +
                +
0003c1 2deb     +MOV ZL , LDR_SO_LOW
0003c2 2dfc     +MOV ZH , LDR_SO_HIGH
0003c3 9341     +ST Z + , ADC_DATA_H
0003c4 2ebe     +MOV LDR_SO_LOW , ZL
0003c5 2ecf     +MOV LDR_SO_HIGH , ZH
                 	SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H					;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
0003c6 9508      RET
                 
                 _LDRS_POINTERS_RESET:
0003c7 dfc9      	RCALL LDRS_POINTERS_RESET
0003c8 cfe0      RJMP LDRS_POINTERS_RESET_RETURN
                 
                 LDRS_MEAN:
                 ;OBS: PARA HACER EL PROMEDIO NO IMPORTA SI NO SE TOMARON CANT_SAMPLES, EL BUFFER ESTA INICIALIZADO CON CERO.
0003c9 e008      	LDI	AUX,CANT_SAMPLES					;VECTMEAN NECESITA LA CANTIDAD DE LAS MUESTRAS
                 
                +
0003ca e5e0     +ldi ZL , LOW ( LDR_NO_BUFFER )
0003cb e0f1     +ldi ZH , HIGH ( LDR_NO_BUFFER )
                 	LDIW Z,LDR_NO_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
0003cc 930f     +PUSH AUX
0003cd 9161     +LD AUX3 , Z +
0003ce 2711     +CLR AUX1
0003cf 950a     +DEC AUX
0003d0 2722     +CLR AUX2
                +loop_mean :
0003d1 94b8     +CLV
0003d2 9171     +LD AUX4 , Z +
0003d3 0f67     +ADD AUX3 , AUX4
0003d4 1f12     +ADC AUX1 , AUX2
0003d5 950a     +DEC AUX
0003d6 f7d1     +BRNE loop_mean
0003d7 e023     +LDI AUX2 , 3
                +division :
0003d8 9516     +LSR AUX1
0003d9 9567     +ROR AUX3
0003da 952a     +DEC AUX2
0003db f7e1     +BRNE division
0003dc 2f16     +MOV AUX1 , AUX3
0003dd 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_NO_MEAN < 0x40
                +out LDR_NO_MEAN , AUX1
0003de 9310 0170+.else 
                +sts LDR_NO_MEAN , AUX1
                 	OUTPUT LDR_NO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
0003e0 e5e8     +ldi ZL , LOW ( LDR_NE_BUFFER )
0003e1 e0f1     +ldi ZH , HIGH ( LDR_NE_BUFFER )
                 	LDIW Z,LDR_NE_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
0003e2 930f     +PUSH AUX
0003e3 9161     +LD AUX3 , Z +
0003e4 2711     +CLR AUX1
0003e5 950a     +DEC AUX
0003e6 2722     +CLR AUX2
                +loop_mean :
0003e7 94b8     +CLV
0003e8 9171     +LD AUX4 , Z +
0003e9 0f67     +ADD AUX3 , AUX4
0003ea 1f12     +ADC AUX1 , AUX2
0003eb 950a     +DEC AUX
0003ec f7d1     +BRNE loop_mean
0003ed e023     +LDI AUX2 , 3
                +division :
0003ee 9516     +LSR AUX1
0003ef 9567     +ROR AUX3
0003f0 952a     +DEC AUX2
0003f1 f7e1     +BRNE division
0003f2 2f16     +MOV AUX1 , AUX3
0003f3 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_NE_MEAN < 0x40
                +out LDR_NE_MEAN , AUX1
0003f4 9310 0171+.else 
                +sts LDR_NE_MEAN , AUX1
                 	OUTPUT LDR_NE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
0003f6 e6e0     +ldi ZL , LOW ( LDR_SE_BUFFER )
0003f7 e0f1     +ldi ZH , HIGH ( LDR_SE_BUFFER )
                 	LDIW Z,LDR_SE_BUFFER					;UBICO EL LDR_NO EN UN PUNTERO.
                +
0003f8 930f     +PUSH AUX
0003f9 9161     +LD AUX3 , Z +
0003fa 2711     +CLR AUX1
0003fb 950a     +DEC AUX
0003fc 2722     +CLR AUX2
                +loop_mean :
0003fd 94b8     +CLV
0003fe 9171     +LD AUX4 , Z +
0003ff 0f67     +ADD AUX3 , AUX4
000400 1f12     +ADC AUX1 , AUX2
000401 950a     +DEC AUX
000402 f7d1     +BRNE loop_mean
000403 e023     +LDI AUX2 , 3
                +division :
000404 9516     +LSR AUX1
000405 9567     +ROR AUX3
000406 952a     +DEC AUX2
000407 f7e1     +BRNE division
000408 2f16     +MOV AUX1 , AUX3
000409 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_SE_MEAN < 0x40
                +out LDR_SE_MEAN , AUX1
00040a 9310 0172+.else 
                +sts LDR_SE_MEAN , AUX1
                 	OUTPUT LDR_SE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
                 
                +
00040c e6e8     +ldi ZL , LOW ( LDR_SO_BUFFER )
00040d e0f1     +ldi ZH , HIGH ( LDR_SO_BUFFER )
                 	LDIW Z,LDR_SO_BUFFER					;UBICO EL LDR_SO EN UN PUNTERO.
                +
00040e 930f     +PUSH AUX
00040f 9161     +LD AUX3 , Z +
000410 2711     +CLR AUX1
000411 950a     +DEC AUX
000412 2722     +CLR AUX2
                +loop_mean :
000413 94b8     +CLV
000414 9171     +LD AUX4 , Z +
000415 0f67     +ADD AUX3 , AUX4
000416 1f12     +ADC AUX1 , AUX2
000417 950a     +DEC AUX
000418 f7d1     +BRNE loop_mean
000419 e023     +LDI AUX2 , 3
                +division :
00041a 9516     +LSR AUX1
00041b 9567     +ROR AUX3
00041c 952a     +DEC AUX2
00041d f7e1     +BRNE division
00041e 2f16     +MOV AUX1 , AUX3
00041f 910f     +POP AUX
                 	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
                +
                +
                +.if LDR_SO_MEAN < 0x40
                +out LDR_SO_MEAN , AUX1
000420 9310 0173+.else 
                +sts LDR_SO_MEAN , AUX1
                 	OUTPUT LDR_SO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
000422 9508      RET	
                 
                 
                 
                 
                 READ_LDR_NO:
000423 e033      	LDI ADC_DATA_L,LDR_NO
000424 dc50      	RCALL ADC_SELECT_INPUT
000425 dc56      	RCALL ADC_SIMPLE_CONVERSION
000426 9508      RET
                 
                 READ_LDR_SO:
000427 e035      	LDI ADC_DATA_L,LDR_SO
000428 dc4c      	RCALL ADC_SELECT_INPUT
000429 dc52      	RCALL ADC_SIMPLE_CONVERSION
00042a 9508      RET
                 
                 READ_LDR_SE:
00042b e034      	LDI ADC_DATA_L,LDR_SE
00042c dc48      	RCALL ADC_SELECT_INPUT
00042d dc4e      	RCALL ADC_SIMPLE_CONVERSION
00042e 9508      RET
                 
                 READ_LDR_NE:
00042f e032      	LDI ADC_DATA_L,LDR_NE
000430 dc44      	RCALL ADC_SELECT_INPUT
000431 dc4a      	RCALL ADC_SIMPLE_CONVERSION
                 .include "MOTORS.inc"
000432 9508      
                 ;
                 ;							MOTORS.inc
                 ;
                 ;-------------------------------------------------------------------------
                 .CSEG
                 
                 MOTORS_INIT:
                +
                +
                +.if DDRD < 0x40
000433 b10a     +in AUX , DDRD
                +.else 
                +lds AUX , DDRD
                 	INPUT AUX,DDRD
000434 790f      	ANDI AUX,(~((1<<DDD5)|(1<<DDD6)))
000435 6600      	ORI AUX,((1<<DDD5)|(1<<DDD6))
                +
                +
                +.if DDRD < 0x40
000436 b90a     +out DDRD , AUX
                +.else 
                +sts DDRD , AUX
                 	OUTPUT DDRD,AUX
                 
                +
                +
                +.if PORTD < 0x40
000437 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000438 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
000439 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
00043a 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
00043b 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
                +
                +
                +.if OCR1AH < 0x40
                +out OCR1AH , AUX
00043d 9300 0089+.else 
                +sts OCR1AH , AUX
                 	OUTPUT	OCR1AH,AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
00043f 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                +
                +
                +.if OCR1BH < 0x40
                +out OCR1BH , AUX
000441 9300 008b+.else 
                +sts OCR1BH , AUX
                 	OUTPUT	OCR1BH,AUX
000443 9508      RET
                 
                 MOTOR_AZIMUT_EAST:
                 ;RECIBE EN AUX3 EL VALOR A MOVERSE EN EL PWM
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PW,
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +in AUX , BT_MANUAL_MOTORS
000444 9100 0177+.else 
                +lds AUX , BT_MANUAL_MOTORS
                 	INPUT AUX,BT_MANUAL_MOTORS
000446 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: LOS MOTORES SE MANEJAN MANUALMENTE.
000447 f109      	BREQ ORDEN_BT_NO_TOCAR_MOTORES			;[FLAG=0x00]: LOS MOTORES SE MANEJAN AUTOMATICAMENTE.
                 
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000448 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
00044a 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
00044b 6851      	ORI PWM_DATA,((1<<COM1A1)|(0<<COM1A0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
00044c 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
00044e b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
00044f 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
000450 6400      	ORI AUX,((0<<MOT_1)|(1<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
000451 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
000452 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
000453 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
000455 d014      	rcall smooth_move_azimut
                 	;OUTPUT	OCR1AL,AUX1
000456 9508      RET
                 
                 MOTOR_AZIMUT_WEST:
                 ;RECIBE EN AUX3 EL VALOR A MOVERSE EN EL PWM
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +in AUX , BT_MANUAL_MOTORS
000457 9100 0177+.else 
                +lds AUX , BT_MANUAL_MOTORS
                 	INPUT AUX,BT_MANUAL_MOTORS
000459 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: LOS MOTORES SE MANEJAN MANUALMENTE.
00045a f071      	BREQ ORDEN_BT_NO_TOCAR_MOTORES			;[FLAG=0x00]: LOS MOTORES SE MANEJAN AUTOMATICAMENTE.
                 
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
00045b 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
00045d 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
00045e 6851      	ORI PWM_DATA,((1<<COM1A1)|(0<<COM1A0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
00045f 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
000461 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000462 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
000463 6200      	ORI AUX,((1<<MOT_1)|(0<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
000464 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
000465 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
000466 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
000468 d001      	rcall smooth_move_azimut
                 	;OUTPUT	OCR1AL,AUX1
                 ORDEN_BT_NO_TOCAR_MOTORES:
000469 9508      RET
                 
                 smooth_move_azimut:
00046a 2777      	clr aux4
00046b 9573      _s:	inc aux4
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
00046c 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
00046e 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
000470 dd6c      	RCALL DELAY_100us
000471 3a7a      	cpi aux4,170
000472 f410      	brsh nxt
000473 dd69      	rcall delay_100us
000474 dd68      	rcall delay_100us
                 nxt:
000475 dd67      	rcall delay_100us
000476 dd66      	rcall delay_100us
000477 1776      	cp aux4,AUX3
000478 f390      	brlo _s
000479 9508      ret
                 
                 MOTOR_ELEVATION_SOUTH:
                 ;RECIBE EN AUX3 EL VALOR A MOVERSE EN EL PWM
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +in AUX , BT_MANUAL_MOTORS
00047a 9100 0177+.else 
                +lds AUX , BT_MANUAL_MOTORS
                 	INPUT AUX,BT_MANUAL_MOTORS
00047c 3f0f      	CPI AUX,0xFF							;[FLAG=0xFF]: LOS MOTORES SE MANEJAN MANUALMENTE.
00047d f359      	BREQ ORDEN_BT_NO_TOCAR_MOTORES			;[FLAG=0x00]: LOS MOTORES SE MANEJAN AUTOMATICAMENTE.
                 
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
00047e 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000480 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
000481 6251      	ORI PWM_DATA,((1<<COM1B1)|(0<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
000482 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
000484 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000485 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
000486 6200      	ORI AUX,((1<<MOT_1)|(0<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
000487 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
000488 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
000489 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 	
00048b d014      	rcall smooth_move_elevation
                 	;OUTPUT	OCR1BL,AUX1
00048c 9508      RET
                 
                 MOTOR_ELEVATION_NORTH:
                 ;RECIBE EN AUX3 EL VALOR A MOVERSE EN EL PWM
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if BT_MANUAL_MOTORS < 0x40
                +in AUX , BT_MANUAL_MOTORS
00048d 9100 0177+.else 
                +lds AUX , BT_MANUAL_MOTORS
                 	INPUT AUX,BT_MANUAL_MOTORS
00048f 3f0f      	CPI AUX,0xFF						;[FLAG=0xFF]: LOS MOTORES SE MANEJAN MANUALMENTE.
000490 f2c1      	BREQ ORDEN_BT_NO_TOCAR_MOTORES			;[FLAG=0x00]: LOS MOTORES SE MANEJAN AUTOMATICAMENTE.
                 
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
000491 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
000493 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
000494 6251      	ORI PWM_DATA,((1<<COM1B1)|(0<<COM1B0)|(1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
000495 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
000497 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
000498 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
000499 6400      	ORI AUX,((0<<MOT_1)|(1<<MOT_2))			;CHEQUEAR CUANDO SE CONECTE
                +
                +
                +.if PORTD < 0x40
00049a b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
00049b 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
00049c 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 
00049e d001      	RCALL smooth_move_elevation
00049f 9508      RET
                 
                 smooth_move_elevation:
0004a0 2777      	clr aux4
0004a1 9573      _sM:	inc aux4
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
0004a2 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
0004a4 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
0004a6 dd36      	RCALL DELAY_100us
0004a7 3a7a      	cpi aux4,170
0004a8 f410      	brsh nxtM
0004a9 dd33      	rcall delay_100us
0004aa dd32      	rcall delay_100us
                 nxtM:
0004ab dd31      	rcall delay_100us
0004ac dd30      	rcall delay_100us
0004ad 1776      	cp aux4,AUX3
0004ae f390      	brlo _sM
0004af 9508      ret
                 
                 MOTOR_AZIMUT_OFF:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
0004b0 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
0004b2 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
0004b3 6051      	ORI PWM_DATA,((1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
0004b4 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
0004b6 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
0004b7 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
0004b8 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
                +
                +
                +.if OCR1AL < 0x40
                +in AUX4 , OCR1AL
0004b9 9170 0088+.else 
                +lds AUX4 , OCR1AL
                 	INPUT AUX4,OCR1AL
                 
                 brake_AZIMUT:
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX4
0004bb 9370 0088+.else 
                +sts OCR1AL , AUX4
                 	OUTPUT	OCR1AL,AUX4
0004bd 387c      	cpI aux4,140
0004be f410      	brSH	ASDF
0004bf dd1d      	RCALL DELAY_100us
0004c0 dd1c      	RCALL DELAY_100us
0004c1 dd1b      ASDF:	RCALL DELAY_100us
0004c2 dd1a      	RCALL DELAY_100us
0004c3 dd19      	RCALL DELAY_100us
0004c4 957a      	dec aux4
0004c5 f7a9      	brne brake_AZIMUT
                 
0004c6 2700      	CLR	AUX
                +
                +
                +.if OCR1AL < 0x40
                +out OCR1AL , AUX
0004c7 9300 0088+.else 
                +sts OCR1AL , AUX
                 	OUTPUT	OCR1AL,AUX
0004c9 9508      RET
                 
                 MOTOR_ELEVATION_OFF:
                 ;SETEO MOT_1 Y MOT_2
                 ;SETEO LOS ENABLE
                 ;SETEO EL PWM
                +
                +
                +.if TCCR1A < 0x40
                +in PWM_DATA , TCCR1A
0004ca 9150 0080+.else 
                +lds PWM_DATA , TCCR1A
                 	INPUT PWM_DATA,TCCR1A	;Timer/counter control register A
0004cc 705c      	ANDI PWM_DATA,(~((1<<COM1A1)|(1<<COM1B1)|(1<<COM1A0)|(1<<COM1B0)|(1<<WGM10)|(1<<WGM11)))
0004cd 6051      	ORI PWM_DATA,((1<<WGM10)|(0<<WGM11))	;fast PWM, non-inverting
                +
                +
                +.if TCCR1A < 0x40
                +out TCCR1A , PWM_DATA
0004ce 9350 0080+.else 
                +sts TCCR1A , PWM_DATA
                 	OUTPUT TCCR1A,PWM_DATA
                 
                +
                +
                +.if PORTD < 0x40
0004d0 b10b     +in AUX , PORTD
                +.else 
                +lds AUX , PORTD
                 	INPUT AUX,PORTD
0004d1 790f      	ANDI AUX,(~((1<<MOT_1)|(1<<MOT_2)))
                +
                +
                +.if PORTD < 0x40
0004d2 b90b     +out PORTD , AUX
                +.else 
                +sts PORTD , AUX
                 	OUTPUT PORTD,AUX
                 
                +
                +
                +.if OCR1BL < 0x40
                +in AUX4 , OCR1BL
0004d3 9170 008a+.else 
                +lds AUX4 , OCR1BL
                 	INPUT AUX4,OCR1BL
                 
                 brake_elevation:
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX4
0004d5 9370 008a+.else 
                +sts OCR1BL , AUX4
                 	OUTPUT	OCR1BL,AUX4
0004d7 3a7a      	cpI aux4,170
0004d8 f410      	brSH	ASF
0004d9 dd03      	RCALL DELAY_100us
0004da dd02      	RCALL DELAY_100us
0004db dd01      ASF:	RCALL DELAY_100us
0004dc dd00      	RCALL DELAY_100us
0004dd dcff      	RCALL DELAY_100us
0004de 957a      	dec aux4
0004df f7a9      	brne brake_elevation
                 
0004e0 2700      	CLR	AUX
                +
                +
                +.if OCR1BL < 0x40
                +out OCR1BL , AUX
0004e1 9300 008a+.else 
                +sts OCR1BL , AUX
                 	OUTPUT	OCR1BL,AUX
                 
0004e3 9508      RET
                 
                 RETURN_TO_ORIGIN:
                 ;BIEN HARDCODEADO.
                 ;EL SOL SALE DEL ESTE Y SE PONE EN EL OESTE.
                +
                +
                +.if FLAG_AT_NIGHT < 0x40
                +in AUX , FLAG_AT_NIGHT
0004e4 9100 0178+.else 
                +lds AUX , FLAG_AT_NIGHT
                 	INPUT AUX,FLAG_AT_NIGHT
0004e6 3f0f      	CPI AUX,0xFF			;SI ESTA PRENDIDO EL FLAG, QUIERE DECIR QUE YA LO HIZO A LA NOCHE
0004e7 f091      	BREQ YA_RETORNO_AL_ORIGEN
0004e8 ef0f      	SER AUX
                +
                +
                +.if FLAG_AT_NIGHT < 0x40
                +out FLAG_AT_NIGHT , AUX
0004e9 9300 0178+.else 
                +sts FLAG_AT_NIGHT , AUX
                 	OUTPUT FLAG_AT_NIGHT,AUX
0004eb ef60      	LDI AUX3,240
0004ec df57      	RCALL MOTOR_AZIMUT_EAST
                 ;	RCALL MOTOR_AZIMUT_WEST
0004ed dd0c      		RCALL DELAY_500ms
0004ee dd0b      		RCALL DELAY_500ms
0004ef dd0a      		RCALL DELAY_500ms
0004f0 dd09      		RCALL DELAY_500ms
0004f1 dd08      		RCALL DELAY_500ms
0004f2 dd07      		RCALL DELAY_500ms
0004f3 dd06      		RCALL DELAY_500ms
0004f4 dd05      		RCALL DELAY_500ms
0004f5 dd04      		RCALL DELAY_500ms
0004f6 dd03      		RCALL DELAY_500ms
0004f7 dd02      		RCALL DELAY_500ms
0004f8 dd01      		RCALL DELAY_500ms
0004f9 dfb6      	RCALL MOTOR_AZIMUT_OFF
                 YA_RETORNO_AL_ORIGEN:
0004fa 9508      RET
                 
                 .include "MESSAGES.inc"
                 
                 ;MENSAJES EN ROM
0004fb 4942
0004fc 4e45
0004fd 4556
0004fe 494e
0004ff 4f44
000500 0d21
000501 470a
000502 4152
000503 4943
000504 5341
000505 5020
000506 524f
000507 5520
000508 4153
000509 2052
00050a 4c45
00050b 5320
00050c 4c4f
00050d 5241
00050e 5420
00050f 4152
000510 4b43
000511 5245
000512 0d21
000513 000a      MSJ_PROJECT_NAME:			.DB	"BIENVENIDO!",'\r','\n',"GRACIAS POR USAR EL SOLAR TRACKER!",'\r','\n',0
000514 414c
000515 5420
000516 4e45
000517 4953
000518 4e4f
000519 4420
00051a 2045
00051b 414c
00051c 4220
00051d 5441
00051e 5245
00051f 4149
000520 4520
000521 3a53
000522 0020      MSJ_V_BAT:					.DB	"LA TENSION DE LA BATERIA ES: ",0
000523 414c
000524 5420
000525 4e45
000526 4953
000527 4e4f
000528 4420
000529 4c45
00052a 5020
00052b 4e41
00052c 4c45
00052d 4520
00052e 3a53
00052f 0020      MSJ_V_PANEL:				.DB "LA TENSION DEL PANEL ES: ",0
000530 4e45
000531 4543
000532 444e
000533 5349
000534 4554
000535 4c20
000536 2041
000537 554c
000538 2e5a
000539 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(6): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(172): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
00053a 0000      MSJ_LIGHT_ON:				.DB "ENCENDISTE LA LUZ.",'\r','\n',0
00053b 5041
00053c 4741
00053d 5341
00053e 4554
00053f 4c20
000540 2041
000541 554c
000542 2e5a
000543 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(7): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(172): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
000544 0000      MSJ_LIGHT_OFF:				.DB "APAGASTE LA LUZ.",'\r','\n',0
000545 4553
000546 4d20
000547 564f
000548 4f49
000549 4520
00054a 204c
00054b 4150
00054c 454e
00054d 204c
00054e 4c41
00054f 4520
000550 5453
000551 2e45
000552 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(8): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(172): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
000553 0000      MSJ_AZIMUT_EAST:			.DB "SE MOVIO EL PANEL AL ESTE.",'\r','\n',0
000554 4553
000555 4d20
000556 564f
000557 4f49
000558 4520
000559 204c
00055a 4150
00055b 454e
00055c 204c
00055d 4c41
00055e 4f20
00055f 5345
000560 4554
000561 0d2e
000562 000a      MSJ_AZIMUT_WEST:			.DB	"SE MOVIO EL PANEL AL OESTE.",'\r','\n',0
000563 4553
000564 4d20
000565 564f
000566 4f49
000567 4520
000568 204c
000569 4150
00056a 454e
00056b 204c
00056c 4c41
00056d 4e20
00056e 524f
00056f 4554
000570 0d2e
000571 000a      MSJ_ELEVATION_NORTH:		.DB "SE MOVIO EL PANEL AL NORTE.",'\r','\n',0
000572 4553
000573 4d20
000574 564f
000575 4f49
000576 4520
000577 204c
000578 4150
000579 454e
00057a 204c
00057b 4c41
00057c 5320
00057d 5255
00057e 0d2e
00057f 000a      MSJ_ELEVATION_SOUTH:		.DB	"SE MOVIO EL PANEL AL SUR.",'\r','\n',0
000580 414c
000581 4c20
000582 5a55
000583 5020
000584 5341
000585 2041
000586 2041
000587 4f43
000588 544e
000589 4f52
00058a 414c
00058b 5352
00058c 2045
00058d 5541
00058e 4f54
00058f 414d
000590 4954
000591 4143
000592 454d
000593 544e
000594 2e45
000595 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(12): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(172): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
000596 0000      MSJ_MANUAL_LIGHT_OFF:		.DB "LA LUZ PASA A CONTROLARSE AUTOMATICAMENTE.",'\r','\n',0
000597 4f4c
000598 2053
000599 4f4d
00059a 4f54
00059b 4552
00059c 2053
00059d 4150
00059e 4153
00059f 204e
0005a0 2041
0005a1 4f43
0005a2 544e
0005a3 4f52
0005a4 414c
0005a5 5352
0005a6 2045
0005a7 5541
0005a8 4f54
0005a9 414d
0005aa 4954
0005ab 4143
0005ac 454d
0005ad 544e
0005ae 2e45
0005af 0a0d
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(13): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(172): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
0005b0 0000      MSJ_MANUAL_MOTORS_OFF:		.DB "LOS MOTORES PASAN A CONTROLARSE AUTOMATICAMENTE.",'\r','\n',0
0005b1 4c45
0005b2 4320
0005b3 4d4f
0005b4 4e41
0005b5 4f44
0005b6 4920
0005b7 474e
0005b8 4552
0005b9 4153
0005ba 4f44
0005bb 4520
0005bc 2053
0005bd 4e49
0005be 4156
0005bf 494c
0005c0 4f44
0005c1 0d21
0005c2 000a      MSJ_INVALID_COMMAND:		.DB "EL COMANDO INGRESADO ES INVALIDO!",'\r','\n',0
                 ;MSJ_DISCONNECTED_BATTERY:	.DB "LA BATERIA ESTA DESCONECTADA!",'\r','\n',0
                 ;MSJ_DISCONNECTED_PANEL:	.DB "EL PANEL ESTA DESCONECTADO!",'\r','\n',0
                 
0005c3 190c
0005c4 3326
0005c5 4c40
0005c6 6659
0005c7 7f73
0005c8 998d
0005c9 b3a6
0005ca cdc0
0005cb e6d9
0005cc fff3      VPANEL_DIG_TABLE:			.DB	12,25,38,51,64,76,89,102,115,127,141,153,166,179,192,205,217,230,243,255
0005cd 0100
0005ce 0302
0005cf 0504
0005d0 0605
0005d1 0807
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(19): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(172): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
0005d2 0009      VPANEL_DEC_TABLE:			.DB 0,1,2,3,4,5,5,6,7,8,9
                 
0005d3 2010
0005d4 4130
0005d5 6151
0005d6 8272
0005d7 a392
0005d8 c3b3
0005d9 e4d4
0005da fff4      VBATTERY_DIG_TABLE:			.DB 16,32,48,65,81,97,114,130,146,163,179,195,212,228,244,255
0005db 0100
0005dc 0201
0005dd 0303
0005de 0504
0005df 0605
0005e0 0707
0005e1 0908
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc(22): warning: .cseg .db misalignment - padding zero byte
C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA.asm(172): 'C:\Users\MAU\Desktop\2016_1c_trabajo_practico-solar_tracker\codigo\Solar Tracker PARA PRUEBA\Solar Tracker PARA PRUEBA\MESSAGES.inc' included form here
0005e2 0009      VBATTERY_DEC_TABLE:			.DB 0,1,1,2,3,3,4,5,5,6,7,7,8,9,9
                 
                 
                 
                 
                 	


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega88" register use summary:
r0 :   2 r1 :   2 r2 :   5 r3 :   5 r4 :   5 r5 :   5 r6 :   5 r7 :   5 
r8 :   5 r9 :   1 r10:   6 r11:   5 r12:   5 r13:   0 r14:   0 r15:   0 
r16: 306 r17:  92 r18:  42 r19:  16 r20:  21 r21:  56 r22:  40 r23: 106 
r24:   0 r25:   0 r26:  25 r27:  21 r28:   2 r29:   2 r30:  47 r31:  43 
x  :  41 y  :   1 z  :  22 
Registers used: 30 out of 35 (85.7%)

"ATmega88" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   4 add   :  17 adiw  :   0 and   :   0 
andi  :  44 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   4 break :   0 breq  :  27 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  17 brlt  :   0 brmi  :   0 
brne  :  25 brpl  :   0 brsh  :   9 brtc  :   2 brts  :   2 brvc  :   2 
brvs  :   0 bset  :   0 bst   :   0 cbi   :   0 cbr   :   1 clc   :   4 
clh   :   0 cli   :   0 cln   :   0 clr   :  39 cls   :   0 clt   :   2 
clv   :   4 clz   :   0 com   :   0 cp    :   8 cpc   :   0 cpi   :  43 
cpse  :   0 dec   :  27 eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 
icall :   0 ijmp  :   0 in    :  19 inc   :  15 ld    :  10 ldd   :   0 
ldi   : 163 lds   :  45 lpm   :   8 lsl   :   0 lsr   :   4 mov   :  56 
movw  :   4 mul   :   4 muls  :   0 mulsu :   0 neg   :   0 nop   :   5 
or    :   1 ori   :  32 out   :  21 pop   :  23 push  :  23 rcall : 163 
ret   :  53 reti  :   4 rjmp  :  33 rol   :   0 ror   :   4 sbc   :   0 
sbci  :   0 sbi   :   0 sbic  :   0 sbis  :   0 sbiw  :   0 sbr   :   2 
sbrc  :   1 sbrs  :   0 sec   :   2 seh   :   0 sei   :   1 sen   :   0 
ser   :   7 ses   :   0 set   :   2 sev   :   0 sez   :   0 sleep :   1 
spm   :   0 st    :  48 std   :   0 sts   :  78 sub   :  12 subi  :   4 
swap  :   0 tst   :   4 wdr   :   0 
Instructions used: 52 out of 111 (46.8%)

"ATmega88" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000bc6   2508    464   2972    8192  36.3%
[.dseg] 0x000100 0x000179      0    121    121    1024  11.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 7 warnings
