;-------------------------------------------------------------------------
;
;							BATTERY.inc
;
;-------------------------------------------------------------------------
.CSEG

BATTERY_INIT:
	INPUT AUX,DDRD
	ANDI AUX,(~((1<<DDD4)|(1<<DDD7)))	;Mascara para tocar solo D3
	ORI AUX,((1<<DDD4)|(1<<DDD7))
	OUTPUT DDRD,AUX
	RCALL INDICATE_BATTERY_LOW

	;INICIALIZO LA INFORMACION DE LA TENSION PARA TRANSMITIR POR BLUETOOTH
	LDIW X,V_BATTERY_DATA
	STI	X+,'0'
	STI	X+,'0'
	STI	X+,'.'
	STI	X+,'0'
	STI	X+,'V'
	STI X+,'\r'
	STI X+,'\n'
	STI	X,0

RET

READ_V_BATTERY:
		LDI ADC_DATA_L,ADC_BATTERY			;ELIJO EL PIN DE LA BATERÍA
		RCALL ADC_SELECT_INPUT				;LLAMO LA FUNCION PARA SELECCIONAR LA BATERIA
		RCALL ADC_SIMPLE_CONVERSION			;LLAMO LA FUNCION PARA MEDIR
RET

CHECK_IF_BATTERY_MINIMUM:
	CLC
	CPI		ADC_DATA_H,MIN_BATTERY_VALUE	;COMPARAR PARA VER SI HAY SUFICIENTE BATERIA PARA OPERAR
	BRCS	_INDICATE_BATTERY_LOW						;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
	RCALL INDICATE_BATTERY_OK
	
RETURN_INDICATE_BATTERY_LOW:
RET

_INDICATE_BATTERY_LOW:
	RCALL INDICATE_BATTERY_LOW
	SEC										;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
RJMP RETURN_INDICATE_BATTERY_LOW

INDICATE_BATTERY_LOW:
	INPUT	AUX,PORTD
	ANDI	AUX,(~((1<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW)))
	ORI		AUX,((1<<PIN_BATTERY_LED_OK)|(0<<PIN_BATTERY_LED_LOW))		;PRENDE POR CERO.
	OUTPUT	PORTD,AUX
RET

INDICATE_BATTERY_OK:
	INPUT	AUX,PORTD
	ANDI	AUX,(~((1<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW)))
	ORI		AUX,((0<<PIN_BATTERY_LED_OK)|(1<<PIN_BATTERY_LED_LOW))		;PRENDE POR CERO.
	OUTPUT	PORTD,AUX
	CLC										;[CARRY=1]: BATTERY LOW. [CARRY=0]: BATTERY OK
RET


VBATTERY_TO_ASCII:

					LDIW X,V_BATTERY_DATA
VBATTERY_DIG:		LDIW Z,(VBATTERY_DIG_TABLE*2)
					CLR AUX1
					CLR AUX2
LOOP_DIG_BATTERY:			
					RCALL SET_VBATTERY_DIG
					BRTS V_BATTERY_DEC
					INC AUX1
					CPI AUX1,10
					BRLO LOWER_THAN_10_DIG_BATTERY
					CLR AUX1
					INC AUX2
LOWER_THAN_10_DIG_BATTERY: BRTC LOOP_DIG_BATTERY
					STI X+,48+1
					STI X+,48+5

V_BATTERY_DEC:		LDIW Z,(VBATTERY_DIG_TABLE*2)
					SUBI AUX1,48
					SUBI AUX2,48
					LDI AUX3,10
					MUL AUX2,AUX3
					MOV AUX2,R0
					ADD AUX1,AUX2
					ADDP Z,AUX1
					LPM AUX1,Z
					SUB AUX1,ADC_DATA_H	;ACA AUX1 TIENE QUE ESTAR ENTRE 0 Y 15
	

					STI	X+,'.'
					ldi	aux2,160		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
					MUL	AUX1,AUX2
					MOV	AUX1,R1
					SUB AUX3,AUX1					
					ADDI AUX3,48		;SE TRANSFORMA EN ASCII
					CPI AUX3,':'
					BREQ ajuste_9_bat

vuelvo_9_bat:		ST X+,AUX3	;El ASCII del número en AUX.
					STI	X+,'V'
					STI X+,'\r'
					STI X+,'\n'
					STI	X,0
					CLT
RET	

ajuste_9_bat:
		ldi aux3,'9'
		rjmp vuelvo_9_bat
		
SET_VBATTERY_DIG:
					LPM AUX,Z+
					INC AUX
					CP ADC_DATA_H,AUX
					BRSH END_SET_VBATTERY_DIG
					ADDI AUX1,48
					ADDI AUX2,48
					ST X+,AUX2
					ST X+,AUX1
					SET
END_SET_VBATTERY_DIG:	RET



/*
MAURO:
V_BATTERY_TO_ASCII:

.DEF UNIDAD		= R17		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
.DEF DECENA		= R18		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3
.DEF DECIMAL	= R22		;OJO! LOS PUSE EN AUX1, AUX2 Y AUX3

	PUSH UNIDAD
	PUSH DECENA
	PUSH DECIMAL
	PUSH ADC_DATA_H

	CLR	UNIDAD
	CLR DECENA
	CLR DECIMAL

		TST	ADC_DATA_H
		BREQ NULO
START:	CLC
		SUBI ADC_DATA_H,16
		BRCS OOB
		CPI ADC_DATA_H,16
		BRLO PASSED
		BREQ dec_0
		inc	unidad
		cpi unidad,10
		breq acomodo
		RJMP START

OOB:	NEG ADC_DATA_H

PASSED:	ldi	aux1,160		;MULTIPLICAR POR 160/256. DIVIDIR POR 256 ES QUEDARME CON LA PARTE ALTA
		MUL	ADC_DATA_H,AUX1
		MOV	ADC_DATA_H,R1
dec_0:	MOV	decimal,ADC_DATA_H
	
NULO:
		LDIW	Z,V_BATTERY_DATA
SUBIR_DECENA:
	ADDI	DECENA,48
	ST	Z+,DECENA

SUBIR_UNIDAD:
	ADDI	UNIDAD,48
	ST	Z+,UNIDAD

SUBIR_PUNTO:
	STI		Z+,'.'

SUBIR_DECIMAL:
	ADDI	DECIMAL,48
	ST	Z+,DECIMAL

SUBIR_FINAL:
	STI		Z+,'V'
	STI		Z+,'\r'
	STI		Z+,'\n'
	STI		Z,0

	POP ADC_DATA_H
	POP	DECIMAL
	POP DECENA
	POP UNIDAD
RET	

ACOMODO:
	CLR UNIDAD
	INC DECENA
RJMP START
*/