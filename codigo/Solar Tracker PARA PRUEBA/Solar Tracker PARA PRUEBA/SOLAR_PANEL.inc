;-------------------------------------------------------------------------
;
;							SOLAR_PANEL.inc
;				
;-------------------------------------------------------------------------
.CSEG

SOLAR_PANEL_INIT:
	INPUT AUX,DDRC
	ANDI AUX,(~((1<<DDC0)|(1<<DDC1)))	;Mascara para tocar los leds del panel solar
	ORI AUX,((1<<DDC0)|(1<<DDC1))
	OUTPUT DDRC,AUX
	RCALL INDICATE_SOLAR_PANEL_LOW

	;INICIALIZO LA INFORMACION DE LA TENSION PARA TRANSMITIR POR BLUETOOTH
	LDIW X,V_SOLAR_PANEL_DATA
	STI	X+,'0'
	STI	X+,'0'
	STI	X+,'.'
	STI	X+,'0'
	STI	X+,'V'
	STI X+,'\r'
	STI X+,'\n'
	STI	X,0

RET

READ_V_SOLAR_PANEL:
;RECIBE: NADA
;DEVUELVE: TENSION DEL PANEL EN ADC_DATA_H
	LDI ADC_DATA_L,ADC_SOLAR_PANEL			;ELIJO EL PIN DEL PANEL SOLAR
	RCALL ADC_SELECT_INPUT					;LLAMO LA FUNCION PARA SELECCIONAR EL PANEL SOLAR
	RCALL ADC_SIMPLE_CONVERSION				;LLAMO LA FUNCION PARA MEDIR
RET

CHECK_IF_SOLAR_PANEL_MINIMUM:
	CLC
	CPI		ADC_DATA_H,MIN_SOLAR_PANEL_VALUE	;COMPARAR PARA VER SI HAY SUFICIENTE BATERIA PARA OPERAR
	BRCS	_INDICATE_SOLAR_PANEL_LOW						;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
	RCALL INDICATE_SOLAR_PANEL_OK
	
RETURN_INDICATE_SOLAR_PANEL_LOW:
RET

_INDICATE_SOLAR_PANEL_LOW:
	RCALL INDICATE_SOLAR_PANEL_LOW
	SEC										;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
RJMP RETURN_INDICATE_SOLAR_PANEL_LOW

INDICATE_SOLAR_PANEL_LOW:
	INPUT	AUX,PORTC
	ANDI	AUX,(~((1<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW)))
	ORI		AUX,((1<<PIN_SOLAR_PANEL_LED_OK)|(0<<PIN_SOLAR_PANEL_LED_LOW))		;PRENDE POR CERO.
	OUTPUT	PORTC,AUX
RET

INDICATE_SOLAR_PANEL_OK:
	INPUT	AUX,PORTC
	ANDI	AUX,(~((1<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW)))
	ORI		AUX,((0<<PIN_SOLAR_PANEL_LED_OK)|(1<<PIN_SOLAR_PANEL_LED_LOW))		;PRENDE POR CERO.
	OUTPUT	PORTC,AUX
	CLC										;[CARRY=1]: SOLAR_PANEL LOW. [CARRY=0]: SOLAR_PANEL OK
RET


ORIENTATE_SOLAR_PANEL:
;YA ESTAN LOS PROMEDIOS DE LOS LDR Y HAY QUE COMPARAR Y MOVER EL PANEL.
;PRIMERO EN ASIMUT, LUEGO EN ELEVACION.
;EL SOL SALE DEL ESTE Y SE PONE EN EL OESTE.
	;SI AMBOS SON 0xFn NO SE MUEVE
	INPUT AUX,LDR_NO_MEAN
	INPUT AUX1,LDR_NE_MEAN
	ANDI	AUX,0xF0
	ANDI	AUX1,0xF0
	CPI		AUX,0xF0
	BRNE	NO_SON_F_AZIMUT
	SUB		AUX,AUX1
	BREQ	AMBOS_SON_F_AZIMUT
NO_SON_F_AZIMUT:
	;COMPARAR_NO_NE:
		INPUT AUX,LDR_NO_MEAN
		INPUT AUX1,LDR_NE_MEAN
		ANDI	AUX,0xF0
		ANDI	AUX1,0xF0
		CP AUX,AUX1
		BRLO _MOTOR_AZIMUT_EAST
	RETURN_MOTOR_AZIMUT_EAST:

		INPUT AUX,LDR_NO_MEAN
		INPUT AUX1,LDR_NE_MEAN
		ANDI	AUX,0xF0
		ANDI	AUX1,0xF0
		CP AUX1,AUX
		BRLO _MOTOR_AZIMUT_WEST
	RETURN_MOTOR_AZIMUT_WEST:
AMBOS_SON_F_AZIMUT:

;--------------------ACA NOS MOVEMOS CON NORTE Y SUR

	INPUT AUX,LDR_NO_MEAN
	INPUT AUX1,LDR_SO_MEAN
	ANDI	AUX,0xF0
	ANDI	AUX1,0xF0
	CPI		AUX,0xF0
	BRNE	NO_SON_F_ELEVATION
	SUB		AUX,AUX1
	BREQ	AMBOS_SON_F_ELEVATION
NO_SON_F_ELEVATION:
	;COMPARAR_NO_SO:
		INPUT AUX,LDR_NO_MEAN
		INPUT AUX1,LDR_SO_MEAN
		ANDI	AUX,0xF0
		ANDI	AUX1,0xF0
		CP AUX,AUX1
		BRLO _MOTOR_ELEVATION_NORTH
	RETURN_MOTOR_ELEVATION_NORTH:

		INPUT AUX,LDR_NO_MEAN
		INPUT AUX1,LDR_SO_MEAN
		ANDI	AUX,0xF0
		ANDI	AUX1,0xF0
		CP AUX1,AUX
		BRLO _MOTOR_ELEVATION_SOUTH
	RETURN_MOTOR_ELEVATION_SOUTH:
AMBOS_SON_F_ELEVATION:

RET


_MOTOR_AZIMUT_EAST:
	SUB AUX,AUX1
	ORI	AUX,0x80
	MOV	AUX3,AUX

	RCALL MOTOR_AZIMUT_EAST
		RCALL DELAY_50ms
		RCALL DELAY_50ms
		RCALL DELAY_50ms
		RCALL DELAY_50ms
	RCALL MOTOR_AZIMUT_OFF
	;	RCALL DELAY_500ms
RJMP RETURN_MOTOR_AZIMUT_EAST

_MOTOR_AZIMUT_WEST:
	SUB AUX1,AUX
	ORI	AUX1,0x80
	MOV	AUX3,AUX1

	RCALL MOTOR_AZIMUT_WEST
		RCALL DELAY_50ms
		RCALL DELAY_50ms
		RCALL DELAY_50ms
		RCALL DELAY_50ms
	RCALL MOTOR_AZIMUT_OFF
RJMP RETURN_MOTOR_AZIMUT_WEST


_MOTOR_ELEVATION_SOUTH:
	SUB AUX1,AUX
	ORI	AUX1,0xAF
	MOV	AUX3,AUX1

	RCALL MOTOR_ELEVATION_SOUTH
		RCALL DELAY_50ms
		RCALL DELAY_50ms
		RCALL DELAY_50ms
		RCALL DELAY_50ms
	RCALL MOTOR_ELEVATION_OFF
RJMP RETURN_MOTOR_ELEVATION_SOUTH

_MOTOR_ELEVATION_NORTH:
	SUB AUX1,AUX
	ORI	AUX1,0xAF
	MOV	AUX3,AUX1

	RCALL MOTOR_ELEVATION_NORTH
		RCALL DELAY_50ms
		RCALL DELAY_50ms
		RCALL DELAY_50ms
		RCALL DELAY_50ms
	RCALL MOTOR_ELEVATION_OFF
RJMP RETURN_MOTOR_ELEVATION_NORTH




VPANEL_TO_ASCII:
				LDIW X,V_SOLAR_PANEL_DATA	;Apunto X a la sección de memoria donde se guarda la tensión a panel a transmitir
				LDIW Z,(VPANEL_DIG_TABLE*2)	;Apunto Z a la sección de ROM donde se delimita cada unidad
VPANEL_DIG:		CLR AUX1					;Acá se guardará el x1
				CLR AUX2					;Acá se guardará el x10
LOOP_DIG_PANEL:			
				RCALL SET_VPANEL_DIG		;Busco el número
				BRTS V_PANEL_DEC
				INC AUX1					;Incremento para ver si es el siguiente en el prox ciclo
				CPI AUX1,10					;Veo si superé 10 para ver si tengo que poner el x10 en 1
				BRLO LOWER_THAN_10_DIG_PANEL;Si no superé 10, sigo el ciclo
				CLR AUX1					;Si es 10, x1 es 0
				INC AUX2					;Si es 10, x10 es 1
LOWER_THAN_10_DIG_PANEL:	BRTC LOOP_DIG_PANEL
				STI X+,48+1					;Si se completaron todos los ciclos, el x10 es 1
				STI X+,48+9					;Si se completaron todos los ciclos, el x1 es 9
V_PANEL_DEC:	LDIW Z,(VPANEL_DIG_TABLE*2)	;Vuelvo a apuntar Z al comienzo de la tabla donde están los números que delimitan cada unidad
				SUBI AUX1,48				;Lo vuelvo a convertir en número no ASCII
				SUBI AUX2,48
				LDI AUX3,10					;Cargo 10 en AUX3 para multiplicar el x10 por 10 y poder sumarselo al x1
				MUL AUX2,AUX3				;Multiplico el x10 por 10
				MOV AUX2,R0					;Paso el resultado de R0 a AUX2
				ADD AUX1,AUX2				;Sumo x1 y x10 para tener el número completo
				ADDP Z,AUX1					;Le sumo al puntero Z la cantidad de posiciones que se tiene que mover en la tabla para ver el número máximo que puede tener esa unidad
				LPM AUX1,Z					;Cargo el número delimitador
				SUB AUX1,ADC_DATA_H			;Le resto al delimitador el número que medí
				STI	X+,'.'
				SUB AUX3,AUX1					
				ADDI AUX3,49		;SE TRANSFORMA EN ASCII
				CPI AUX3,':'
				BREQ ajuste_9_panel

vuelvo_9_panel:	ST X+,AUX3	;El ASCII del número en AUX.
				STI	X+,'V'
				STI X+,'\r'
				STI X+,'\n'
				STI	X,0
				CLT
RET

ajuste_9_panel:
				ldi aux3,'9'
				rjmp vuelvo_9_panel
	

SET_VPANEL_DIG:
					LPM AUX,Z+				;Leo de tabla en ROM
					INC AUX					;Incremento lo leído porque se usará BRSH
					CP ADC_DATA_H,AUX		;Veo si el número es menor al de la tabla a ver si encontramos el valor
					BRSH END_SET_VPANEL_DIG	;Si es mayor o igual, sigo buscando
											;ESTO NO ES LO QUE QUERES HACER
					ADDI AUX1,48			;Le sumo 48 al número porque los números en ASCII comienzan a partir de 48
					ADDI AUX2,48
					ST X+,AUX2				;Guardo el x10
					ST X+,AUX1				;Guardo el x1
					SET
END_SET_VPANEL_DIG:	RET