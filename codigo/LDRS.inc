;------------------------------------------------------------------

						HEADER DE LOS LDR'S

;------------------------------------------------------------------

LDRS_INIT:
		RCALL LDRS_POINTERS_RESET
LOOP:	CLR ADC_DATA_H
		SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H
		SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H
		SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H
		SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H
		INPUT AUX,COUNTER
		INC AUX
		OUTPUT COUNTER,AUX
		CPI AUX,CANT_SAMPLES			;CHEQUEAR QUE NO ESTE HACIENDO UNO DE MENOS
		BRLO LOOP
		RCALL LDRS_POINTERS_RESET
RET

LDRS_POINTERS_RESET:
	MOVI LDR_NO_LOW,LOW(LDR_NO_VEC)
	MOVI LDR_NO_HIGH,HIGH(LDR_NO_VEC)
	MOVI LDR_SO_LOW,LOW(LDR_SO_VEC)
	MOVI LDR_SO_HIGH,HIGH(LDR_SO_VEC)

	MOVI LDR_SE_LOW,LOW(LDR_SE_VEC)
	MOVI LDR_SE_HIGH,HIGH(LDR_SE_VEC)

	MOVI LDR_NE_LOW,LOW(LDR_NE_VEC)
	MOVI LDR_NE_HIGH,HIGH(LDR_NE_VEC)

;	INPUT AUX,COUNTER
	CLR AUX
	OUTPUT COUNTER,AUX
RET

READ_LDRS:

	INPUT AUX,COUNTER			;CHEQUEO QUE SEA MENOR A CANT_SAMPLES. SI ES MAYOR, RESETEO LOS PUNTEROS. [EL BUFFER ESTA LLENO, SACO LA PRIMER MUESTRA].
	CPI AUX,CANT_SAMPLES
	BREQ _LDRS_POINTERS_RESET
	LDRS_POINTERS_RESET_RETURN:
	INPUT AUX,COUNTER
	INC AUX
	OUTPUT COUNTER,AUX
;PREGUNTAR COMO SE HACE ESTO BIEN!! CUANDO HACES UNA FUNCION Y QUERES COMPARAR E IR A LA FUNCION.
	
	RLDR LDR_NO								;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
	SLDR LDR_NO_LOW,LDR_NO_HIGH,ADC_DATA_H	;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H

	RLDR LDR_SO								;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
	SLDR LDR_SO_LOW,LDR_SO_HIGH,ADC_DATA_H	;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H

	RLDR LDR_SE								;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
	SLDR LDR_SE_LOW,LDR_SE_HIGH,ADC_DATA_H	;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H

	RLDR LDR_NE								;READ_LDR:	DEVUELVE EL RESULTADO DE LA CONVERSION EN ADC_DATA_H
	SLDR LDR_NE_LOW,LDR_NE_HIGH,ADC_DATA_H	;STORE_LDR:	UBICA [LDR_XX_LOW,LDR_XX_HIGH] EN UN PUNTERO Y GUARDA ADC_DATA_H
RET

_LDRS_POINTERS_RESET:
	RCALL LDRS_POINTERS_RESET
	RJMP LDRS_POINTERS_RESET_RETURN

LDRS_MEAN:
;OBS: PARA HACER EL PROMEDIO NO IMPORTA SI NO SE TOMARON CANT_SAMPLES, EL BUFFER ESTA INICIALIZADO CON CERO.

	LDI	AUX,CANT_SAMPLES					;VECTMEAN NECESITA LA CANTIDAD DE LAS MUESTRAS

	LLDR Z,LDR_NO_LOW,LDR_NO_HIGH			;UBICO EL LDR_NO EN UN PUNTERO.
	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
	OUTPUT LDR_NO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.

	LLDR Z,LDR_SO_LOW,LDR_SO_HIGH			;UBICO EL LDR_SO EN UN PUNTERO.
	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
	OUTPUT LDR_SO_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.

	LLDR Z,LDR_SE_LOW,LDR_SE_HIGH			;UBICO EL LDR_SE EN UN PUNTERO.
	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
	OUTPUT LDR_SE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.

	LLDR Z,LDR_NE_LOW,LDR_NE_HIGH			;UBICO EL LDR_NE EN UN PUNTERO.
	VECTMEAN Z,AUX,AUX1						;CALCULO EL PROMEDIO DE Z DE LARGO "AUX" DEJANDO EL DATO EN "AUX1"
	OUTPUT LDR_NE_MEAN,AUX1					;GUARDAMOS EN RAM EL PROMEDIO.
RET	